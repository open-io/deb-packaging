Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 grpc (1.0.0-1) xenial; urgency=medium
 .
   * New upstream release
Author: Romain Acciari <romain.acciari@openio.io>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/.travis.yml
@@ -0,0 +1,54 @@
+# Travis CI has no ability to handle 3 langauges (c, c++, python)
+# and it overrides $CC/$CXX if language is set to c/c++ (only one, not both).
+#
+# Set language to python since at least the result of that is something useful.
+language: python
+
+python:
+    - "2.7"
+    - "3.4"
+
+# Manage the C/C++ compiler manually
+env:
+    - CC=gcc     CXX=g++
+    - CC=gcc-4.8 CXX=g++-4.8
+    - CC=gcc-4.9 CXX=g++-4.9
+    - CC=gcc-5   CXX=g++-5
+    - CC=clang   CXX=clang++
+
+addons:
+    apt:
+        sources:
+            - ubuntu-toolchain-r-test
+        packages:
+            - gcc-4.8
+            - g++-4.8
+            - gcc-4.9
+            - g++-4.9
+            - gcc-5
+            - g++-5
+
+
+before_install:
+    - export PATH=$HOME/.local/bin:$HOME/protobuf/bin:$PATH
+    - export MAKEFLAGS=-j$(grep processor /proc/cpuinfo | wc -l)
+    - $CC --version
+    - $CXX --version
+    - python --version
+    - lsb_release -a
+
+# Seems to be issues with concurrent builds
+#cache:
+#    directories:
+#        - $HOME/protobuf
+
+install:
+    - curl -L https://github.com/google/protobuf/releases/download/v3.0.0-beta-1/protobuf-python-3.0.0-alpha-4.tar.gz | tar xzf -
+      && pushd protobuf-3.0.0-alpha-4
+      && ./configure --prefix=$HOME/protobuf && make && make install
+      && pushd python && python setup.py build && python setup.py install && popd
+      && popd
+
+script:
+    - pushd generator/proto && make && popd
+    - pushd tests && python2 $(which scons) CC=$CC CXX=$CXX && popd
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/CHANGELOG.txt
@@ -0,0 +1,241 @@
+nanopb-0.3.6 (2016-06-19)
+ Protect against corrupted _count fields in pb_release (#205)
+ Fix error in STATIC_ASSERT with multiple files (#203)
+ Add -D option to specify output directory (#193)
+ Generate MIN/MAX/ARRAYSIZE defines for enums (#194)
+ Generate comments about uncalculable message sizes (#195)
+ Documentation updates (#196, #201)
+ Improvements to test cases.
+
+nanopb-0.3.5 (2016-02-13)
+ NOTE: If you are using pb_syshdr.h, you will need to add uint_least8_t
+ definition. See docs/migration.rst for details.
+
+ Fix generator crash with Enum inside Oneof (#188)
+ Fix some generator regressions related to .options file path (#172)
+ Add support for platforms without uint8_t (#191)
+ Allow const parameter to pb_istream_from_buffer (#152)
+ Ignore null pointers in pb_release() (#183)
+ Add support for anonymous unions (#184)
+ Add Python3 support to the generator (#169)
+ Add code generator insertion points to generated files (#178)
+ Improvements to CMake script (#181)
+ Improvements to test cases.
+
+nanopb-0.3.4 (2015-09-26)
+ Fix handling of unsigned 8- and 16-bit enums (issue 164)
+ Fix generator on systems where python = python3. (issue 155)
+ Fix compiler warning on GCC 5.x (issue 171)
+ Make the generator better handle imported .protos (issue 165)
+ Add packed_enum option to generator.
+ Add syntax= line to .proto files (issue 167)
+ Add PlatformIO registry manifest file. (pr 156)
+
+nanopb-0.3.3 (2015-04-10)
+ Fix missing files in Linux binary package (issue 146)
+ Fix generator bug when oneof is first field in a message. (issue 142)
+ Fix generator error when long_names:false is combined with Oneofs. (issue 147)
+ Fix oneof submessage initialization bug. (issue 149)
+ Fix problem with plugin options on Python 2.7.2 and older. (issue 153)
+ Fix crash when callback is inside oneof field. (issue 148)
+ Switch to .tar.gz format for Mac OS X packages. (issue 154)
+ Always define enum long names so that cross-file references work. (issue 118)
+ Add msgid generator option. (issue 151)
+ Improve comment support in .options files. (issue 145)
+ Updates for the CMake rule file, add cmake example.
+ Better error messages for syntax errors in .options file
+
+nanopb-0.3.2 (2015-01-24)
+ Fix memory leaks with PB_ENABLE_MALLOC with some submessage hierarchies (issue 138)
+ Implement support for oneofs (C unions). (issues 131, 141)
+ Add int_size option for generator (issue 139)
+ Add compilation option to disable struct packing. (issue 136)
+ Change PB_RETURN_ERROR() macro to avoid compiler warnings (issue 140)
+ Fix build problems with protoc 3.0.0
+ Add support for POINTER type in extensions
+ Initialize also extension fields to defaults in pb_decode().
+ Detect too large varint values when decoding.
+
+nanopb-0.3.1 (2014-09-11)
+ Fix security issue due to size_t overflows. (issue 132)
+ Fix memory leak with duplicated fields and PB_ENABLE_MALLOC
+ Fix crash if pb_release() is called twice.
+ Fix cyclic message support (issue 130)
+ Fix error in generated initializers for repeated pointer fields.
+ Improve tests (issues 113, 126)
+
+nanopb-0.3.0 (2014-08-26)
+ NOTE: See docs/migration.html or online at
+ http://koti.kapsi.fi/~jpa/nanopb/docs/migration.html
+ for changes in this version. Most importantly, you need to add
+ pb_common.c to the list of files to compile.
+
+ Separated field iterator logic to pb_common.c (issue 128)
+ Change the _count fields to use pb_size_t datatype (issue 82)
+ Added PB_ prefix to macro names (issue 106)
+ Added #if version guard to generated files (issue 129)
+ Added migration document
+
+nanopb-0.2.9 (2014-08-09)
+ NOTE: If you are using the -e option with the generator, you have
+ to prepend . to the argument to get the same behaviour as before.
+
+ Do not automatically add a dot with generator -e option. (issue 122)
+ Fix problem with .options file and extension fields. (issue 125)
+ Don't use SIZE_MAX macro, as it is not in C89. (issue 120)
+ Generate #defines for initializing message structures. (issue 79)
+ Add skip_message option to generator. (issue 121)
+ Add PB_PACKED_STRUCT support for Keil MDK-ARM toolchain (issue 119)
+ Give better messages about the .options file path. (issue 124)
+ Improved tests
+
+nanopb-0.2.8 (2014-05-20)
+ Fix security issue with PB_ENABLE_MALLOC. (issue 117)
+ Add option to not add timestamps to .pb.h and .pb.c preambles. (issue 115)
+ Documentation updates
+ Improved tests
+
+nanopb-0.2.7 (2014-04-07)
+ Fix bug with default values for extension fields (issue 111)
+ Fix some MISRA-C warnings (issue 91)
+ Implemented optional malloc() support (issue 80)
+ Changed pointer-type bytes field datatype
+ Add a "found" field to pb_extension_t (issue 112)
+ Add convenience function pb_get_encoded_size() (issue 16)
+
+nanopb-0.2.6 (2014-02-15)
+ Fix generator error with bytes callback fields (issue 99)
+ Fix warnings about large integer constants (issue 102)
+ Add comments to where STATIC_ASSERT is used (issue 96)
+ Add warning about unknown field names on .options (issue 105)
+ Move descriptor.proto to google/protobuf subdirectory (issue 104)
+ Improved tests
+
+nanopb-0.2.5 (2014-01-01)
+ Fix a bug with encoding negative values in int32 fields (issue 97)
+ Create binary packages of the generator + dependencies (issue 47)
+ Add support for pointer-type fields to the encoder (part of issue 80)
+ Fixed path in FindNanopb.cmake (issue 94)
+ Improved tests
+
+nanopb-0.2.4 (2013-11-07)
+ Remove the deprecated NANOPB_INTERNALS functions from public API.
+ Document the security model.
+ Check array and bytes max sizes when encoding (issue 90)
+ Add #defines for maximum encoded message size (issue 89)
+ Add #define tags for extension fields (issue 93)
+ Fix MISRA C violations (issue 91)
+ Clean up pb_field_t definition with typedefs.
+
+nanopb-0.2.3 (2013-09-18)
+ Improve compatibility by removing ternary operator from initializations (issue 88)
+ Fix build error on Visual C++ (issue 84, patch by Markus Schwarzenberg)
+ Don't stop on unsupported extension fields (issue 83)
+ Add an example pb_syshdr.h file for non-C99 compilers
+ Reorganize tests and examples into subfolders (issue 63)
+ Switch from Makefiles to scons for building the tests
+ Make the tests buildable on Windows
+
+nanopb-0.2.2 (2013-08-18)
+ Add support for extension fields (issue 17)
+ Fix unknown fields in empty message (issue 78)
+ Include the field tags in the generated .pb.h file.
+ Add pb_decode_delimited and pb_encode_delimited wrapper functions (issue 74)
+ Add a section in top of pb.h for changing compilation settings (issue 76)
+ Documentation improvements (issues 12, 77 and others)
+ Improved tests
+
+nanopb-0.2.1 (2013-04-14)
+ NOTE: The default callback function signature has changed.
+       If you don't want to update your code, define PB_OLD_CALLBACK_STYLE.
+ 
+ Change the callback function to use void** (issue 69)
+ Add support for defining the nanopb options in a separate file (issue 12)
+ Add support for packed structs in IAR and MSVC (in addition to GCC) (issue 66)
+ Implement error message support for the encoder side (issue 7)
+ Handle unterminated strings when encoding (issue 68)
+ Fix bug with empty strings in repeated string callbacks (issue 73)
+ Fix regression in 0.2.0 with optional callback fields (issue 70)
+ Fix bugs with empty message types (issues 64, 65)
+ Fix some compiler warnings on clang (issue 67)
+ Some portability improvements (issues 60, 62)
+ Various new generator options
+ Improved tests
+
+nanopb-0.2.0 (2013-03-02)
+ NOTE: This release requires you to regenerate all .pb.c
+       files. Files generated by older versions will not
+       compile anymore.
+
+ Reformat generated .pb.c files using macros (issue 58)
+ Rename PB_HTYPE_ARRAY -> PB_HTYPE_REPEATED
+ Separate PB_HTYPE to PB_ATYPE and PB_HTYPE
+ Move STATIC_ASSERTs to .pb.c file
+ Added CMake file (by Pavel Ilin)
+ Add option to give file extension to generator (by Michael Haberler)
+ Documentation updates
+
+nanopb-0.1.9 (2013-02-13)
+ Fixed error message bugs (issues 52, 56)
+ Sanitize #ifndef filename (issue 50)
+ Performance improvements
+ Add compile-time option PB_BUFFER_ONLY
+ Add Java package name to nanopb.proto
+ Check for sizeof(double) == 8 (issue 54)
+ Added generator option to ignore some fields. (issue 51)
+ Added generator option to make message structs packed. (issue 49)
+ Add more test cases.
+
+nanopb-0.1.8 (2012-12-13)
+ Fix bugs in the enum short names introduced in 0.1.7 (issues 42, 43)
+ Fix STATIC_ASSERT macro when using multiple .proto files. (issue 41)
+ Fix missing initialization of istream.errmsg
+ Make tests/Makefile work for non-gcc compilers (issue 40)
+
+nanopb-0.1.7 (2012-11-11)
+ Remove "skip" mode from pb_istream_t callbacks. Example implementation had a bug. (issue 37)
+ Add option to use shorter names for enum values (issue 38)
+ Improve options support in generator (issues 12, 30)
+ Add nanopb version number to generated files (issue 36)
+ Add extern "C" to generated headers (issue 35)
+ Add names for structs to allow forward declaration (issue 39)
+ Add buffer size check in example (issue 34)
+ Fix build warnings on MS compilers (issue 33)
+
+nanopb-0.1.6 (2012-09-02)
+ Reorganize the field decoder interface (issue 2)
+ Improve performance in submessage decoding (issue 28)
+ Implement error messages in the decoder side (issue 7)
+ Extended testcases (alltypes test is now complete).
+ Fix some compiler warnings (issues 25, 26, 27, 32).
+
+nanopb-0.1.5 (2012-08-04)
+ Fix bug in decoder with packed arrays (issue 23).
+ Extended testcases.
+ Fix some compiler warnings.
+
+nanopb-0.1.4 (2012-07-05)
+ Add compile-time options for easy-to-use >255 field support.
+ Improve the detection of missing required fields.
+ Added example on how to handle union messages.
+ Fix generator error with .proto without messages.
+ Fix problems that stopped the code from compiling with some compilers.
+ Fix some compiler warnings.
+
+nanopb-0.1.3 (2012-06-12)
+ Refactor the field encoder interface.
+ Improve generator error messages (issue 5)
+ Add descriptor.proto into the #include exclusion list
+ Fix some compiler warnings.
+
+nanopb-0.1.2 (2012-02-15)
+ Make the generator to generate include for other .proto files (issue 4).
+ Fixed generator not working on Windows (issue 3)
+
+nanopb-0.1.1 (2012-01-14)
+ Fixed bug in encoder with 'bytes' fields (issue 1).
+ Fixed a bug in the generator that caused a compiler error on sfixed32 and sfixed64 fields.
+ Extended testcases.
+
+nanopb-0.1.0 (2012-01-06)
+ First stable release.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/CONTRIBUTING.md
@@ -0,0 +1,32 @@
+Contributing to Nanopb development
+==================================
+
+Reporting issues and requesting features
+----------------------------------------
+
+Feel free to report any issues you see or features you would like
+to see in the future to the Github issue tracker. Using the templates
+below is preferred:
+
+* [Report a bug](https://github.com/nanopb/nanopb/issues/new?body=**Steps%20to%20reproduce%20the%20issue**%0a%0a1.%0a2.%0a3.%0a%0a**What%20happens?**%0A%0A**What%20should%20happen?**&labels=Type-Defect)
+* [Request a feature](https://github.com/nanopb/nanopb/issues/new?body=**What%20should%20the%20feature%20do?**%0A%0A**In%20what%20situation%20would%20the%20feature%20be%20useful?**&labels=Type-Enhancement)
+
+Requesting help
+---------------
+
+If there is something strange going on, but you do not know if
+it is actually a bug in nanopb, try asking first on the
+[discussion forum](https://groups.google.com/forum/#!forum/nanopb).
+
+Pull requests
+-------------
+
+Pull requests are welcome!
+
+If it is not obvious from the commit message, please indicate the
+same information as you would for an issue report:
+
+* What functionality it fixes/adds.
+* How can the problem be reproduced / when would the feature be useful.
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/LICENSE.txt
@@ -0,0 +1,20 @@
+Copyright (c) 2011 Petteri Aimonen <jpa at nanopb.mail.kapsi.fi>
+
+This software is provided 'as-is', without any express or 
+implied warranty. In no event will the authors be held liable 
+for any damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any 
+purpose, including commercial applications, and to alter it and 
+redistribute it freely, subject to the following restrictions:
+
+1. The origin of this software must not be misrepresented; you 
+   must not claim that you wrote the original software. If you use 
+   this software in a product, an acknowledgment in the product 
+   documentation would be appreciated but is not required.
+
+2. Altered source versions must be plainly marked as such, and 
+   must not be misrepresented as being the original software.
+
+3. This notice may not be removed or altered from any source 
+   distribution.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/README.md
@@ -0,0 +1,71 @@
+Nanopb - Protocol Buffers for Embedded Systems
+==============================================
+
+[![Build Status](https://travis-ci.org/nanopb/nanopb.svg?branch=master)](https://travis-ci.org/nanopb/nanopb)
+
+Nanopb is a small code-size Protocol Buffers implementation in ansi C. It is
+especially suitable for use in microcontrollers, but fits any memory
+restricted system.
+
+* **Homepage:** http://kapsi.fi/~jpa/nanopb/
+* **Documentation:** http://kapsi.fi/~jpa/nanopb/docs/
+* **Downloads:** http://kapsi.fi/~jpa/nanopb/download/
+* **Forum:** https://groups.google.com/forum/#!forum/nanopb
+
+
+
+Using the nanopb library
+------------------------
+To use the nanopb library, you need to do two things:
+
+1. Compile your .proto files for nanopb, using protoc.
+2. Include pb_encode.c and pb_decode.c in your project.
+
+The easiest way to get started is to study the project in "examples/simple".
+It contains a Makefile, which should work directly under most Linux systems.
+However, for any other kind of build system, see the manual steps in
+README.txt in that folder.
+
+
+
+Using the Protocol Buffers compiler (protoc)
+--------------------------------------------
+The nanopb generator is implemented as a plugin for the Google's own protoc
+compiler. This has the advantage that there is no need to reimplement the
+basic parsing of .proto files. However, it does mean that you need the
+Google's protobuf library in order to run the generator.
+
+If you have downloaded a binary package for nanopb (either Windows, Linux or
+Mac OS X version), the 'protoc' binary is included in the 'generator-bin'
+folder. In this case, you are ready to go. Simply run this command:
+
+    generator-bin/protoc --nanopb_out=. myprotocol.proto
+
+However, if you are using a git checkout or a plain source distribution, you
+need to provide your own version of protoc and the Google's protobuf library.
+On Linux, the necessary packages are protobuf-compiler and python-protobuf.
+On Windows, you can either build Google's protobuf library from source or use
+one of the binary distributions of it. In either case, if you use a separate
+protoc, you need to manually give the path to nanopb generator:
+
+    protoc --plugin=protoc-gen-nanopb=nanopb/generator/protoc-gen-nanopb ...
+
+
+
+Running the tests
+-----------------
+If you want to perform further development of the nanopb core, or to verify
+its functionality using your compiler and platform, you'll want to run the
+test suite. The build rules for the test suite are implemented using Scons,
+so you need to have that installed. To run the tests:
+
+    cd tests
+    scons
+
+This will show the progress of various test cases. If the output does not
+end in an error, the test cases were successful.
+
+Note: Mac OS X by default aliases 'clang' as 'gcc', while not actually
+supporting the same command line options as gcc does. To run tests on
+Mac OS X, use: "scons CC=clang CXX=clang". Same way can be used to run
+tests with different compilers on any platform.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/Makefile
@@ -0,0 +1,9 @@
+all: index.html concepts.html reference.html security.html migration.html \
+	generator_flow.png
+
+%.png: %.svg
+	rsvg $< $@
+
+%.html: %.rst
+	rst2html --stylesheet=lsr.css --link-stylesheet $< $@
+	sed -i 's!</head>!<link href="favicon.ico" type="image/x-icon" rel="shortcut icon" />\n</head>!' $@
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/concepts.rst
@@ -0,0 +1,390 @@
+======================
+Nanopb: Basic concepts
+======================
+
+.. include :: menu.rst
+
+The things outlined here are the underlying concepts of the nanopb design.
+
+.. contents::
+
+Proto files
+===========
+All Protocol Buffers implementations use .proto files to describe the message
+format. The point of these files is to be a portable interface description
+language.
+
+Compiling .proto files for nanopb
+---------------------------------
+Nanopb uses the Google's protoc compiler to parse the .proto file, and then a
+python script to generate the C header and source code from it::
+
+    user@host:~$ protoc -omessage.pb message.proto
+    user@host:~$ python ../generator/nanopb_generator.py message.pb
+    Writing to message.h and message.c
+    user@host:~$
+
+Modifying generator behaviour
+-----------------------------
+Using generator options, you can set maximum sizes for fields in order to
+allocate them statically. The preferred way to do this is to create an .options
+file with the same name as your .proto file::
+
+   # Foo.proto
+   message Foo {
+      required string name = 1;
+   }
+
+::
+
+   # Foo.options
+   Foo.name max_size:16
+
+For more information on this, see the `Proto file options`_ section in the
+reference manual.
+
+.. _`Proto file options`: reference.html#proto-file-options
+
+Streams
+=======
+
+Nanopb uses streams for accessing the data in encoded format.
+The stream abstraction is very lightweight, and consists of a structure (*pb_ostream_t* or *pb_istream_t*) which contains a pointer to a callback function.
+
+There are a few generic rules for callback functions:
+
+#) Return false on IO errors. The encoding or decoding process will abort immediately.
+#) Use state to store your own data, such as a file descriptor.
+#) *bytes_written* and *bytes_left* are updated by pb_write and pb_read.
+#) Your callback may be used with substreams. In this case *bytes_left*, *bytes_written* and *max_size* have smaller values than the original stream. Don't use these values to calculate pointers.
+#) Always read or write the full requested length of data. For example, POSIX *recv()* needs the *MSG_WAITALL* parameter to accomplish this.
+
+Output streams
+--------------
+
+::
+
+ struct _pb_ostream_t
+ {
+    bool (*callback)(pb_ostream_t *stream, const uint8_t *buf, size_t count);
+    void *state;
+    size_t max_size;
+    size_t bytes_written;
+ };
+
+The *callback* for output stream may be NULL, in which case the stream simply counts the number of bytes written. In this case, *max_size* is ignored.
+
+Otherwise, if *bytes_written* + bytes_to_be_written is larger than *max_size*, pb_write returns false before doing anything else. If you don't want to limit the size of the stream, pass SIZE_MAX.
+ 
+**Example 1:**
+
+This is the way to get the size of the message without storing it anywhere::
+
+ Person myperson = ...;
+ pb_ostream_t sizestream = {0};
+ pb_encode(&sizestream, Person_fields, &myperson);
+ printf("Encoded size is %d\n", sizestream.bytes_written);
+
+**Example 2:**
+
+Writing to stdout::
+
+ bool callback(pb_ostream_t *stream, const uint8_t *buf, size_t count)
+ {
+    FILE *file = (FILE*) stream->state;
+    return fwrite(buf, 1, count, file) == count;
+ }
+ 
+ pb_ostream_t stdoutstream = {&callback, stdout, SIZE_MAX, 0};
+
+Input streams
+-------------
+For input streams, there is one extra rule:
+
+#) You don't need to know the length of the message in advance. After getting EOF error when reading, set bytes_left to 0 and return false. Pb_decode will detect this and if the EOF was in a proper position, it will return true.
+
+Here is the structure::
+
+ struct _pb_istream_t
+ {
+    bool (*callback)(pb_istream_t *stream, uint8_t *buf, size_t count);
+    void *state;
+    size_t bytes_left;
+ };
+
+The *callback* must always be a function pointer. *Bytes_left* is an upper limit on the number of bytes that will be read. You can use SIZE_MAX if your callback handles EOF as described above.
+
+**Example:**
+
+This function binds an input stream to stdin:
+
+:: 
+
+ bool callback(pb_istream_t *stream, uint8_t *buf, size_t count)
+ {
+    FILE *file = (FILE*)stream->state;
+    bool status;
+    
+    if (buf == NULL)
+    {
+        while (count-- && fgetc(file) != EOF);
+        return count == 0;
+    }
+    
+    status = (fread(buf, 1, count, file) == count);
+    
+    if (feof(file))
+        stream->bytes_left = 0;
+    
+    return status;
+ }
+ 
+ pb_istream_t stdinstream = {&callback, stdin, SIZE_MAX};
+
+Data types
+==========
+
+Most Protocol Buffers datatypes have directly corresponding C datatypes, such as int32 is int32_t, float is float and bool is bool. However, the variable-length datatypes are more complex:
+
+1) Strings, bytes and repeated fields of any type map to callback functions by default.
+2) If there is a special option *(nanopb).max_size* specified in the .proto file, string maps to null-terminated char array and bytes map to a structure containing a char array and a size field.
+3) If there is a special option *(nanopb).max_count* specified on a repeated field, it maps to an array of whatever type is being repeated. Another field will be created for the actual number of entries stored.
+
+=============================================================================== =======================
+      field in .proto                                                           autogenerated in .h
+=============================================================================== =======================
+required string name = 1;                                                       pb_callback_t name;
+required string name = 1 [(nanopb).max_size = 40];                              char name[40];
+repeated string name = 1 [(nanopb).max_size = 40];                              pb_callback_t name;
+repeated string name = 1 [(nanopb).max_size = 40, (nanopb).max_count = 5];      | size_t name_count;
+                                                                                | char name[5][40];
+required bytes data = 1 [(nanopb).max_size = 40];                               | typedef struct {
+                                                                                |    size_t size;
+                                                                                |    uint8_t bytes[40];
+                                                                                | } Person_data_t;
+                                                                                | Person_data_t data;
+=============================================================================== =======================
+
+The maximum lengths are checked in runtime. If string/bytes/array exceeds the allocated length, *pb_decode* will return false.
+
+Note: for the *bytes* datatype, the field length checking may not be exact.
+The compiler may add some padding to the *pb_bytes_t* structure, and the nanopb runtime doesn't know how much of the structure size is padding. Therefore it uses the whole length of the structure for storing data, which is not very smart but shouldn't cause problems. In practise, this means that if you specify *(nanopb).max_size=5* on a *bytes* field, you may be able to store 6 bytes there. For the *string* field type, the length limit is exact.
+
+Field callbacks
+===============
+When a field has dynamic length, nanopb cannot statically allocate storage for it. Instead, it allows you to handle the field in whatever way you want, using a callback function.
+
+The `pb_callback_t`_ structure contains a function pointer and a *void* pointer called *arg* you can use for passing data to the callback. If the function pointer is NULL, the field will be skipped. A pointer to the *arg* is passed to the function, so that it can modify it and retrieve the value.
+
+The actual behavior of the callback function is different in encoding and decoding modes. In encoding mode, the callback is called once and should write out everything, including field tags. In decoding mode, the callback is called repeatedly for every data item.
+
+.. _`pb_callback_t`: reference.html#pb-callback-t
+
+Encoding callbacks
+------------------
+::
+
+    bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
+
+When encoding, the callback should write out complete fields, including the wire type and field number tag. It can write as many or as few fields as it likes. For example, if you want to write out an array as *repeated* field, you should do it all in a single call.
+
+Usually you can use `pb_encode_tag_for_field`_ to encode the wire type and tag number of the field. However, if you want to encode a repeated field as a packed array, you must call `pb_encode_tag`_ instead to specify a wire type of *PB_WT_STRING*.
+
+If the callback is used in a submessage, it will be called multiple times during a single call to `pb_encode`_. In this case, it must produce the same amount of data every time. If the callback is directly in the main message, it is called only once.
+
+.. _`pb_encode`: reference.html#pb-encode
+.. _`pb_encode_tag_for_field`: reference.html#pb-encode-tag-for-field
+.. _`pb_encode_tag`: reference.html#pb-encode-tag
+
+This callback writes out a dynamically sized string::
+
+    bool write_string(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+    {
+        char *str = get_string_from_somewhere();
+        if (!pb_encode_tag_for_field(stream, field))
+            return false;
+        
+        return pb_encode_string(stream, (uint8_t*)str, strlen(str));
+    }
+
+Decoding callbacks
+------------------
+::
+
+    bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
+
+When decoding, the callback receives a length-limited substring that reads the contents of a single field. The field tag has already been read. For *string* and *bytes*, the length value has already been parsed, and is available at *stream->bytes_left*.
+
+The callback will be called multiple times for repeated fields. For packed fields, you can either read multiple values until the stream ends, or leave it to `pb_decode`_ to call your function over and over until all values have been read.
+
+.. _`pb_decode`: reference.html#pb-decode
+
+This callback reads multiple integers and prints them::
+
+    bool read_ints(pb_istream_t *stream, const pb_field_t *field, void **arg)
+    {
+        while (stream->bytes_left)
+        {
+            uint64_t value;
+            if (!pb_decode_varint(stream, &value))
+                return false;
+            printf("%lld\n", value);
+        }
+        return true;
+    }
+
+Field description array
+=======================
+
+For using the *pb_encode* and *pb_decode* functions, you need an array of pb_field_t constants describing the structure you wish to encode. This description is usually autogenerated from .proto file.
+
+For example this submessage in the Person.proto file::
+
+ message Person {
+    message PhoneNumber {
+        required string number = 1 [(nanopb).max_size = 40];
+        optional PhoneType type = 2 [default = HOME];
+    }
+ }
+
+generates this field description array for the structure *Person_PhoneNumber*::
+
+ const pb_field_t Person_PhoneNumber_fields[3] = {
+    PB_FIELD(  1, STRING  , REQUIRED, STATIC, Person_PhoneNumber, number, number, 0),
+    PB_FIELD(  2, ENUM    , OPTIONAL, STATIC, Person_PhoneNumber, type, number, &Person_PhoneNumber_type_default),
+    PB_LAST_FIELD
+ };
+
+Oneof
+=====
+Protocol Buffers supports `oneof`_ sections. Here is an example of ``oneof`` usage::
+
+ message MsgType1 {
+     required int32 value = 1;
+ }
+
+ message MsgType2 {
+     required bool value = 1;
+ }
+ 
+ message MsgType3 {
+     required int32 value1 = 1;
+     required int32 value2 = 2;
+ } 
+ 
+ message MyMessage {
+     required uint32 uid = 1;
+     required uint32 pid = 2;
+     required uint32 utime = 3;
+ 
+     oneof payload {
+         MsgType1 msg1 = 4;
+         MsgType2 msg2 = 5;
+         MsgType3 msg3 = 6;
+     }
+ }
+
+Nanopb will generate ``payload`` as a C union and add an additional field ``which_payload``::
+
+  typedef struct _MyMessage {
+    uint32_t uid;
+    uint32_t pid;
+    uint32_t utime;
+    pb_size_t which_payload;
+    union {
+        MsgType1 msg1;
+        MsgType2 msg2;
+        MsgType3 msg3;
+    } payload;
+  /* @@protoc_insertion_point(struct:MyMessage) */
+  } MyMessage;
+
+``which_payload`` indicates which of the ``oneof`` fields is actually set. 
+The user is expected to set the filed manually using the correct field tag::
+
+  MyMessage msg = MyMessage_init_zero;
+  msg.payload.msg2.value = true;
+  msg.which_payload = MyMessage_msg2_tag;
+
+Notice that neither ``which_payload`` field nor the unused fileds in ``payload``
+will consume any space in the resulting encoded message.
+
+.. _`oneof`: https://developers.google.com/protocol-buffers/docs/reference/proto2-spec#oneof_and_oneof_field
+
+Extension fields
+================
+Protocol Buffers supports a concept of `extension fields`_, which are
+additional fields to a message, but defined outside the actual message.
+The definition can even be in a completely separate .proto file.
+
+The base message is declared as extensible by keyword *extensions* in
+the .proto file::
+
+ message MyMessage {
+     .. fields ..
+     extensions 100 to 199;
+ }
+
+For each extensible message, *nanopb_generator.py* declares an additional
+callback field called *extensions*. The field and associated datatype
+*pb_extension_t* forms a linked list of handlers. When an unknown field is
+encountered, the decoder calls each handler in turn until either one of them
+handles the field, or the list is exhausted.
+
+The actual extensions are declared using the *extend* keyword in the .proto,
+and are in the global namespace::
+
+ extend MyMessage {
+     optional int32 myextension = 100;
+ }
+
+For each extension, *nanopb_generator.py* creates a constant of type
+*pb_extension_type_t*. To link together the base message and the extension,
+you have to:
+
+1. Allocate storage for your field, matching the datatype in the .proto.
+   For example, for a *int32* field, you need a *int32_t* variable to store
+   the value.
+2. Create a *pb_extension_t* constant, with pointers to your variable and
+   to the generated *pb_extension_type_t*.
+3. Set the *message.extensions* pointer to point to the *pb_extension_t*.
+
+An example of this is available in *tests/test_encode_extensions.c* and
+*tests/test_decode_extensions.c*.
+
+.. _`extension fields`: https://developers.google.com/protocol-buffers/docs/proto#extensions
+
+Message framing
+===============
+Protocol Buffers does not specify a method of framing the messages for transmission.
+This is something that must be provided by the library user, as there is no one-size-fits-all
+solution. Typical needs for a framing format are to:
+
+1. Encode the message length.
+2. Encode the message type.
+3. Perform any synchronization and error checking that may be needed depending on application.
+
+For example UDP packets already fullfill all the requirements, and TCP streams typically only
+need a way to identify the message length and type. Lower level interfaces such as serial ports
+may need a more robust frame format, such as HDLC (high-level data link control).
+
+Nanopb provides a few helpers to facilitate implementing framing formats:
+
+1. Functions *pb_encode_delimited* and *pb_decode_delimited* prefix the message data with a varint-encoded length.
+2. Union messages and oneofs are supported in order to implement top-level container messages.
+3. Message IDs can be specified using the *(nanopb_msgopt).msgid* option and can then be accessed from the header.
+
+Return values and error handling
+================================
+
+Most functions in nanopb return bool: *true* means success, *false* means failure. There is also some support for error messages for debugging purposes: the error messages go in *stream->errmsg*.
+
+The error messages help in guessing what is the underlying cause of the error. The most common error conditions are:
+
+1) Running out of memory, i.e. stack overflow.
+2) Invalid field descriptors (would usually mean a bug in the generator).
+3) IO errors in your own stream callbacks.
+4) Errors that happen in your callback functions.
+5) Exceeding the max_size or bytes_left of a stream.
+6) Exceeding the max_size of a string or array field
+7) Invalid protocol buffers binary message.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/generator_flow.svg
@@ -0,0 +1,2869 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="490"
+   height="220"
+   id="svg1901"
+   sodipodi:version="0.32"
+   inkscape:version="0.48.2 r9819"
+   sodipodi:docname="generator_flow.svg"
+   version="1.1">
+  <defs
+     id="defs1903">
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient15568">
+      <stop
+         style="stop-color:#729fcf;stop-opacity:1;"
+         offset="0"
+         id="stop15570" />
+      <stop
+         style="stop-color:#729fcf;stop-opacity:0;"
+         offset="1"
+         id="stop15572" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient15558">
+      <stop
+         style="stop-color:#fcaf3e;stop-opacity:1;"
+         offset="0"
+         id="stop15560" />
+      <stop
+         style="stop-color:#fcaf3e;stop-opacity:0;"
+         offset="1"
+         id="stop15562" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient13629">
+      <stop
+         style="stop-color:#fce94f;stop-opacity:1;"
+         offset="0"
+         id="stop13631" />
+      <stop
+         style="stop-color:#fce94f;stop-opacity:0;"
+         offset="1"
+         id="stop13633" />
+    </linearGradient>
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1,0,0,0.284916,0,30.08928)"
+       r="15.821514"
+       fy="42.07798"
+       fx="24.306795"
+       cy="42.07798"
+       cx="24.306795"
+       id="radialGradient4548"
+       xlink:href="#linearGradient4542"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient259">
+      <stop
+         style="stop-color:#fafafa;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop260" />
+      <stop
+         style="stop-color:#bbbbbb;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop261" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient269">
+      <stop
+         style="stop-color:#a3a3a3;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop270" />
+      <stop
+         style="stop-color:#4c4c4c;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop271" />
+    </linearGradient>
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       fy="114.5684"
+       fx="20.892099"
+       r="5.256"
+       cy="114.5684"
+       cx="20.892099"
+       id="aigrd2">
+      <stop
+         id="stop15566"
+         style="stop-color:#F0F0F0"
+         offset="0" />
+      <stop
+         id="stop15568"
+         style="stop-color:#9a9a9a;stop-opacity:1.0000000;"
+         offset="1.0000000" />
+    </radialGradient>
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       fy="64.567902"
+       fx="20.892099"
+       r="5.257"
+       cy="64.567902"
+       cx="20.892099"
+       id="aigrd3">
+      <stop
+         id="stop15573"
+         style="stop-color:#F0F0F0"
+         offset="0" />
+      <stop
+         id="stop15575"
+         style="stop-color:#9a9a9a;stop-opacity:1.0000000;"
+         offset="1.0000000" />
+    </radialGradient>
+    <linearGradient
+       id="linearGradient15662">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop15664" />
+      <stop
+         style="stop-color:#f8f8f8;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop15666" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4542"
+       inkscape:collect="always">
+      <stop
+         id="stop4544"
+         offset="0"
+         style="stop-color:#000000;stop-opacity:1;" />
+      <stop
+         id="stop4546"
+         offset="1"
+         style="stop-color:#000000;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5048">
+      <stop
+         id="stop5050"
+         offset="0"
+         style="stop-color:black;stop-opacity:0;" />
+      <stop
+         style="stop-color:black;stop-opacity:1;"
+         offset="0.5"
+         id="stop5056" />
+      <stop
+         id="stop5052"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5060"
+       inkscape:collect="always">
+      <stop
+         id="stop5062"
+         offset="0"
+         style="stop-color:black;stop-opacity:1;" />
+      <stop
+         id="stop5064"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <radialGradient
+       r="9.586297"
+       fy="9.8105707"
+       fx="21.578989"
+       cy="9.8105707"
+       cx="21.578989"
+       gradientTransform="matrix(0.74942,0,0,0.394055,6.226925,10.09253)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient2908"
+       xlink:href="#linearGradient2869"
+       inkscape:collect="always" />
+    <radialGradient
+       r="6.4286141"
+       fy="20.800287"
+       fx="23.94367"
+       cy="20.800287"
+       cx="23.94367"
+       gradientTransform="matrix(1.353283,0,0,0.635968,-8.45889,3.41347)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient2906"
+       xlink:href="#linearGradient2884"
+       inkscape:collect="always" />
+    <radialGradient
+       r="9.586297"
+       fy="9.0255041"
+       fx="21.578989"
+       cy="9.0255041"
+       cx="21.578989"
+       gradientTransform="matrix(0.74942,0,0,0.394055,6.226925,10.09253)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient2898"
+       xlink:href="#linearGradient2869"
+       inkscape:collect="always" />
+    <radialGradient
+       r="6.4286141"
+       fy="20.800287"
+       fx="23.94367"
+       cy="20.800287"
+       cx="23.94367"
+       gradientTransform="matrix(1.353283,0,0,0.635968,-8.45889,3.41347)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient2896"
+       xlink:href="#linearGradient2884"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="22.585211"
+       x2="24.990499"
+       y1="34.004856"
+       x1="24.990499"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2288"
+       xlink:href="#linearGradient4210"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="47.388485"
+       x2="30.014812"
+       y1="19.912336"
+       x1="18.706615"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2285"
+       xlink:href="#linearGradient4222"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="16.020695"
+       x2="22.071806"
+       y1="9.7577486"
+       x1="21.906841"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2282"
+       xlink:href="#linearGradient4987"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="12.636667"
+       x2="34.193642"
+       y1="12.636667"
+       x1="16.148972"
+       gradientTransform="matrix(1,0,0,1.039184,0,-0.04057054)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2280"
+       xlink:href="#linearGradient4182"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="16.17037"
+       x2="24.119167"
+       y1="24.720648"
+       x1="25.381256"
+       gradientTransform="matrix(1,0,0,0.986355,0,0.316638)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2277"
+       xlink:href="#linearGradient4192"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="15.267649"
+       x2="47.065834"
+       y1="14.661557"
+       x1="36.288929"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2274"
+       xlink:href="#linearGradient4995"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="12.333632"
+       x2="17.696169"
+       y1="13.444801"
+       x1="30.062469"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2269"
+       xlink:href="#linearGradient4979"
+       inkscape:collect="always" />
+    <radialGradient
+       r="17.576654"
+       fy="35.373093"
+       fx="22.930462"
+       cy="35.373093"
+       cx="22.930462"
+       gradientTransform="matrix(1,0,0,0.333333,0,23.58206)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient2252"
+       xlink:href="#linearGradient4946"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient4182">
+      <stop
+         style="stop-color:#a36d18;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop4184" />
+      <stop
+         style="stop-color:#d79020;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4186" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4192">
+      <stop
+         style="stop-color:#e9b96e;stop-opacity:1;"
+         offset="0"
+         id="stop4194" />
+      <stop
+         style="stop-color:#f1d19e;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4196" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4210">
+      <stop
+         style="stop-color:#eaba6f;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop4212" />
+      <stop
+         style="stop-color:#b97a1b;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4214" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4222">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4224" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.68639052;"
+         offset="1.0000000"
+         id="stop4226" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4946">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4948" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4950" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4979">
+      <stop
+         style="stop-color:#fbf0e0;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop4981" />
+      <stop
+         style="stop-color:#f0ce99;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4983" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4987">
+      <stop
+         style="stop-color:#a0670c;stop-opacity:1;"
+         offset="0"
+         id="stop4989" />
+      <stop
+         style="stop-color:#a0670c;stop-opacity:0;"
+         offset="1"
+         id="stop4991" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4995">
+      <stop
+         style="stop-color:#de9523;stop-opacity:1;"
+         offset="0"
+         id="stop4997" />
+      <stop
+         style="stop-color:#a36d18;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4999" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2869">
+      <stop
+         id="stop2871"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop2873"
+         offset="1.0000000"
+         style="stop-color:#cccccc;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2884"
+       inkscape:collect="always">
+      <stop
+         id="stop2886"
+         offset="0"
+         style="stop-color:#000000;stop-opacity:1;" />
+      <stop
+         id="stop2888"
+         offset="1"
+         style="stop-color:#000000;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       y2="609.50507"
+       x2="302.85715"
+       y1="366.64789"
+       x1="302.85715"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1892.179,-872.8854)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient6715-6"
+       xlink:href="#linearGradient5048-7"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient5048-7">
+      <stop
+         id="stop5050-2"
+         offset="0"
+         style="stop-color:black;stop-opacity:0;" />
+      <stop
+         style="stop-color:black;stop-opacity:1;"
+         offset="0.5"
+         id="stop5056-4" />
+      <stop
+         id="stop5052-0"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <radialGradient
+       r="117.14286"
+       fy="486.64789"
+       fx="605.71429"
+       cy="486.64789"
+       cx="605.71429"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1891.633,-872.8854)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient6717-4"
+       xlink:href="#linearGradient5060-6"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient5060-6"
+       inkscape:collect="always">
+      <stop
+         id="stop5062-2"
+         offset="0"
+         style="stop-color:black;stop-opacity:1;" />
+      <stop
+         id="stop5064-8"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <radialGradient
+       r="117.14286"
+       fy="486.64789"
+       fx="605.71429"
+       cy="486.64789"
+       cx="605.71429"
+       gradientTransform="matrix(-2.774389,0,0,1.969706,112.7623,-872.8854)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient6719-8"
+       xlink:href="#linearGradient5060-6"
+       inkscape:collect="always" />
+    <linearGradient
+       gradientTransform="matrix(-0.901805,0.210818,-0.211618,-0.898788,63.54132,37.87423)"
+       y2="46.06208"
+       x2="29.477814"
+       y1="2.8703361"
+       x1="25.950134"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient5486"
+       xlink:href="#linearGradient5476"
+       inkscape:collect="always" />
+    <linearGradient
+       gradientTransform="matrix(1.106909,-0.258404,0.259748,1.101665,-19.66697,12.19788)"
+       gradientUnits="userSpaceOnUse"
+       y2="46.06208"
+       x2="29.477814"
+       y1="2.8703361"
+       x1="25.950134"
+       id="linearGradient5482"
+       xlink:href="#linearGradient5476"
+       inkscape:collect="always" />
+    <linearGradient
+       gradientTransform="matrix(1.106909,-0.258404,0.259748,1.101665,-19.66697,12.19788)"
+       y2="2.8163671"
+       x2="21.587093"
+       y1="23.499001"
+       x1="21.587093"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient5472"
+       xlink:href="#linearGradient5464"
+       inkscape:collect="always" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4356">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4358" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4360" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4344">
+      <stop
+         style="stop-color:#727e0a;stop-opacity:1;"
+         offset="0"
+         id="stop4346" />
+      <stop
+         style="stop-color:#5b6508;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4348" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4338">
+      <stop
+         id="stop4340"
+         offset="0.0000000"
+         style="stop-color:#e9b15e;stop-opacity:1.0000000;" />
+      <stop
+         id="stop4342"
+         offset="1.0000000"
+         style="stop-color:#966416;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4163">
+      <stop
+         style="stop-color:#3b74bc;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop4165" />
+      <stop
+         style="stop-color:#2d5990;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4167" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3824">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop3826" />
+      <stop
+         style="stop-color:#c9c9c9;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop3828" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient3816">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop3818" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop3820" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3800">
+      <stop
+         style="stop-color:#f4d9b1;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop3802" />
+      <stop
+         style="stop-color:#df9725;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop3804" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3800"
+       id="radialGradient3806"
+       cx="29.344931"
+       cy="17.064077"
+       fx="29.344931"
+       fy="17.064077"
+       r="9.1620579"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3816"
+       id="radialGradient3822"
+       cx="31.112698"
+       cy="19.008621"
+       fx="31.112698"
+       fy="19.008621"
+       r="8.6620579"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3824"
+       id="linearGradient3830"
+       x1="30.935921"
+       y1="29.553486"
+       x2="30.935921"
+       y2="35.803486"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4163"
+       id="radialGradient4169"
+       cx="28.089741"
+       cy="27.203083"
+       fx="28.089741"
+       fy="27.203083"
+       r="13.56536"
+       gradientTransform="matrix(1.297564,0,0,0.884831,-8.358505,4.940469)"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3800"
+       id="radialGradient4171"
+       gradientUnits="userSpaceOnUse"
+       cx="29.344931"
+       cy="17.064077"
+       fx="29.344931"
+       fy="17.064077"
+       r="9.1620579"
+       gradientTransform="matrix(0.787998,0,0,0.787998,6.221198,3.617627)" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3824"
+       id="linearGradient4175"
+       gradientUnits="userSpaceOnUse"
+       x1="30.935921"
+       y1="29.553486"
+       x2="30.935921"
+       y2="35.803486"
+       gradientTransform="translate(0.707108,0)" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3816"
+       id="radialGradient4179"
+       gradientUnits="userSpaceOnUse"
+       cx="31.112698"
+       cy="19.008621"
+       fx="31.112698"
+       fy="19.008621"
+       r="8.6620579" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3824"
+       id="linearGradient4326"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(-12.41789,-7)"
+       x1="30.935921"
+       y1="29.553486"
+       x2="30.935921"
+       y2="35.803486" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4338"
+       id="radialGradient4328"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.787998,0,0,0.787998,6.221198,3.617627)"
+       cx="29.344931"
+       cy="17.064077"
+       fx="29.344931"
+       fy="17.064077"
+       r="9.1620579" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3816"
+       id="radialGradient4330"
+       gradientUnits="userSpaceOnUse"
+       cx="31.112698"
+       cy="19.008621"
+       fx="31.112698"
+       fy="19.008621"
+       r="8.6620579" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3824"
+       id="linearGradient4332"
+       gradientUnits="userSpaceOnUse"
+       x1="30.935921"
+       y1="29.553486"
+       x2="30.935921"
+       y2="35.803486"
+       gradientTransform="translate(-13.125,-7)" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3816"
+       id="radialGradient4336"
+       gradientUnits="userSpaceOnUse"
+       cx="31.112698"
+       cy="19.008621"
+       fx="31.112698"
+       fy="19.008621"
+       r="8.6620579" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4344"
+       id="radialGradient4350"
+       cx="16.214741"
+       cy="19.836468"
+       fx="16.214741"
+       fy="19.836468"
+       r="13.56536"
+       gradientTransform="matrix(1,0,0,0.681917,0,8.233773)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4356"
+       id="linearGradient4362"
+       x1="20.661695"
+       y1="35.817974"
+       x2="22.626925"
+       y2="36.217758"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.983375,0.181588,-0.181588,0.983375,6.231716,-2.651466)" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4356"
+       id="linearGradient4366"
+       gradientUnits="userSpaceOnUse"
+       x1="22.686766"
+       y1="36.3904"
+       x2="21.408455"
+       y2="35.739632"
+       gradientTransform="matrix(-0.977685,0.210075,0.210075,0.977685,55.1096,-3.945209)" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4356"
+       id="linearGradient4372"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.983375,0.181588,-0.181588,0.983375,-7.07212,-9.82492)"
+       x1="20.661695"
+       y1="35.817974"
+       x2="22.626925"
+       y2="36.217758" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4356"
+       id="linearGradient4374"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(-0.977685,0.210075,0.210075,0.977685,41.80576,-11.11866)"
+       x1="22.686766"
+       y1="36.3904"
+       x2="21.408455"
+       y2="35.739632" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4356"
+       id="linearGradient1366"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(-0.977685,0.210075,0.210075,0.977685,41.80576,-11.11866)"
+       x1="22.686766"
+       y1="36.3904"
+       x2="21.408455"
+       y2="35.739632" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4356"
+       id="linearGradient1369"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.983375,0.181588,-0.181588,0.983375,-7.07212,-9.82492)"
+       x1="20.661695"
+       y1="35.817974"
+       x2="22.626925"
+       y2="36.217758" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient3824"
+       id="linearGradient1372"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(-12.41789,-7)"
+       x1="30.935921"
+       y1="29.553486"
+       x2="30.935921"
+       y2="35.803486" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4344"
+       id="radialGradient1381"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1,0,0,0.681917,0,8.233773)"
+       cx="16.214741"
+       cy="19.836468"
+       fx="16.214741"
+       fy="19.836468"
+       r="13.56536" />
+    <linearGradient
+       y2="11.981981"
+       x2="13.846983"
+       y1="11.48487"
+       x1="11.74217"
+       gradientTransform="matrix(1.276531,0,0,-1.406115,24.24763,33.3374)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1493"
+       xlink:href="#linearGradient15107"
+       inkscape:collect="always" />
+    <radialGradient
+       r="7.228416"
+       fy="73.615715"
+       fx="6.702713"
+       cy="73.615715"
+       cx="6.702713"
+       gradientTransform="scale(1.902215,0.525703)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient1481"
+       xlink:href="#linearGradient10691"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="12.765438"
+       x2="38.129341"
+       y1="7.7850504"
+       x1="26.577936"
+       gradientTransform="matrix(0,1,-1,0,37.07553,-5.879343)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2365"
+       xlink:href="#linearGradient4274"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="29.698416"
+       x2="16.588747"
+       y1="16.612858"
+       x1="41.093174"
+       gradientTransform="matrix(0,0.914114,-0.914114,0,39.78243,-9.748047)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2566"
+       xlink:href="#linearGradient2187"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="27.145725"
+       x2="10.112462"
+       y1="23.332331"
+       x1="10.791593"
+       gradientTransform="matrix(0,1,-1,0,37.07553,-5.879343)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2564"
+       xlink:href="#linearGradient6925"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="30.55784"
+       x2="12.252101"
+       y1="15.028743"
+       x1="15.193591"
+       gradientTransform="matrix(0,1,-1,0,37.07553,-5.879343)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2562"
+       xlink:href="#linearGradient6901"
+       inkscape:collect="always" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient6925">
+      <stop
+         style="stop-color:#204a87;stop-opacity:1;"
+         offset="0"
+         id="stop6927" />
+      <stop
+         style="stop-color:#204a87;stop-opacity:0;"
+         offset="1"
+         id="stop6929" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient6901">
+      <stop
+         style="stop-color:#3465a4;stop-opacity:1;"
+         offset="0"
+         id="stop6903" />
+      <stop
+         style="stop-color:#3465a4;stop-opacity:0;"
+         offset="1"
+         id="stop6905" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2187"
+       inkscape:collect="always">
+      <stop
+         id="stop2189"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop2191"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4274">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.25490198;"
+         offset="0.0000000"
+         id="stop4276" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4278" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient10691">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop10693" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop10695" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient15107">
+      <stop
+         id="stop15109"
+         offset="0.0000000"
+         style="stop-color:#ffffff;stop-opacity:1.0000000;" />
+      <stop
+         id="stop15111"
+         offset="1.0000000"
+         style="stop-color:#e2e2e2;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient9749">
+      <stop
+         id="stop9751"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop9753"
+         offset="1.0000000"
+         style="stop-color:#ededed;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2274-5">
+      <stop
+         id="stop2276"
+         offset="0.0000000"
+         style="stop-color:#000000;stop-opacity:0.12871288;" />
+      <stop
+         id="stop2278"
+         offset="1.0000000"
+         style="stop-color:#000000;stop-opacity:0.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2624">
+      <stop
+         style="stop-color:#dfe0df;stop-opacity:1;"
+         offset="0"
+         id="stop2626" />
+      <stop
+         id="stop2630"
+         offset="0.23809524"
+         style="stop-color:#a6b0a6;stop-opacity:1;" />
+      <stop
+         style="stop-color:#b5beb5;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop2628" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5464">
+      <stop
+         id="stop5466"
+         offset="0"
+         style="stop-color:#729fcf;stop-opacity:1;" />
+      <stop
+         id="stop5468"
+         offset="1"
+         style="stop-color:#afc9e4;stop-opacity:1;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5476"
+       inkscape:collect="always">
+      <stop
+         id="stop5478"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop5480"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5048-5">
+      <stop
+         id="stop5050-4"
+         offset="0"
+         style="stop-color:black;stop-opacity:0;" />
+      <stop
+         style="stop-color:black;stop-opacity:1;"
+         offset="0.5"
+         id="stop5056-9" />
+      <stop
+         id="stop5052-2"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1,0,0,0.177966,0,108.7434)"
+       r="29.036913"
+       fy="132.28575"
+       fx="61.518883"
+       cy="132.28575"
+       cx="61.518883"
+       id="radialGradient2801"
+       xlink:href="#linearGradient2795"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="76.313133"
+       x2="26.670298"
+       y1="76.176224"
+       x1="172.94208"
+       gradientTransform="matrix(0.562541,0,0,0.567972,-11.5974,-7.60954)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2258"
+       xlink:href="#linearGradient4689"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="144.75717"
+       x2="-65.308502"
+       y1="144.75717"
+       x1="224.23996"
+       gradientTransform="matrix(0.562541,0,0,0.567972,-11.5974,-7.60954)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2255"
+       xlink:href="#linearGradient4671"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="144.75717"
+       x2="-65.308502"
+       y1="144.75717"
+       x1="224.23996"
+       gradientTransform="translate(100.2702,99.61116)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2250"
+       xlink:href="#linearGradient4671"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="76.313133"
+       x2="26.670298"
+       y1="77.475983"
+       x1="172.94208"
+       gradientTransform="translate(100.2702,99.61116)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2248"
+       xlink:href="#linearGradient4689"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="144.75717"
+       x2="-65.308502"
+       y1="144.75717"
+       x1="224.23996"
+       gradientTransform="translate(100.2702,99.61116)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2589"
+       xlink:href="#linearGradient4671"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="76.313133"
+       x2="26.670298"
+       y1="77.475983"
+       x1="172.94208"
+       gradientTransform="translate(100.2702,99.61116)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient2587"
+       xlink:href="#linearGradient4689"
+       inkscape:collect="always" />
+    <linearGradient
+       gradientTransform="translate(100.2702,99.61116)"
+       gradientUnits="userSpaceOnUse"
+       xlink:href="#linearGradient4689"
+       id="linearGradient2990"
+       y2="76.313133"
+       x2="26.670298"
+       y1="77.475983"
+       x1="172.94208" />
+    <linearGradient
+       gradientTransform="translate(100.2702,99.61116)"
+       gradientUnits="userSpaceOnUse"
+       xlink:href="#linearGradient4671"
+       id="linearGradient2987"
+       y2="144.75717"
+       x2="-65.308502"
+       y1="144.75717"
+       x1="224.23996" />
+    <linearGradient
+       id="linearGradient4689">
+      <stop
+         id="stop4691"
+         offset="0"
+         style="stop-color:#5a9fd4;stop-opacity:1;" />
+      <stop
+         id="stop4693"
+         offset="1"
+         style="stop-color:#306998;stop-opacity:1;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4671">
+      <stop
+         id="stop4673"
+         offset="0"
+         style="stop-color:#ffd43b;stop-opacity:1;" />
+      <stop
+         id="stop4675"
+         offset="1"
+         style="stop-color:#ffe873;stop-opacity:1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3236">
+      <stop
+         id="stop3244"
+         offset="0"
+         style="stop-color:#f4f4f4;stop-opacity:1" />
+      <stop
+         id="stop3240"
+         offset="1"
+         style="stop-color:white;stop-opacity:1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3676">
+      <stop
+         id="stop3678"
+         offset="0"
+         style="stop-color:#b2b2b2;stop-opacity:0.5;" />
+      <stop
+         id="stop3680"
+         offset="1"
+         style="stop-color:#b3b3b3;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2787">
+      <stop
+         id="stop2789"
+         offset="0"
+         style="stop-color:#7f7f7f;stop-opacity:0.5;" />
+      <stop
+         id="stop2791"
+         offset="1"
+         style="stop-color:#7f7f7f;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2795">
+      <stop
+         id="stop2797"
+         offset="0"
+         style="stop-color:#b8b8b8;stop-opacity:0.49803922;" />
+      <stop
+         id="stop2799"
+         offset="1"
+         style="stop-color:#7f7f7f;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4689"
+       id="linearGradient11109"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.562541,0,0,0.567972,-9.399749,-5.305317)"
+       x1="26.648937"
+       y1="20.603781"
+       x2="135.66525"
+       y2="114.39767" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4671"
+       id="linearGradient11111"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.562541,0,0,0.567972,-9.399749,-5.305317)"
+       x1="150.96111"
+       y1="192.35176"
+       x2="112.03144"
+       y2="137.27299" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2795"
+       id="radialGradient11113"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.382716e-8,-0.296405,1.43676,4.683673e-7,-128.544,150.5202)"
+       cx="61.518883"
+       cy="132.28575"
+       fx="61.518883"
+       fy="132.28575"
+       r="29.036913" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5048"
+       id="linearGradient11177"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1892.179,-872.8854)"
+       x1="302.85715"
+       y1="366.64789"
+       x2="302.85715"
+       y2="609.50507" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5060"
+       id="radialGradient11179"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1891.633,-872.8854)"
+       cx="605.71429"
+       cy="486.64789"
+       fx="605.71429"
+       fy="486.64789"
+       r="117.14286" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5060"
+       id="radialGradient11181"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(-2.774389,0,0,1.969706,112.7623,-872.8854)"
+       cx="605.71429"
+       cy="486.64789"
+       fx="605.71429"
+       fy="486.64789"
+       r="117.14286" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient259"
+       id="radialGradient11183"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="scale(0.960493,1.041132)"
+       cx="33.966679"
+       cy="35.736916"
+       fx="33.966679"
+       fy="35.736916"
+       r="86.70845" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient269"
+       id="radialGradient11185"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.968273,0,0,1.032767,3.353553,0.646447)"
+       cx="8.824419"
+       cy="3.7561285"
+       fx="8.824419"
+       fy="3.7561285"
+       r="37.751713" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient15662"
+       id="radialGradient11187"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.968273,0,0,1.032767,3.353553,0.646447)"
+       cx="8.1435566"
+       cy="7.2678967"
+       fx="8.1435566"
+       fy="7.2678967"
+       r="38.158695" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#aigrd2"
+       id="radialGradient11189"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.229703,0,0,0.229703,4.613529,3.979808)"
+       cx="20.892099"
+       cy="114.5684"
+       fx="20.892099"
+       fy="114.5684"
+       r="5.256" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#aigrd3"
+       id="radialGradient11191"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.229703,0,0,0.229703,4.613529,3.979808)"
+       cx="20.892099"
+       cy="64.567902"
+       fx="20.892099"
+       fy="64.567902"
+       r="5.257" />
+    <linearGradient
+       y2="31.026741"
+       x2="22.17771"
+       y1="33.357376"
+       x1="17.397203"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1505"
+       xlink:href="#linearGradient2573-9"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="7.4121075"
+       x2="40.024059"
+       y1="4.2507305"
+       x1="11.841544"
+       gradientTransform="matrix(1.370928,0,0,-1.46456,2.525057,33.71269)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1503"
+       xlink:href="#linearGradient9749-0"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="-7.5274644"
+       x2="17.178024"
+       y1="20.219761"
+       x1="10.027"
+       gradientTransform="matrix(1.570607,0,0,-1.231511,2.973436,33.33485)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1501"
+       xlink:href="#linearGradient15107-6"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="11.981981"
+       x2="13.846983"
+       y1="11.48487"
+       x1="11.74217"
+       gradientTransform="matrix(1.296015,0,0,-1.43692,3.746576,33.20516)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1497"
+       xlink:href="#linearGradient15107-6"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="11.981981"
+       x2="13.846983"
+       y1="11.48487"
+       x1="11.74217"
+       gradientTransform="matrix(1.276531,0,0,-1.406115,24.24763,33.3374)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1493-0"
+       xlink:href="#linearGradient15107-6"
+       inkscape:collect="always" />
+    <radialGradient
+       r="17.977943"
+       fy="38.711506"
+       fx="27.741131"
+       cy="38.711506"
+       cx="27.741131"
+       gradientTransform="matrix(0.629929,0.459373,-0.147675,0.248512,16.51724,9.053737)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient1491"
+       xlink:href="#linearGradient2274-9"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="52.090679"
+       x2="9.8855038"
+       y1="38.070892"
+       x1="9.1643066"
+       gradientTransform="matrix(2.454781,0,0,0.762004,2.88175,0.337386)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1487"
+       xlink:href="#linearGradient2624-6"
+       inkscape:collect="always" />
+    <linearGradient
+       y2="26.022909"
+       x2="18.475286"
+       y1="4.7461624"
+       x1="11.572842"
+       gradientTransform="matrix(1.343475,0,0,1.505846,2.879511,-2.266018)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient1483"
+       xlink:href="#linearGradient15107-6"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient4274-7">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:0.25490198;"
+         offset="0.0000000"
+         id="stop4276-3" />
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop4278-5" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient15107-6">
+      <stop
+         id="stop15109-8"
+         offset="0.0000000"
+         style="stop-color:#ffffff;stop-opacity:1.0000000;" />
+      <stop
+         id="stop15111-9"
+         offset="1.0000000"
+         style="stop-color:#e2e2e2;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient9749-0">
+      <stop
+         id="stop9751-2"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop9753-3"
+         offset="1.0000000"
+         style="stop-color:#ededed;stop-opacity:1.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2274-9">
+      <stop
+         id="stop2276-4"
+         offset="0.0000000"
+         style="stop-color:#000000;stop-opacity:0.12871288;" />
+      <stop
+         id="stop2278-2"
+         offset="1.0000000"
+         style="stop-color:#000000;stop-opacity:0.0000000;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2573-9"
+       inkscape:collect="always">
+      <stop
+         id="stop2575-9"
+         offset="0"
+         style="stop-color:#ffffff;stop-opacity:1;" />
+      <stop
+         id="stop2577-6"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2624-6">
+      <stop
+         style="stop-color:#dfe0df;stop-opacity:1;"
+         offset="0"
+         id="stop2626-1" />
+      <stop
+         id="stop2630-9"
+         offset="0.23809524"
+         style="stop-color:#a6b0a6;stop-opacity:1;" />
+      <stop
+         style="stop-color:#b5beb5;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop2628-4" />
+    </linearGradient>
+    <linearGradient
+       y2="609.50507"
+       x2="302.85715"
+       y1="366.64789"
+       x1="302.85715"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1892.179,-872.8854)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient5027"
+       xlink:href="#linearGradient5048-2"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient5048-2">
+      <stop
+         id="stop5050-7"
+         offset="0"
+         style="stop-color:black;stop-opacity:0;" />
+      <stop
+         style="stop-color:black;stop-opacity:1;"
+         offset="0.5"
+         id="stop5056-2" />
+      <stop
+         id="stop5052-01"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <radialGradient
+       r="117.14286"
+       fy="486.64789"
+       fx="605.71429"
+       cy="486.64789"
+       cx="605.71429"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1891.633,-872.8854)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient5029"
+       xlink:href="#linearGradient5060-4"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient5060-4"
+       inkscape:collect="always">
+      <stop
+         id="stop5062-24"
+         offset="0"
+         style="stop-color:black;stop-opacity:1;" />
+      <stop
+         id="stop5064-0"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <radialGradient
+       r="117.14286"
+       fy="486.64789"
+       fx="605.71429"
+       cy="486.64789"
+       cx="605.71429"
+       gradientTransform="matrix(-2.774389,0,0,1.969706,112.7623,-872.8854)"
+       gradientUnits="userSpaceOnUse"
+       id="radialGradient5031"
+       xlink:href="#linearGradient5060-4"
+       inkscape:collect="always" />
+    <linearGradient
+       id="linearGradient5048-3">
+      <stop
+         id="stop5050-23"
+         offset="0"
+         style="stop-color:black;stop-opacity:0;" />
+      <stop
+         style="stop-color:black;stop-opacity:1;"
+         offset="0.5"
+         id="stop5056-8" />
+      <stop
+         id="stop5052-05"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient5060-5"
+       inkscape:collect="always">
+      <stop
+         id="stop5062-1"
+         offset="0"
+         style="stop-color:black;stop-opacity:1;" />
+      <stop
+         id="stop5064-5"
+         offset="1"
+         style="stop-color:black;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient259-5">
+      <stop
+         style="stop-color:#fafafa;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop260-8" />
+      <stop
+         style="stop-color:#bbbbbb;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop261-9" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient269-3">
+      <stop
+         style="stop-color:#a3a3a3;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop270-6" />
+      <stop
+         style="stop-color:#4c4c4c;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop271-7" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient15662-6">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1.0000000;"
+         offset="0.0000000"
+         id="stop15664-2" />
+      <stop
+         style="stop-color:#f8f8f8;stop-opacity:1.0000000;"
+         offset="1.0000000"
+         id="stop15666-5" />
+    </linearGradient>
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       fy="114.5684"
+       fx="20.892099"
+       r="5.256"
+       cy="114.5684"
+       cx="20.892099"
+       id="aigrd2-0">
+      <stop
+         id="stop15566-0"
+         style="stop-color:#F0F0F0"
+         offset="0" />
+      <stop
+         id="stop15568-0"
+         style="stop-color:#9a9a9a;stop-opacity:1.0000000;"
+         offset="1.0000000" />
+    </radialGradient>
+    <radialGradient
+       gradientUnits="userSpaceOnUse"
+       fy="64.567902"
+       fx="20.892099"
+       r="5.257"
+       cy="64.567902"
+       cx="20.892099"
+       id="aigrd3-2">
+      <stop
+         id="stop15573-8"
+         style="stop-color:#F0F0F0"
+         offset="0" />
+      <stop
+         id="stop15575-8"
+         style="stop-color:#9a9a9a;stop-opacity:1.0000000;"
+         offset="1.0000000" />
+    </radialGradient>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5048-3"
+       id="linearGradient13544"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1892.179,-872.8854)"
+       x1="302.85715"
+       y1="366.64789"
+       x2="302.85715"
+       y2="609.50507" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5060-5"
+       id="radialGradient13546"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.774389,0,0,1.969706,-1891.633,-872.8854)"
+       cx="605.71429"
+       cy="486.64789"
+       fx="605.71429"
+       fy="486.64789"
+       r="117.14286" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient5060-5"
+       id="radialGradient13548"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(-2.774389,0,0,1.969706,112.7623,-872.8854)"
+       cx="605.71429"
+       cy="486.64789"
+       fx="605.71429"
+       fy="486.64789"
+       r="117.14286" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient259-5"
+       id="radialGradient13550"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="scale(0.960493,1.041132)"
+       cx="33.966679"
+       cy="35.736916"
+       fx="33.966679"
+       fy="35.736916"
+       r="86.70845" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient269-3"
+       id="radialGradient13552"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.968273,0,0,1.032767,3.353553,0.646447)"
+       cx="8.824419"
+       cy="3.7561285"
+       fx="8.824419"
+       fy="3.7561285"
+       r="37.751713" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient15662-6"
+       id="radialGradient13554"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.968273,0,0,1.032767,3.353553,0.646447)"
+       cx="8.1435566"
+       cy="7.2678967"
+       fx="8.1435566"
+       fy="7.2678967"
+       r="38.158695" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#aigrd2-0"
+       id="radialGradient13556"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.229703,0,0,0.229703,4.613529,3.979808)"
+       cx="20.892099"
+       cy="114.5684"
+       fx="20.892099"
+       fy="114.5684"
+       r="5.256" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#aigrd3-2"
+       id="radialGradient13558"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.229703,0,0,0.229703,4.613529,3.979808)"
+       cx="20.892099"
+       cy="64.567902"
+       fx="20.892099"
+       fy="64.567902"
+       r="5.257" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient13629"
+       id="linearGradient13635"
+       x1="135"
+       y1="317.36218"
+       x2="105"
+       y2="237.36218"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       y2="248.6311"
+       x2="153.0005"
+       y1="15.4238"
+       x1="99.777298"
+       gradientUnits="userSpaceOnUse"
+       id="aigrd1">
+      <stop
+         id="stop53300"
+         style="stop-color:#184375"
+         offset="0" />
+      <stop
+         id="stop53302"
+         style="stop-color:#C8BDDC"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient2300">
+      <stop
+         style="stop-color:#000000;stop-opacity:0.32673267;"
+         offset="0.0000000"
+         id="stop2302" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop2304" />
+    </linearGradient>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient2300"
+       id="radialGradient15544"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.399258,-2.234445e-7,8.196178e-8,0.513264,4.365074,4.839285)"
+       cx="14.287618"
+       cy="68.872971"
+       fx="14.287618"
+       fy="72.568001"
+       r="11.68987" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#aigrd1"
+       id="linearGradient15546"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.200685,0,0,0.200685,-0.585758,-1.050787)"
+       x1="99.777298"
+       y1="15.4238"
+       x2="153.0005"
+       y2="248.6311" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient15558"
+       id="linearGradient15564"
+       x1="350"
+       y1="352.36218"
+       x2="350"
+       y2="272.36218"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient15568"
+       id="linearGradient15574"
+       x1="350"
+       y1="452.36218"
+       x2="340"
+       y2="342.36218"
+       gradientUnits="userSpaceOnUse" />
+  </defs>
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="1.4"
+     inkscape:cx="249.31284"
+     inkscape:cy="117.69757"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     inkscape:window-width="1280"
+     inkscape:window-height="750"
+     inkscape:window-x="-1"
+     inkscape:window-y="26"
+     showgrid="true"
+     inkscape:window-maximized="1"
+     fit-margin-top="0"
+     fit-margin-left="0"
+     fit-margin-right="0"
+     fit-margin-bottom="0">
+    <inkscape:grid
+       type="xygrid"
+       id="grid10878"
+       empspacing="5"
+       visible="true"
+       enabled="true"
+       snapvisiblegridlinesonly="true"
+       color="#0000ff"
+       opacity="0.04705882" />
+  </sodipodi:namedview>
+  <metadata
+     id="metadata1906">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     inkscape:label="Taso 1"
+     inkscape:groupmode="layer"
+     id="layer1"
+     transform="translate(-60,-212.36218)">
+    <path
+       style="fill:url(#linearGradient15574);fill-opacity:1;stroke:none"
+       d="m 214,392.36218 25,-25 275,0 25,25 -25,25 -275,0 z"
+       id="path15566"
+       inkscape:connector-curvature="0" />
+    <path
+       style="fill:url(#linearGradient15564);fill-opacity:1;stroke:none"
+       d="m 230,332.36218 0,-40 0,-10 290,0 0,50 -20,20 -90,0 0,5 -30,20 -30,-20 0,-5 -100,0 z"
+       id="path15548"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccccccccccc" />
+    <path
+       style="fill:url(#linearGradient13635);fill-opacity:1;stroke:none"
+       d="m 70,287.36218 0,-60 230,0 20,20 0,45 -35,20 -35,-20 0,-5 z"
+       id="path13627"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccccccc" />
+    <g
+       id="g10938"
+       transform="translate(0,0.21712644)">
+      <g
+         transform="matrix(0.69596564,0,0,0.69596564,116.34319,233.05094)"
+         id="g3694">
+        <g
+           id="layer6"
+           inkscape:label="Shadow">
+          <g
+             style="display:inline"
+             transform="matrix(0.02105461,0,0,0.02086758,42.85172,41.1536)"
+             id="g6707">
+            <rect
+               style="opacity:0.40206185;color:#000000;fill:url(#linearGradient11177);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible"
+               id="rect6709"
+               width="1339.6335"
+               height="478.35718"
+               x="-1559.2523"
+               y="-150.69685" />
+            <path
+               inkscape:connector-curvature="0"
+               style="opacity:0.40206185;color:#000000;fill:url(#radialGradient11179);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible"
+               d="m -219.61876,-150.68038 c 0,0 0,478.33079 0,478.33079 142.874166,0.90045 345.40022,-107.16966 345.40014,-239.196175 0,-132.026537 -159.436816,-239.134595 -345.40014,-239.134615 z"
+               id="path6711"
+               sodipodi:nodetypes="cccc" />
+            <path
+               inkscape:connector-curvature="0"
+               sodipodi:nodetypes="cccc"
+               id="path6713"
+               d="m -1559.2523,-150.68038 c 0,0 0,478.33079 0,478.33079 -142.8742,0.90045 -345.4002,-107.16966 -345.4002,-239.196175 0,-132.026537 159.4368,-239.134595 345.4002,-239.134615 z"
+               style="opacity:0.40206185;color:#000000;fill:url(#radialGradient11181);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible" />
+          </g>
+        </g>
+        <g
+           style="display:inline"
+           inkscape:label="Base"
+           id="layer1-8">
+          <rect
+             style="color:#000000;fill:url(#radialGradient11183);fill-opacity:1;fill-rule:nonzero;stroke:url(#radialGradient11185);stroke-width:1.43685257;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dashoffset:0;marker:none;visibility:visible;display:block;overflow:visible"
+             id="rect15391"
+             width="34.875"
+             height="40.920494"
+             x="6.6035528"
+             y="3.6464462"
+             ry="1.1490486" />
+          <rect
+             style="color:#000000;fill:none;stroke:url(#radialGradient11187);stroke-width:1.43685257;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dashoffset:0;marker:none;visibility:visible;display:block;overflow:visible"
+             id="rect15660"
+             width="32.775887"
+             height="38.946384"
+             x="7.6660538"
+             y="4.5839462"
+             ry="0.14904857"
+             rx="0.14904857" />
+          <g
+             transform="translate(0.646447,-0.03798933)"
+             id="g2270">
+            <g
+               id="g1440"
+               style="fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1.43685257;stroke-miterlimit:4"
+               transform="matrix(0.229703,0,0,0.229703,4.967081,4.244972)">
+              <radialGradient
+                 id="radialGradient1442"
+                 cx="20.892099"
+                 cy="114.5684"
+                 r="5.256"
+                 fx="20.892099"
+                 fy="114.5684"
+                 gradientUnits="userSpaceOnUse">
+                <stop
+                   offset="0"
+                   style="stop-color:#F0F0F0"
+                   id="stop1444" />
+                <stop
+                   offset="1"
+                   style="stop-color:#474747"
+                   id="stop1446" />
+              </radialGradient>
+              <path
+                 inkscape:connector-curvature="0"
+                 style="stroke:none"
+                 d="m 23.428,113.07 c 0,1.973 -1.6,3.572 -3.573,3.572 -1.974,0 -3.573,-1.6 -3.573,-3.572 0,-1.974 1.6,-3.573 3.573,-3.573 1.973,0 3.573,1.6 3.573,3.573 z"
+                 id="path1448" />
+              <radialGradient
+                 id="radialGradient1450"
+                 cx="20.892099"
+                 cy="64.567902"
+                 r="5.257"
+                 fx="20.892099"
+                 fy="64.567902"
+                 gradientUnits="userSpaceOnUse">
+                <stop
+                   offset="0"
+                   style="stop-color:#F0F0F0"
+                   id="stop1452" />
+                <stop
+                   offset="1"
+                   style="stop-color:#474747"
+                   id="stop1454" />
+              </radialGradient>
+              <path
+                 inkscape:connector-curvature="0"
+                 style="stroke:none"
+                 d="m 23.428,63.07 c 0,1.973 -1.6,3.573 -3.573,3.573 -1.974,0 -3.573,-1.6 -3.573,-3.573 0,-1.974 1.6,-3.573 3.573,-3.573 1.973,0 3.573,1.6 3.573,3.573 z"
+                 id="path1456" />
+            </g>
+            <path
+               inkscape:connector-curvature="0"
+               style="fill:url(#radialGradient11189);fill-rule:nonzero;stroke:none"
+               d="m 9.9950109,29.952326 c 0,0.453204 -0.3675248,0.820499 -0.8207288,0.820499 -0.4534338,0 -0.8207289,-0.367524 -0.8207289,-0.820499 0,-0.453434 0.3675248,-0.820729 0.8207289,-0.820729 0.453204,0 0.8207288,0.367525 0.8207288,0.820729 z"
+               id="path15570" />
+            <path
+               inkscape:connector-curvature="0"
+               style="fill:url(#radialGradient11191);fill-rule:nonzero;stroke:none"
+               d="m 9.9950109,18.467176 c 0,0.453204 -0.3675248,0.820729 -0.8207288,0.820729 -0.4534338,0 -0.8207289,-0.367525 -0.8207289,-0.820729 0,-0.453434 0.3675248,-0.820729 0.8207289,-0.820729 0.453204,0 0.8207288,0.367525 0.8207288,0.820729 z"
+               id="path15577" />
+          </g>
+          <path
+             inkscape:connector-curvature="0"
+             style="fill:none;stroke:#000000;stroke-width:1.42040503;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:0.01754384"
+             d="m 11.505723,5.4942766 0,37.9065924"
+             id="path15672"
+             sodipodi:nodetypes="cc" />
+          <path
+             inkscape:connector-curvature="0"
+             style="fill:none;stroke:#ffffff;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:0.20467828"
+             d="m 12.5,5.0205154 0,38.0177126"
+             id="path15674"
+             sodipodi:nodetypes="cc" />
+        </g>
+        <g
+           id="layer5"
+           inkscape:label="Text"
+           style="display:inline">
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="9"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15686"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="11"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15688"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="13"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15690"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="15"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15692"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="17"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15694"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="19"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15696"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="21"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15698"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.13778631"
+             y="23"
+             x="15.999994"
+             height="1"
+             width="20.000006"
+             id="rect15700"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <rect
+             ry="0.065390877"
+             rx="0.062003858"
+             y="25"
+             x="15.999986"
+             height="1"
+             width="9.0000057"
+             id="rect15732"
+             style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+          <g
+             id="g4849">
+            <rect
+               style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+               id="rect15736"
+               width="20.000006"
+               height="1"
+               x="15.999986"
+               y="29"
+               rx="0.13778631"
+               ry="0.065390877" />
+            <rect
+               style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+               id="rect15738"
+               width="20.000006"
+               height="1"
+               x="15.999986"
+               y="31"
+               rx="0.13778631"
+               ry="0.065390877" />
+            <rect
+               style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+               id="rect15740"
+               width="20.000006"
+               height="1"
+               x="15.999986"
+               y="33"
+               rx="0.13778631"
+               ry="0.065390877" />
+            <rect
+               style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+               id="rect15742"
+               width="20.000006"
+               height="1"
+               x="15.999986"
+               y="35"
+               rx="0.13778631"
+               ry="0.065390877" />
+            <rect
+               style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+               id="rect15744"
+               width="14.000014"
+               height="1"
+               x="15.999986"
+               y="37"
+               rx="0.096450485"
+               ry="0.065390877" />
+          </g>
+        </g>
+      </g>
+      <text
+         sodipodi:linespacing="125%"
+         id="text7676"
+         y="279.34702"
+         x="85.84211"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="279.34702"
+           x="85.84211"
+           id="tspan7678"
+           sodipodi:role="line">MyMessage.proto</tspan></text>
+    </g>
+    <g
+       id="g11049"
+       transform="translate(74.824219,-16)">
+      <text
+         sodipodi:linespacing="125%"
+         id="text7692"
+         y="408.36218"
+         x="269.17578"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="408.36218"
+           x="269.17578"
+           id="tspan7694"
+           sodipodi:role="line">pb_encode( );</tspan></text>
+      <text
+         sodipodi:linespacing="125%"
+         id="text7696"
+         y="421.36218"
+         x="269"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="421.36218"
+           x="269"
+           id="tspan7698"
+           sodipodi:role="line">pb_decode( );</tspan></text>
+    </g>
+    <g
+       id="g10981"
+       transform="translate(40.612196,-41.994574)">
+      <text
+         sodipodi:linespacing="125%"
+         id="text7688"
+         y="321.55872"
+         x="161.02837"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="321.55872"
+           x="161.02837"
+           id="tspan7690"
+           sodipodi:role="line">nanopb_generator.py</tspan></text>
+      <g
+         transform="matrix(0.20866613,0,0,0.20866613,166.72161,281.75965)"
+         id="g10620">
+        <path
+           inkscape:connector-curvature="0"
+           id="path46"
+           style="fill:#646464;fill-opacity:1"
+           d="m 184.61344,61.929363 c 0,-14.56215 -4.15226,-22.03817 -12.45678,-22.44755 -3.30427,-0.15595 -6.53055,0.37039 -9.66912,1.58878 -2.505,0.89673 -4.19124,1.78372 -5.07823,2.68045 l 0,34.75812 c 5.31216,3.33351 10.02976,4.88329 14.14303,4.63962 8.70415,-0.57508 13.0611,-7.64172 13.0611,-21.21942 z m 10.24419,0.60432 c 0,7.39804 -1.73498,13.53871 -5.22444,18.422 -3.88909,5.5266 -9.27923,8.37275 -16.17042,8.52871 -5.1952,0.1657 -10.54635,-1.46207 -16.05346,-4.87355 l 0,31.590317 -8.90884,-3.17755 0,-70.120567 c 1.46206,-1.79346 3.34325,-3.3335 5.62407,-4.63961 5.30242,-3.08983 11.74524,-4.67861 19.32848,-4.75658 l 0.12671,0.12671 c 6.93018,-0.08773 12.27159,2.75843 16.02422,8.5287 3.4992,5.29267 5.25368,12.07665 5.25368,20.37142 z" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path48"
+           style="fill:#646464;fill-opacity:1"
+           d="m 249.30487,83.265743 c 0,9.92254 -0.9942,16.794237 -2.9826,20.615097 -1.99816,3.82086 -5.79952,6.8717 -11.41385,9.14277 -4.55189,1.79346 -9.47417,2.76817 -14.75709,2.93387 l -1.47181,-5.61432 c 5.37064,-0.73103 9.15252,-1.46207 11.34561,-2.1931 4.31796,-1.46206 7.28108,-3.70389 8.90884,-6.706 1.30611,-2.446517 1.94942,-7.115367 1.94942,-14.026057 l 0,-2.3198 c -6.09193,2.76817 -12.47628,4.14251 -19.15303,4.14251 -4.38619,0 -8.25579,-1.37434 -11.58929,-4.14251 -3.74289,-3.01186 -5.61433,-6.83272 -5.61433,-11.46258 l 0,-37.07793 8.90884,-3.05084 0,37.3216 c 0,3.98656 1.28662,7.0569 3.85985,9.21101 2.57323,2.1541 5.90674,3.18729 9.99077,3.10932 4.08403,-0.08773 8.46047,-1.66676 13.10983,-4.75658 l 0,-43.54025 8.90884,0 0,48.41379 z" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path50"
+           style="fill:#646464;fill-opacity:1"
+           d="m 284.08249,88.997033 c -1.06243,0.08772 -2.03714,0.12671 -2.93387,0.12671 -5.03925,0 -8.96733,-1.19889 -11.77449,-3.60642 -2.79742,-2.40753 -4.20099,-5.73129 -4.20099,-9.97127 l 0,-35.08953 -6.10168,0 0,-5.60457 6.10168,0 0,-14.88381 8.89909,-3.16781 0,18.05162 10.01026,0 0,5.60457 -10.01026,0 0,34.84585 c 0,3.34325 0.89673,5.71179 2.6902,7.09588 1.54004,1.14041 3.98656,1.79347 7.32006,1.95917 l 0,4.63961 z" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path52"
+           style="fill:#646464;fill-opacity:1"
+           d="m 338.02288,88.266003 -8.90884,0 0,-34.38773 c 0,-3.49921 -0.81876,-6.51106 -2.44651,-9.02581 -1.88119,-2.84615 -4.49342,-4.26923 -7.84641,-4.26923 -4.08404,0 -9.19152,2.15411 -15.32242,6.46233 l 0,41.22044 -8.90885,0 0,-82.1972101 8.90885,-2.80716 0,37.4385701 c 5.6923,-4.14251 11.91093,-6.21864 18.66566,-6.21864 4.7176,0 8.53846,1.58877 11.46258,4.75658 2.93388,3.1678 4.39594,7.11537 4.39594,11.83296 l 0,37.1949 0,0 z" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path54"
+           style="fill:#646464;fill-opacity:1"
+           d="m 385.37424,60.525783 c 0,-5.59483 -1.06242,-10.21495 -3.17755,-13.87011 -2.51474,-4.45442 -6.42332,-6.80347 -11.70625,-7.04715 -9.76658,0.56534 -14.64012,7.56375 -14.64012,20.97574 0,6.15042 1.01369,11.28713 3.06057,15.41015 2.61223,5.25368 6.53056,7.84641 11.755,7.75869 9.80557,-0.07798 14.70835,-7.81717 14.70835,-23.22732 z m 9.75685,0.05848 c 0,7.96338 -2.03714,14.5914 -6.10168,19.88407 -4.47391,5.92623 -10.65357,8.89909 -18.53897,8.89909 -7.81716,0 -13.90909,-2.97286 -18.30503,-8.89909 -3.98656,-5.29267 -5.97497,-11.92069 -5.97497,-19.88407 0,-7.48576 2.15411,-13.78238 6.46232,-18.90935 4.5519,-5.43888 10.53661,-8.16806 17.93464,-8.16806 7.39805,0 13.42174,2.72918 18.06137,8.16806 4.3082,5.12697 6.46232,11.42359 6.46232,18.90935 z" />
+        <path
+           inkscape:connector-curvature="0"
+           id="path56"
+           style="fill:#646464;fill-opacity:1"
+           d="m 446.20583,88.266003 -8.90884,0 0,-36.33715 c 0,-3.98656 -1.19889,-7.09588 -3.59667,-9.33772 -2.39779,-2.23208 -5.59483,-3.31401 -9.58139,-3.22628 -4.23023,0.07798 -8.25579,1.46206 -12.07664,4.14251 l 0,44.75864 -8.90884,0 0,-45.86006 c 5.12697,-3.73313 9.84456,-6.16991 14.15276,-7.31032 4.06455,-1.06243 7.65148,-1.58877 10.74131,-1.58877 2.11512,0 4.10352,0.20469 5.97496,0.61406 3.49921,0.80901 6.34535,2.31006 8.53845,4.51291 2.44651,2.43677 3.6649,5.3609 3.6649,8.78212 l 0,40.85006 z" />
+        <path
+           inkscape:connector-curvature="0"
+           style="fill:url(#linearGradient11109);fill-opacity:1"
+           d="m 60.510156,6.3979729 c -4.583653,0.021298 -8.960939,0.4122177 -12.8125,1.09375 C 36.35144,9.4962267 34.291407,13.691825 34.291406,21.429223 l 0,10.21875 26.8125,0 0,3.40625 -26.8125,0 -10.0625,0 c -7.792459,0 -14.6157592,4.683717 -16.7500002,13.59375 -2.46182,10.212966 -2.5710151,16.586023 0,27.25 1.9059283,7.937852 6.4575432,13.593748 14.2500002,13.59375 l 9.21875,0 0,-12.25 c 0,-8.849902 7.657144,-16.656248 16.75,-16.65625 l 26.78125,0 c 7.454951,0 13.406253,-6.138164 13.40625,-13.625 l 0,-25.53125 c 0,-7.266339 -6.12998,-12.7247775 -13.40625,-13.9375001 -4.605987,-0.7667253 -9.385097,-1.1150483 -13.96875,-1.09375 z m -14.5,8.2187501 c 2.769547,0 5.03125,2.298646 5.03125,5.125 -2e-6,2.816336 -2.261703,5.09375 -5.03125,5.09375 -2.779476,-1e-6 -5.03125,-2.277415 -5.03125,-5.09375 -1e-6,-2.826353 2.251774,-5.125 5.03125,-5.125 z"
+           id="path1948" />
+        <path
+           inkscape:connector-curvature="0"
+           style="fill:url(#linearGradient11111);fill-opacity:1"
+           d="m 91.228906,35.054223 0,11.90625 c 0,9.230755 -7.825895,16.999999 -16.75,17 l -26.78125,0 c -7.335833,0 -13.406249,6.278483 -13.40625,13.625 l 0,25.531247 c 0,7.26634 6.318588,11.54032 13.40625,13.625 8.487331,2.49561 16.626237,2.94663 26.78125,0 6.750155,-1.95439 13.406253,-5.88761 13.40625,-13.625 l 0,-10.218747 -26.78125,0 0,-3.40625 26.78125,0 13.406254,0 c 7.79246,0 10.69625,-5.435408 13.40624,-13.59375 2.79933,-8.398886 2.68022,-16.475776 0,-27.25 -1.92578,-7.757441 -5.60387,-13.59375 -13.40624,-13.59375 l -10.062504,0 z m -15.0625,64.65625 c 2.779478,3e-6 5.03125,2.277417 5.03125,5.093747 -2e-6,2.82635 -2.251775,5.125 -5.03125,5.125 -2.76955,0 -5.03125,-2.29865 -5.03125,-5.125 2e-6,-2.81633 2.261697,-5.093747 5.03125,-5.093747 z"
+           id="path1950" />
+        <path
+           inkscape:connector-curvature="0"
+           d="m 463.5544,26.909383 1.56195,0 0,-9.79624 3.70013,0 0,-1.16766 -8.96221,0 0,1.16766 3.70013,0 0,9.79624 m 6.64702,0 1.33447,0 0,-8.94703 2.89641,8.945906 1.48569,0 3.01816,-8.915576 0,8.9167 1.45579,0 0,-10.9639 -1.92589,0 -3.29831,9.392857 -2.81297,-9.392857 -2.15335,0 0,10.9639"
+           style="font-size:15.16445827px;font-style:normal;font-weight:normal;line-height:125%;fill:#646464;fill-opacity:1;stroke:none;font-family:Bitstream Vera Sans"
+           id="text3004"
+           sodipodi:nodetypes="ccccccccccccccccccccccc" />
+        <path
+           sodipodi:type="arc"
+           style="opacity:0.44382019;fill:url(#radialGradient11113);fill-opacity:1;fill-rule:nonzero;stroke:none"
+           id="path1894"
+           sodipodi:cx="61.518883"
+           sodipodi:cy="132.28575"
+           sodipodi:rx="48.948284"
+           sodipodi:ry="8.6066771"
+           d="m 110.46717,132.28575 c 0,4.75334 -21.914896,8.60668 -48.948287,8.60668 -27.033391,0 -48.948284,-3.85334 -48.948284,-8.60668 0,-4.75334 21.914893,-8.60668 48.948284,-8.60668 27.033391,0 48.948287,3.85334 48.948287,8.60668 z"
+           transform="matrix(0.73406,0,0,0.809524,16.24958,27.00935)" />
+      </g>
+    </g>
+    <g
+       transform="translate(221.34207,203.5191)"
+       id="g10632">
+      <g
+         id="g10678"
+         inkscape:label="Text"
+         style="display:inline" />
+    </g>
+    <g
+       id="g13491"
+       transform="translate(24.020135,-23.566724)">
+      <text
+         sodipodi:linespacing="125%"
+         id="text7680"
+         y="360.05713"
+         x="215.79094"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="360.05713"
+           x="215.79094"
+           id="tspan7682"
+           sodipodi:role="line">MyMessage.pb.c</tspan></text>
+      <text
+         sodipodi:linespacing="125%"
+         id="text7684"
+         y="346.05713"
+         x="215.73695"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="346.05713"
+           x="215.73695"
+           id="tspan7686"
+           sodipodi:role="line">MyMessage.pb.h</tspan></text>
+    </g>
+    <g
+       id="g13560"
+       transform="translate(1.7323942,-7.4432063)">
+      <g
+         transform="matrix(0.69596564,0,0,0.69596564,207.04204,157.31974)"
+         id="g10800-7">
+        <g
+           transform="translate(221.34207,203.5191)"
+           id="g10634-0"
+           inkscape:label="Shadow">
+          <g
+             style="display:inline"
+             transform="matrix(0.02105461,0,0,0.02086758,42.85172,41.1536)"
+             id="g10636-1">
+            <rect
+               style="opacity:0.40206185;color:#000000;fill:url(#linearGradient13544);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible"
+               id="rect10638-5"
+               width="1339.6335"
+               height="478.35718"
+               x="-1559.2523"
+               y="-150.69685" />
+            <path
+               inkscape:connector-curvature="0"
+               style="opacity:0.40206185;color:#000000;fill:url(#radialGradient13546);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible"
+               d="m -219.61876,-150.68038 c 0,0 0,478.33079 0,478.33079 142.874166,0.90045 345.40022,-107.16966 345.40014,-239.196175 0,-132.026537 -159.436816,-239.134595 -345.40014,-239.134615 z"
+               id="path10640-0"
+               sodipodi:nodetypes="cccc" />
+            <path
+               inkscape:connector-curvature="0"
+               sodipodi:nodetypes="cccc"
+               id="path10642-8"
+               d="m -1559.2523,-150.68038 c 0,0 0,478.33079 0,478.33079 -142.8742,0.90045 -345.4002,-107.16966 -345.4002,-239.196175 0,-132.026537 159.4368,-239.134595 345.4002,-239.134615 z"
+               style="opacity:0.40206185;color:#000000;fill:url(#radialGradient13548);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible" />
+          </g>
+        </g>
+        <g
+           transform="translate(221.34207,203.5191)"
+           style="display:inline"
+           inkscape:label="Base"
+           id="g10644-0">
+          <rect
+             style="color:#000000;fill:url(#radialGradient13550);fill-opacity:1;fill-rule:nonzero;stroke:url(#radialGradient13552);stroke-width:1.43685257;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dashoffset:0;marker:none;visibility:visible;display:block;overflow:visible"
+             id="rect10646-7"
+             width="34.875"
+             height="40.920494"
+             x="6.6035528"
+             y="3.6464462"
+             ry="1.1490486" />
+          <rect
+             style="color:#000000;fill:none;stroke:url(#radialGradient13554);stroke-width:1.43685257;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dashoffset:0;marker:none;visibility:visible;display:block;overflow:visible"
+             id="rect10648-1"
+             width="32.775887"
+             height="38.946384"
+             x="7.6660538"
+             y="4.5839462"
+             ry="0.14904857"
+             rx="0.14904857" />
+          <g
+             transform="translate(0.646447,-0.03798933)"
+             id="g10650-5">
+            <g
+               id="g10652-1"
+               style="fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:#000000;stroke-width:1.43685257;stroke-miterlimit:4"
+               transform="matrix(0.229703,0,0,0.229703,4.967081,4.244972)">
+              <radialGradient
+                 id="radialGradient10654-3"
+                 cx="20.892099"
+                 cy="114.5684"
+                 r="5.256"
+                 fx="20.892099"
+                 fy="114.5684"
+                 gradientUnits="userSpaceOnUse">
+                <stop
+                   offset="0"
+                   style="stop-color:#F0F0F0"
+                   id="stop10656-3" />
+                <stop
+                   offset="1"
+                   style="stop-color:#474747"
+                   id="stop10658-9" />
+              </radialGradient>
+              <path
+                 inkscape:connector-curvature="0"
+                 style="stroke:none"
+                 d="m 23.428,113.07 c 0,1.973 -1.6,3.572 -3.573,3.572 -1.974,0 -3.573,-1.6 -3.573,-3.572 0,-1.974 1.6,-3.573 3.573,-3.573 1.973,0 3.573,1.6 3.573,3.573 z"
+                 id="path10660-4" />
+              <radialGradient
+                 id="radialGradient10662-8"
+                 cx="20.892099"
+                 cy="64.567902"
+                 r="5.257"
+                 fx="20.892099"
+                 fy="64.567902"
+                 gradientUnits="userSpaceOnUse">
+                <stop
+                   offset="0"
+                   style="stop-color:#F0F0F0"
+                   id="stop10664-2" />
+                <stop
+                   offset="1"
+                   style="stop-color:#474747"
+                   id="stop10666-3" />
+              </radialGradient>
+              <path
+                 inkscape:connector-curvature="0"
+                 style="stroke:none"
+                 d="m 23.428,63.07 c 0,1.973 -1.6,3.573 -3.573,3.573 -1.974,0 -3.573,-1.6 -3.573,-3.573 0,-1.974 1.6,-3.573 3.573,-3.573 1.973,0 3.573,1.6 3.573,3.573 z"
+                 id="path10668-6" />
+            </g>
+            <path
+               inkscape:connector-curvature="0"
+               style="fill:url(#radialGradient13556);fill-rule:nonzero;stroke:none"
+               d="m 9.9950109,29.952326 c 0,0.453204 -0.3675248,0.820499 -0.8207288,0.820499 -0.4534338,0 -0.8207289,-0.367524 -0.8207289,-0.820499 0,-0.453434 0.3675248,-0.820729 0.8207289,-0.820729 0.453204,0 0.8207288,0.367525 0.8207288,0.820729 z"
+               id="path10670-0" />
+            <path
+               inkscape:connector-curvature="0"
+               style="fill:url(#radialGradient13558);fill-rule:nonzero;stroke:none"
+               d="m 9.9950109,18.467176 c 0,0.453204 -0.3675248,0.820729 -0.8207288,0.820729 -0.4534338,0 -0.8207289,-0.367525 -0.8207289,-0.820729 0,-0.453434 0.3675248,-0.820729 0.8207289,-0.820729 0.453204,0 0.8207288,0.367525 0.8207288,0.820729 z"
+               id="path10672-9" />
+          </g>
+          <path
+             inkscape:connector-curvature="0"
+             style="fill:none;stroke:#000000;stroke-width:1.42040503;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:0.01754384"
+             d="m 11.505723,5.4942766 0,37.9065924"
+             id="path10674-0"
+             sodipodi:nodetypes="cc" />
+          <path
+             inkscape:connector-curvature="0"
+             style="fill:none;stroke:#ffffff;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:0.20467828"
+             d="m 12.5,5.0205154 0,38.0177126"
+             id="path10676-7"
+             sodipodi:nodetypes="cc" />
+        </g>
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.13778631"
+           y="9"
+           x="15.999994"
+           height="1"
+           width="20.000006"
+           id="rect10680-0"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.010779859"
+           y="11"
+           x="15.999994"
+           height="1"
+           width="1.5647217"
+           id="rect10682-2"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.071673371"
+           y="13"
+           x="18.272837"
+           height="1"
+           width="10.403558"
+           id="rect10684-0"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.093421049"
+           y="15"
+           x="18.272837"
+           height="1"
+           width="13.560284"
+           id="rect10686-0"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.074283093"
+           y="17"
+           x="18.272837"
+           height="1"
+           width="10.782365"
+           id="rect10688-0"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.010779865"
+           y="19"
+           x="18.272837"
+           height="1"
+           width="1.5647227"
+           id="rect10690-4"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.041226614"
+           y="21"
+           x="20.166874"
+           height="1"
+           width="5.984139"
+           id="rect10692-0"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.031657632"
+           y="23"
+           x="18.146568"
+           height="1"
+           width="4.5951796"
+           id="rect10694-8"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.064613581"
+           y="25"
+           x="20.040596"
+           height="1"
+           width="9.3788128"
+           id="rect10696-1"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10730-1"
+           width="1.5501302"
+           height="1"
+           x="18.166864"
+           y="27"
+           rx="0.010679333"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10732-9"
+           width="1.5647217"
+           height="1"
+           x="15.999994"
+           y="29"
+           rx="0.010779859"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10734-9"
+           width="9.2671347"
+           height="1"
+           x="15.999994"
+           y="33"
+           rx="0.063844196"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10736-3"
+           width="1.5647217"
+           height="1"
+           x="15.999994"
+           y="35"
+           rx="0.010779859"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10738-9"
+           width="8.7620602"
+           height="1"
+           x="18.272837"
+           y="37"
+           rx="0.060364578"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#9b9b9b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10740-9"
+           width="10.277287"
+           height="1"
+           x="18.272837"
+           y="39"
+           rx="0.070803463"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#555753;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10742-1"
+           width="1.5647227"
+           height="1"
+           x="19.43354"
+           y="23"
+           rx="0.010779865"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.010779865"
+           y="16.928572"
+           x="18.272825"
+           height="1"
+           width="1.5647227"
+           id="rect10744-2"
+           style="color:#000000;fill:#555753;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#75507b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10746-6"
+           width="3.9754369"
+           height="1"
+           x="15.951397"
+           y="8.9821434"
+           rx="0.027388033"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.021236859"
+           y="13.000001"
+           x="18.272825"
+           height="1"
+           width="3.0825799"
+           id="rect10748-4"
+           style="color:#000000;fill:#75507b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#75507b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10750-7"
+           width="3.0825799"
+           height="1"
+           x="18.36211"
+           y="14.964287"
+           rx="0.021236859"
+           ry="0.065390877" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           ry="0.065390877"
+           rx="0.014470569"
+           y="33"
+           x="15.86211"
+           height="1"
+           width="2.1004369"
+           id="rect10752-9"
+           style="color:#000000;fill:#75507b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible" />
+        <rect
+           transform="translate(221.34207,203.5191)"
+           style="color:#000000;fill:#75507b;fill-opacity:0.54970757;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:block;overflow:visible"
+           id="rect10754-3"
+           width="2.1004369"
+           height="1"
+           x="18.272825"
+           y="36.92857"
+           rx="0.014470569"
+           ry="0.065390877" />
+        <text
+           xml:space="preserve"
+           style="font-size:22.49356079px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#2e3436;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+           x="247.85315"
+           y="242.62157"
+           id="text10726-2"
+           sodipodi:linespacing="125%"><tspan
+             sodipodi:role="line"
+             id="tspan10728-8"
+             x="247.85315"
+             y="242.62157">c</tspan></text>
+      </g>
+      <text
+         xml:space="preserve"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         x="339"
+         y="345.36218"
+         id="text13355"
+         sodipodi:linespacing="125%"><tspan
+           sodipodi:role="line"
+           id="tspan13357"
+           x="339"
+           y="345.36218">Nanopb library</tspan></text>
+    </g>
+    <g
+       id="g11071"
+       transform="translate(81.439632,-41.53157)">
+      <g
+         id="g12984">
+        <text
+           xml:space="preserve"
+           style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:center;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:middle;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+           x="193"
+           y="442.36218"
+           id="text10864"
+           sodipodi:linespacing="125%"><tspan
+             sodipodi:role="line"
+             id="tspan10866"
+             x="193"
+             y="442.36218">Protocol Buffers</tspan><tspan
+             sodipodi:role="line"
+             x="193"
+             y="457.36218"
+             id="tspan10868"
+             dy="-5">messages</tspan></text>
+        <g
+           transform="matrix(0.66229159,0,0,0.66229159,176.71024,408.41713)"
+           inkscape:label="Layer 1"
+           id="layer1-3">
+          <g
+             style="display:inline"
+             id="g5022"
+             transform="matrix(0.02312904,0,0,0.01485743,45.62082,30.57952)">
+            <rect
+               y="-150.69685"
+               x="-1559.2523"
+               height="478.35718"
+               width="1339.6335"
+               id="rect4173"
+               style="opacity:0.40206185;color:#000000;fill:url(#linearGradient5027);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible" />
+            <path
+               inkscape:connector-curvature="0"
+               sodipodi:nodetypes="cccc"
+               id="path5058"
+               d="m -219.61876,-150.68038 c 0,0 0,478.33079 0,478.33079 142.874166,0.90045 345.40022,-107.16966 345.40014,-239.196175 0,-132.026537 -159.436816,-239.134595 -345.40014,-239.134615 z"
+               style="opacity:0.40206185;color:#000000;fill:url(#radialGradient5029);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible" />
+            <path
+               inkscape:connector-curvature="0"
+               style="opacity:0.40206185;color:#000000;fill:url(#radialGradient5031);fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:1;marker:none;visibility:visible;display:inline;overflow:visible"
+               d="m -1559.2523,-150.68038 c 0,0 0,478.33079 0,478.33079 -142.8742,0.90045 -345.4002,-107.16966 -345.4002,-239.196175 0,-132.026537 159.4368,-239.134595 345.4002,-239.134615 z"
+               id="path5018"
+               sodipodi:nodetypes="cccc" />
+          </g>
+          <g
+             id="g2570"
+             transform="matrix(1.004727,0,0,1.006001,0.05456518,-9.119156)"
+             inkscape:r_cx="true"
+             inkscape:r_cy="true">
+            <path
+               inkscape:connector-curvature="0"
+               id="path12723"
+               d="m 6.34375,15.454879 0,25.987281 36.96875,0 L 43.25,15.554447 c -1.3e-5,-0.0057 3.74e-4,-0.02709 0,-0.03319 -7.31e-4,-0.0065 0.0011,-0.02633 0,-0.03319 -0.0014,-0.0072 -0.02946,-0.02558 -0.03125,-0.03319 l -36.875,0 z"
+               style="fill:url(#linearGradient1483);fill-opacity:1;fill-rule:evenodd;stroke:#888a85;stroke-width:1.50185335;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               sodipodi:nodetypes="ccccccc"
+               id="path1634"
+               d="M 20.490674,29.058712 7.09471,40.0307 l 13.908842,-9.604306 9.018158,0 12.419047,9.482193 -11.863425,-10.849875 -10.086658,0 z"
+               style="fill:url(#linearGradient1487);fill-opacity:1;fill-rule:evenodd;stroke:none"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               id="path15103"
+               d="m 7.34375,16.733862 c -0.0067,0.01334 0.00539,0.01964 0,0.03159 -0.00237,0.0056 -0.029214,0.02632 -0.03125,0.03159 -0.0017,0.0049 0.00137,0.02704 0,0.03159 -0.00103,0.0042 6.858e-4,0.02777 0,0.03159 l 0.03125,23.473418 34.9375,0 -0.0625,-23.347047 c -6.87e-4,-0.0037 10e-4,-0.02751 0,-0.03159 -0.01466,-0.04808 -0.04183,-0.132156 -0.09375,-0.221149 l -34.78125,0 z"
+               style="fill:none;stroke:#ffffff;stroke-width:1.50185323;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               id="path2563"
+               d="M 23.329298,32.996721 C 20.937189,32.550375 7.9003872,18.771125 6.5966059,16.372022 6.5816495,16.343448 6.5559705,16.288608 6.5446896,16.2636 l 34.5131134,0 c -0.277079,2.502804 -7.524227,16.505746 -9.561279,16.733121 -0.0082,4.68e-4 -0.02128,0 -0.02927,0 l -8.020859,0 c -0.03363,0 -0.07755,0.0074 -0.117094,0 z"
+               style="fill:url(#radialGradient1491);fill-opacity:1;fill-rule:evenodd;stroke:none"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               id="path1613"
+               d="M 20.77475,31.085394 C 18.407309,30.694257 7.945269,18.619435 7.1185841,16.517089 7.109327,16.49205 7.094677,16.443993 7.088438,16.422079 l 35.542207,0 c -0.823616,2.19322 -11.29845,14.464065 -13.445143,14.663315 -0.0085,4.09e-4 -0.02191,0 -0.03015,0 l -8.260021,0 c -0.03463,0 -0.08145,0.0065 -0.120584,0 z"
+               style="fill:url(#linearGradient1497);fill-opacity:1;fill-rule:evenodd;stroke:#989898;stroke-width:1.28649366;stroke-linecap:butt;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               id="path18153"
+               d="M 20.625174,30.490479 C 18.519211,29.999928 7.7224803,17.987711 7.0314243,16.466377 c -0.00254,-0.006 0.00218,-0.02669 0,-0.03231 -0.00545,-0.01576 -0.029096,-0.0523 -0.03125,-0.06463 2.87e-5,-0.0033 -4.061e-4,-0.02938 0,-0.03231 0.00117,-0.0021 0.029695,0.0017 0.03125,0 l 0.09375,-0.09694 35.4687497,0 c -0.0027,0.02433 -0.02268,0.06687 -0.03125,0.09694 -0.0075,0.0236 -0.02057,0.07023 -0.03125,0.09694 -0.922098,2.180937 -11.507988,13.766449 -13.34375,14.056416 -0.01493,0.0016 -0.04885,0 -0.0625,0 l -8.375,0 c -0.03029,-0.0017 -0.08975,0.0082 -0.125,0 z"
+               style="fill:url(#linearGradient1501);fill-opacity:1;fill-rule:evenodd;stroke:none"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               id="path1616"
+               d="M 20.875174,30.051141 C 18.427215,29.501671 8.7040003,18.433898 7.5314243,16.451725 l 34.5937497,0 c -1.490188,2.333171 -11.046672,13.411791 -13.15625,13.599416 -0.0087,4.02e-4 -0.02278,0 -0.03125,0 l -7.90625,0 c -0.02639,0 -0.06488,0.0036 -0.09375,0 -0.01979,-0.0031 -0.04165,0.0047 -0.0625,0 z"
+               style="fill:none;stroke:url(#linearGradient1503);stroke-width:1.2864933;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+            <path
+               inkscape:connector-curvature="0"
+               sodipodi:nodetypes="cccccc"
+               id="path1636"
+               d="m 20.959511,30.447113 -11.941499,8.270856 2.219433,0.0061 9.998125,-6.86894 8.821908,-1.422838 -9.097967,0.01482 z"
+               style="fill:url(#linearGradient1505);fill-opacity:1;fill-rule:evenodd;stroke:none"
+               inkscape:r_cx="true"
+               inkscape:r_cy="true" />
+          </g>
+        </g>
+      </g>
+    </g>
+    <g
+       id="g11055"
+       transform="translate(68.952442,-27.959635)">
+      <text
+         sodipodi:linespacing="125%"
+         id="text10870"
+         y="435.36218"
+         x="367.90341"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="435.36218"
+           x="367.90341"
+           id="tspan10872"
+           sodipodi:role="line">Data structures</tspan></text>
+      <g
+         transform="matrix(0.69596564,0,0,0.69596564,273.85443,81.742553)"
+         id="g10906">
+        <path
+           style="fill:none;stroke:#2e3436;stroke-width:1.43685257px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 180,479.36218 0,-3 4,0 0,-3"
+           id="path10902"
+           inkscape:connector-curvature="0"
+           sodipodi:nodetypes="cccc" />
+        <path
+           style="fill:none;stroke:#2e3436;stroke-width:1.43685257px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
+           d="m 206,479.36218 0,-3 -4,0 0,-3"
+           id="path10904"
+           inkscape:connector-curvature="0"
+           sodipodi:nodetypes="cccc" />
+        <g
+           id="g10880">
+          <rect
+             ry="0.040280778"
+             rx="0.010749566"
+             y="462.36218"
+             x="180"
+             height="11"
+             width="26"
+             id="rect10874"
+             style="color:#000000;fill:#729fcf;fill-opacity:1;fill-rule:nonzero;stroke:#204a87;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+          <rect
+             style="color:#000000;fill:#729fcf;fill-opacity:1;fill-rule:nonzero;stroke:#bdd2e9;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+             id="rect10876"
+             width="24"
+             height="9.0000305"
+             x="181"
+             y="463.36215"
+             rx="0.0099226767"
+             ry="0.032957111" />
+        </g>
+        <g
+           id="g10892"
+           transform="translate(8,-2)">
+          <rect
+             style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#4e9a06;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+             id="rect10886"
+             width="13"
+             height="10.999969"
+             x="166"
+             y="481.36221"
+             rx="0.0053747827"
+             ry="0.040280666" />
+          <rect
+             ry="0.032956999"
+             rx="0.004547894"
+             y="482.36218"
+             x="167"
+             height="9"
+             width="11"
+             id="rect10888"
+             style="color:#000000;fill:#8ae234;fill-opacity:1;fill-rule:nonzero;stroke:#caf2a4;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+        </g>
+        <g
+           transform="translate(33,-2)"
+           id="g10896">
+          <rect
+             ry="0.040280666"
+             rx="0.0053747827"
+             y="481.36221"
+             x="166"
+             height="10.999969"
+             width="13"
+             id="rect10898"
+             style="color:#000000;fill:#d3d7cf;fill-opacity:1;fill-rule:nonzero;stroke:#4e9a06;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+          <rect
+             style="color:#000000;fill:#8ae234;fill-opacity:1;fill-rule:nonzero;stroke:#caf2a4;stroke-width:1.43685257;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+             id="rect10900"
+             width="11"
+             height="9"
+             x="167"
+             y="482.36218"
+             rx="0.004547894"
+             ry="0.032956999" />
+        </g>
+      </g>
+    </g>
+    <g
+       id="g15531"
+       transform="translate(-16,0.55679368)">
+      <g
+         transform="matrix(0.79106547,0,0,0.79106547,463.64438,289.26048)"
+         id="g15500">
+        <g
+           inkscape:label="shadow"
+           id="layer2">
+          <path
+             transform="matrix(1.18638,0,0,1.18638,-4.539687,-7.794678)"
+             d="m 44.285715,38.714287 c 0,5.43296 -8.922325,9.837245 -19.928572,9.837245 -11.006246,0 -19.9285713,-4.404285 -19.9285713,-9.837245 0,-5.432961 8.9223253,-9.837245 19.9285713,-9.837245 11.006247,0 19.928572,4.404284 19.928572,9.837245 z"
+             sodipodi:ry="9.837245"
+             sodipodi:rx="19.928572"
+             sodipodi:cy="38.714287"
+             sodipodi:cx="24.357143"
+             id="path1538"
+             style="color:#000000;fill:url(#radialGradient15544);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.50000042;marker:none;visibility:visible;display:inline;overflow:visible"
+             sodipodi:type="arc" />
+        </g>
+        <g
+           id="layer1-4"
+           inkscape:label="Layer 1">
+          <path
+             inkscape:connector-curvature="0"
+             style="fill:url(#linearGradient15546);fill-rule:nonzero;stroke:#3f4561;stroke-width:1.26411784;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1"
+             d="M 24.285801,43.196358 4.3751874,23.285744 24.285801,3.3751291 44.196415,23.285744 24.285801,43.196358 l 0,0 z"
+             id="path53304" />
+          <path
+             inkscape:connector-curvature="0"
+             sodipodi:nodetypes="ccccccc"
+             style="opacity:0.72000002;fill:#ffffff;fill-rule:nonzero;stroke:none"
+             d="M 43.505062,23.285744 24.285801,4.0664819 5.0665401,23.285744 5.8476076,23.910676 24.45724,5.4825431 43.505256,23.285744 l -1.94e-4,0 z"
+             id="path53359" />
+          <path
+             inkscape:connector-curvature="0"
+             style="opacity:0.5;fill:#ffffff;fill-rule:nonzero;stroke:none"
+             d="m 8.9257729,27.145172 0.7384498,-1.024184 c 0.6367493,0.268492 1.3006183,0.485069 1.9861833,0.644885 l -0.0058,1.576858 c 0.427728,0.08834 0.86301,0.156136 1.304105,0.204371 l 0.481774,-1.501889 c 0.344041,0.02848 0.691764,0.04417 1.043361,0.04417 0.351209,0 0.699124,-0.0155 1.043166,-0.04417 l 0.481775,1.501889 c 0.441288,-0.04823 0.876376,-0.116036 1.304104,-0.204371 l -0.006,-1.577051 c 0.685758,-0.159623 1.349433,-0.3762 1.986182,-0.644692 l 0.92248,1.279502 c 0.402351,-0.182094 0.794241,-0.382591 1.174895,-0.600522 l -0.492817,-1.498016 c 0.59723,-0.36225 1.161723,-0.773319 1.687471,-1.227972 l 1.272141,0.931779 c 0.325638,-0.296581 0.637329,-0.608272 0.933716,-0.93391 l -0.931585,-1.271947 c 0.454847,-0.525748 0.865916,-1.090047 1.228166,-1.687665 l 1.498015,0.493011 C 26.79347,21.2244 26.994161,20.832316 27.175867,20.43016 l -1.279308,-0.922287 c 0.268492,-0.636749 0.485068,-1.300618 0.645079,-1.986376 l 1.576663,0.0058 c 0.08834,-0.427727 0.156137,-0.86301 0.204178,-1.304298 l -1.501695,-0.481774 c 0.02886,-0.343848 0.04417,-0.691764 0.04417,-1.043167 0,-0.351403 -0.01569,-0.699125 -0.04417,-1.043361 l 1.501695,-0.481774 C 28.274632,12.73184 28.206442,12.296751 28.118495,11.86883 l -1.577051,0.006 C 26.381627,11.189076 26.165051,10.525208 25.896753,9.8886539 L 27.176061,8.9663652 C 26.994354,8.5640139 26.79347,8.1721237 26.575926,7.7912754 L 25.077717,8.2842867 C 24.715466,7.6868623 24.304398,7.1225635 23.849744,6.5970095 L 24.78133,5.3248686 C 24.502958,5.0189892 24.210252,4.7268638 23.905922,4.4467488 L 5.0669275,23.285938 6.0738693,24.29288 6.3725811,24.074174 c 0.5257484,0.454653 1.0900465,0.865722 1.6874698,1.227972 l -0.2419526,0.735157 1.1080622,1.108062 -3.876e-4,-1.93e-4 z"
+             id="path53361" />
+          <path
+             inkscape:connector-curvature="0"
+             style="opacity:0.5;fill:#ffffff;fill-rule:nonzero;stroke:none"
+             d="m 28.448976,32.191116 c 0,-6.484682 4.233883,-11.979469 10.08724,-13.874023 l -2.226972,-2.227167 c -0.01685,0.007 -0.0339,0.01298 -0.05056,0.02015 L 36.077171,15.858244 34.665167,14.44624 c -0.463178,0.2189 -0.91667,0.45446 -1.359314,0.707648 l 0.694089,2.109193 c -0.841314,0.509669 -1.635748,1.08869 -2.375747,1.728732 l -1.79111,-1.311659 c -0.458721,0.41746 -0.897297,0.856036 -1.314564,1.314565 l 1.311465,1.790914 c -0.640041,0.740195 -1.218868,1.534628 -1.728731,2.375748 l -2.109387,-0.694089 c -0.306654,0.536403 -0.589093,1.088304 -0.844994,1.654732 l 1.801182,1.298293 c -0.377942,0.896329 -0.682852,1.831014 -0.907758,2.796501 l -2.219999,-0.0085 c -0.124172,0.602266 -0.219869,1.215188 -0.287476,1.836051 l 2.114423,0.678398 c -0.04029,0.484293 -0.06199,0.97401 -0.06199,1.46857 0,0.494753 0.0217,0.98447 0.06199,1.468763 l -2.114423,0.677816 c 0.06761,0.621251 0.163304,1.233979 0.28767,1.836245 l 2.219805,-0.0083 c 0.224906,0.965487 0.529816,1.900172 0.907758,2.796502 l -1.801182,1.298486 c 0.142382,0.31479 0.293869,0.624931 0.452136,0.930423 l 3.804023,-3.803636 c -0.61602,-1.614245 -0.95425,-3.365836 -0.95425,-5.196269 l 1.93e-4,-1.94e-4 z"
+             id="path53363" />
+          <path
+             inkscape:connector-curvature="0"
+             sodipodi:nodetypes="ccccccc"
+             style="opacity:0.35;fill:#000000;fill-rule:nonzero;stroke:none"
+             d="M 5.2050478,23.424252 24.285801,42.505005 43.505062,23.285744 42.789963,22.603525 24.310314,41.041677 5.2050478,23.424059 l 0,1.93e-4 z"
+             id="path53365" />
+        </g>
+      </g>
+      <text
+         sodipodi:linespacing="125%"
+         id="text13355-1"
+         y="337.36218"
+         x="440"
+         style="font-size:12px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+         xml:space="preserve"><tspan
+           y="337.36218"
+           x="440"
+           id="tspan13357-7"
+           sodipodi:role="line">User application</tspan></text>
+    </g>
+  </g>
+</svg>
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/index.rst
@@ -0,0 +1,127 @@
+=============================================
+Nanopb: Protocol Buffers with small code size
+=============================================
+
+.. include :: menu.rst
+
+Nanopb is an ANSI-C library for encoding and decoding messages in Google's `Protocol Buffers`__ format with minimal requirements for RAM and code space.
+It is primarily suitable for 32-bit microcontrollers.
+
+__ http://code.google.com/apis/protocolbuffers/
+
+Overall structure
+=================
+
+For the runtime program, you always need *pb.h* for type declarations.
+Depending on whether you want to encode, decode, or both, you also need *pb_encode.h/c* or *pb_decode.h/c*.
+
+The high-level encoding and decoding functions take an array of *pb_field_t* structures, which describes the fields of a message structure. Usually you want these autogenerated from a *.proto* file. The tool script *nanopb_generator.py* accomplishes this.
+
+.. image:: generator_flow.png
+
+So a typical project might include these files:
+
+1) Nanopb runtime library:
+    - pb.h
+    - pb_common.h and pb_common.c (always needed)
+    - pb_decode.h and pb_decode.c (needed for decoding messages)
+    - pb_encode.h and pb_encode.c (needed for encoding messages)
+2) Protocol description (you can have many):
+    - person.proto (just an example)
+    - person.pb.c (autogenerated, contains initializers for const arrays)
+    - person.pb.h (autogenerated, contains type declarations)
+
+Features and limitations
+========================
+
+**Features**
+
+#) Pure C runtime
+#) Small code size (210 kB depending on processor, plus any message definitions)
+#) Small ram usage (typically ~300 bytes, plus any message structs)
+#) Allows specifying maximum size for strings and arrays, so that they can be allocated statically.
+#) No malloc needed: everything can be allocated statically or on the stack. Optional malloc support available.
+#) You can use either encoder or decoder alone to cut the code size in half.
+#) Support for most protobuf features, including: all data types, nested submessages, default values, repeated and optional fields, oneofs, packed arrays, extension fields.
+#) Callback mechanism for handling messages larger than can fit in available RAM.
+#) Extensive set of tests.
+
+**Limitations**
+
+#) Some speed has been sacrificed for code size.
+#) Encoding is focused on writing to streams. For memory buffers only it could be made more efficient.
+#) The deprecated Protocol Buffers feature called "groups" is not supported.
+#) Fields in the generated structs are ordered by the tag number, instead of the natural ordering in .proto file.
+#) Unknown fields are not preserved when decoding and re-encoding a message.
+#) Reflection (runtime introspection) is not supported. E.g. you can't request a field by giving its name in a string.
+#) Numeric arrays are always encoded as packed, even if not marked as packed in .proto..
+#) Cyclic references between messages are supported only in callback and malloc mode.
+
+Getting started
+===============
+
+For starters, consider this simple message::
+
+ message Example {
+    required int32 value = 1;
+ }
+
+Save this in *message.proto* and compile it::
+
+    user@host:~$ protoc -omessage.pb message.proto
+    user@host:~$ python nanopb/generator/nanopb_generator.py message.pb
+
+You should now have in *message.pb.h*::
+
+ typedef struct {
+    int32_t value;
+ } Example;
+ 
+ extern const pb_field_t Example_fields[2];
+
+Now in your main program do this to encode a message::
+
+ Example mymessage = {42};
+ uint8_t buffer[10];
+ pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+ pb_encode(&stream, Example_fields, &mymessage);
+
+After that, buffer will contain the encoded message.
+The number of bytes in the message is stored in *stream.bytes_written*.
+You can feed the message to *protoc --decode=Example message.proto* to verify its validity.
+
+For a complete example of the simple case, see *example/simple.c*.
+For a more complex example with network interface, see the *example/network_server* subdirectory.
+
+Compiler requirements
+=====================
+Nanopb should compile with most ansi-C compatible compilers. It however
+requires a few header files to be available:
+
+#) *string.h*, with these functions: *strlen*, *memcpy*, *memset*
+#) *stdint.h*, for definitions of *int32_t* etc.
+#) *stddef.h*, for definition of *size_t*
+#) *stdbool.h*, for definition of *bool*
+
+If these header files do not come with your compiler, you can use the
+file *extra/pb_syshdr.h* instead. It contains an example of how to provide
+the dependencies. You may have to edit it a bit to suit your custom platform.
+
+To use the pb_syshdr.h, define *PB_SYSTEM_HEADER* as *"pb_syshdr.h"* (including the quotes).
+Similarly, you can provide a custom include file, which should provide all the dependencies
+listed above.
+
+Running the test cases
+======================
+Extensive unittests and test cases are included under the *tests* folder.
+
+To build the tests, you will need the `scons`__ build system. The tests should
+be runnable on most platforms. Windows and Linux builds are regularly tested.
+
+__ http://www.scons.org/
+
+In addition to the build system, you will also need a working Google Protocol
+Buffers *protoc* compiler, and the Python bindings for Protocol Buffers. On
+Debian-based systems, install the following packages: *protobuf-compiler*,
+*python-protobuf* and *libprotobuf-dev*.
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/logo/logo.svg
@@ -0,0 +1,1470 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:dc="http://purl.org/dc/elements/1.1/"
+   xmlns:cc="http://creativecommons.org/ns#"
+   xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
+   xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
+   width="48"
+   height="48"
+   id="svg1901"
+   sodipodi:version="0.32"
+   inkscape:version="0.48.2 r9819"
+   sodipodi:docname="logo.svg"
+   version="1.1"
+   inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/logo.png"
+   inkscape:export-xdpi="90"
+   inkscape:export-ydpi="90">
+  <sodipodi:namedview
+     id="base"
+     pagecolor="#ffffff"
+     bordercolor="#666666"
+     borderopacity="1.0"
+     inkscape:pageopacity="0.0"
+     inkscape:pageshadow="2"
+     inkscape:zoom="7.9195959"
+     inkscape:cx="22.374283"
+     inkscape:cy="25.474909"
+     inkscape:document-units="px"
+     inkscape:current-layer="layer1"
+     inkscape:window-width="1280"
+     inkscape:window-height="753"
+     inkscape:window-x="0"
+     inkscape:window-y="26"
+     showgrid="false"
+     inkscape:window-maximized="1"
+     showguides="true"
+     inkscape:guide-bbox="true"
+     inkscape:snap-nodes="false"
+     inkscape:snap-global="false">
+    <inkscape:grid
+       type="xygrid"
+       id="grid4748"
+       empspacing="5"
+       visible="true"
+       enabled="true"
+       snapvisiblegridlinesonly="true" />
+  </sodipodi:namedview>
+  <defs
+     id="defs1903">
+    <linearGradient
+       id="linearGradient4822">
+      <stop
+         id="stop4824"
+         offset="0"
+         style="stop-color:#000000;stop-opacity:1;" />
+      <stop
+         id="stop4826"
+         offset="1"
+         style="stop-color:#000000;stop-opacity:0;" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4810">
+      <stop
+         style="stop-color:#747474;stop-opacity:0.40000001"
+         offset="0"
+         id="stop4812" />
+      <stop
+         style="stop-color:#747474;stop-opacity:0;"
+         offset="1"
+         id="stop4814" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4768">
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="0"
+         id="stop4770" />
+      <stop
+         style="stop-color:#000000;stop-opacity:0;"
+         offset="1"
+         id="stop4772" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4758">
+      <stop
+         style="stop-color:#2c2c2c;stop-opacity:1;"
+         offset="0"
+         id="stop4760" />
+      <stop
+         id="stop4762"
+         offset="1"
+         style="stop-color:#000000;stop-opacity:1;" />
+    </linearGradient>
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4342">
+      <stop
+         style="stop-color:#0c0c0c;stop-opacity:1"
+         offset="0"
+         id="stop4344" />
+      <stop
+         style="stop-color:#212121;stop-opacity:0;"
+         offset="1"
+         id="stop4346" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4294">
+      <stop
+         style="stop-color:#ababab;stop-opacity:1;"
+         offset="0"
+         id="stop4296" />
+      <stop
+         id="stop4298"
+         offset="1"
+         style="stop-color:#454545;stop-opacity:1;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4250">
+      <stop
+         style="stop-color:#4b4b4b;stop-opacity:1;"
+         offset="0"
+         id="stop4252" />
+      <stop
+         style="stop-color:#353535;stop-opacity:1;"
+         offset="1"
+         id="stop4254" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4206">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4208" />
+      <stop
+         style="stop-color:#525252;stop-opacity:1;"
+         offset="1"
+         id="stop4210" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4196">
+      <stop
+         style="stop-color:#ffffff;stop-opacity:1;"
+         offset="0"
+         id="stop4198" />
+      <stop
+         id="stop4200"
+         offset="1"
+         style="stop-color:#a4a4a4;stop-opacity:1;" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4128">
+      <stop
+         style="stop-color:#101010;stop-opacity:1;"
+         offset="0"
+         id="stop4130" />
+      <stop
+         style="stop-color:#101010;stop-opacity:0;"
+         offset="1"
+         id="stop4132" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient4098">
+      <stop
+         id="stop4106"
+         offset="0"
+         style="stop-color:#393939;stop-opacity:1;" />
+      <stop
+         style="stop-color:#000000;stop-opacity:1;"
+         offset="1"
+         id="stop4102" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3927">
+      <stop
+         style="stop-color:#424242;stop-opacity:0;"
+         offset="0"
+         id="stop3929" />
+      <stop
+         style="stop-color:#424242;stop-opacity:1;"
+         offset="1"
+         id="stop3931" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3855">
+      <stop
+         style="stop-color:#666666;stop-opacity:1;"
+         offset="0"
+         id="stop3857" />
+      <stop
+         style="stop-color:#666666;stop-opacity:1;"
+         offset="1"
+         id="stop3859" />
+    </linearGradient>
+    <filter
+       inkscape:collect="always"
+       id="filter3937"
+       x="-0.12812556"
+       width="1.2562511"
+       y="-0.16742191"
+       height="1.3348438"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="6.9443171"
+         id="feGaussianBlur3939" />
+    </filter>
+    <mask
+       maskUnits="userSpaceOnUse"
+       id="mask3953">
+      <path
+         sodipodi:type="arc"
+         style="color:#000000;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+         id="path3955"
+         sodipodi:cx="352.14285"
+         sodipodi:cy="623.07648"
+         sodipodi:rx="40.714287"
+         sodipodi:ry="40.714287"
+         d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+         transform="matrix(1.7543859,0,0,1.7543859,-339.22305,-467.89728)" />
+    </mask>
+    <filter
+       inkscape:collect="always"
+       id="filter3979"
+       x="-0.3823055"
+       width="1.764611"
+       y="-0.47600195"
+       height="1.952004"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="9.0109491"
+         id="feGaussianBlur3981" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4049"
+       x="-0.16508646"
+       width="1.3301729"
+       y="-0.2055463"
+       height="1.4110926"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="3.8910917"
+         id="feGaussianBlur4051" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4077"
+       x="-0.10677131"
+       width="1.2135426"
+       y="-0.13951825"
+       height="1.2790365"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="5.7869309"
+         id="feGaussianBlur4079" />
+    </filter>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4098"
+       id="radialGradient4108"
+       cx="141.30658"
+       cy="537.61609"
+       fx="141.30658"
+       fy="537.61609"
+       r="62.941189"
+       gradientTransform="matrix(0.25806011,0.29422394,-0.03785018,0.03319792,-54.888524,963.70096)"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4098"
+       id="radialGradient4116"
+       cx="241.51366"
+       cy="562.11151"
+       fx="241.51366"
+       fy="562.11151"
+       r="61.588345"
+       gradientTransform="matrix(0.23965697,0.20183681,-0.0408911,0.04855325,-57.403613,954.12796)"
+       gradientUnits="userSpaceOnUse" />
+    <filter
+       inkscape:collect="always"
+       id="filter4124"
+       x="-0.13548391"
+       width="1.2709678"
+       y="-0.13548385"
+       height="1.2709677"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="1.5681804"
+         id="feGaussianBlur4126" />
+    </filter>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128"
+       id="linearGradient4134"
+       x1="223.01562"
+       y1="596.02582"
+       x2="249.23067"
+       y2="615.72375"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4196"
+       id="radialGradient4166"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.21059566,0.18185717,-0.04148798,0.04804422,-52.42241,1007.9653)"
+       cx="241.51366"
+       cy="562.11151"
+       fx="241.51366"
+       fy="562.11151"
+       r="61.588345" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128"
+       id="linearGradient4168"
+       gradientUnits="userSpaceOnUse"
+       x1="223.01562"
+       y1="596.02582"
+       x2="244.1799"
+       y2="609.66284"
+       gradientTransform="translate(-15.152288,311.12698)" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4196"
+       id="radialGradient4170"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.21753099,0.27226679,-0.05516349,0.04407357,-42.593175,1009.5278)"
+       cx="133.18637"
+       cy="535.45135"
+       fx="133.18637"
+       fy="535.45135"
+       r="62.941189" />
+    <filter
+       inkscape:collect="always"
+       id="filter4172"
+       x="-0.19549713"
+       width="1.3909943"
+       y="-0.2434101"
+       height="1.4868202"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="4.6078717"
+         id="feGaussianBlur4174" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4192"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="1.2830565"
+         id="feGaussianBlur4194" />
+    </filter>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128"
+       id="linearGradient4204"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(-125.50943,203.26983)"
+       x1="223.01562"
+       y1="596.02582"
+       x2="247.3942"
+       y2="621.80566" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4294"
+       id="radialGradient4288"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.23965697,0.20183681,-0.0408911,0.04855325,-56.508695,902.22267)"
+       cx="241.51366"
+       cy="562.11151"
+       fx="241.51366"
+       fy="562.11151"
+       r="61.588345" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128"
+       id="linearGradient4290"
+       gradientUnits="userSpaceOnUse"
+       x1="223.01562"
+       y1="596.02582"
+       x2="249.23067"
+       y2="615.72375"
+       gradientTransform="translate(5.7142857,-331.42857)" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4294"
+       id="radialGradient4292"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.25806011,0.29422394,-0.03785018,0.03319792,-53.993604,911.79568)"
+       cx="141.30658"
+       cy="537.61609"
+       fx="141.30658"
+       fy="537.61609"
+       r="62.941189" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128-1"
+       id="linearGradient4204-3"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(-125.50943,203.26983)"
+       x1="223.01562"
+       y1="596.02582"
+       x2="247.3942"
+       y2="621.80566" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4128-1">
+      <stop
+         style="stop-color:#101010;stop-opacity:1;"
+         offset="0"
+         id="stop4130-9" />
+      <stop
+         style="stop-color:#101010;stop-opacity:0;"
+         offset="1"
+         id="stop4132-6" />
+    </linearGradient>
+    <filter
+       color-interpolation-filters="sRGB"
+       inkscape:collect="always"
+       id="filter4192-5">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="1.2830565"
+         id="feGaussianBlur4194-3" />
+    </filter>
+    <linearGradient
+       y2="623.88721"
+       x2="257.00116"
+       y1="588.95477"
+       x1="214.42932"
+       gradientTransform="translate(-103.05154,-435.68082)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient4317"
+       xlink:href="#linearGradient4128-1"
+       inkscape:collect="always" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4342"
+       id="linearGradient4348"
+       x1="199.86082"
+       y1="194.70784"
+       x2="205.35472"
+       y2="200.26366"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.15661078,0,0,0.15661078,-60.981634,940.60962)" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4758"
+       id="radialGradient4380"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.22197967,0.2098482,-0.03289985,0.03480181,-3.6600532,960.31534)"
+       cx="233.06406"
+       cy="558.55359"
+       fx="233.06406"
+       fy="558.55359"
+       r="61.588345" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128"
+       id="linearGradient4382"
+       gradientUnits="userSpaceOnUse"
+       x1="223.01562"
+       y1="596.02582"
+       x2="244.66977"
+       y2="621.13983"
+       gradientTransform="translate(353.55339,-2.0203051)" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4098"
+       id="radialGradient4384"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.26804686,0.27059786,-0.03479311,0.03446511,-3.4683138,966.86956)"
+       cx="141.30658"
+       cy="537.61609"
+       fx="141.30658"
+       fy="537.61609"
+       r="62.941189" />
+    <linearGradient
+       y2="623.88721"
+       x2="257.00116"
+       y1="588.95477"
+       x1="214.42932"
+       gradientTransform="translate(-103.05154,-435.68082)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient4317-7"
+       xlink:href="#linearGradient4128-1-3"
+       inkscape:collect="always" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4128-1-3">
+      <stop
+         style="stop-color:#101010;stop-opacity:1;"
+         offset="0"
+         id="stop4130-9-1" />
+      <stop
+         style="stop-color:#101010;stop-opacity:0;"
+         offset="1"
+         id="stop4132-6-8" />
+    </linearGradient>
+    <filter
+       color-interpolation-filters="sRGB"
+       inkscape:collect="always"
+       id="filter4192-5-8">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="1.2830565"
+         id="feGaussianBlur4194-3-2" />
+    </filter>
+    <linearGradient
+       y2="623.88721"
+       x2="257.00116"
+       y1="588.95477"
+       x1="214.42932"
+       gradientTransform="translate(243.90853,-108.62729)"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient4403"
+       xlink:href="#linearGradient4128-1-3"
+       inkscape:collect="always" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4342-4"
+       id="linearGradient4348-2"
+       x1="199.86082"
+       y1="194.70784"
+       x2="205.35472"
+       y2="200.26366"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       id="linearGradient4342-4">
+      <stop
+         style="stop-color:#0c0c0c;stop-opacity:1"
+         offset="0"
+         id="stop4344-9" />
+      <stop
+         style="stop-color:#212121;stop-opacity:0;"
+         offset="1"
+         id="stop4346-4" />
+    </linearGradient>
+    <linearGradient
+       gradientTransform="matrix(0.15234083,0,0,0.15234083,-7.1415876,993.54015)"
+       y2="213.52541"
+       x2="223.58961"
+       y1="207.96959"
+       x1="218.92458"
+       gradientUnits="userSpaceOnUse"
+       id="linearGradient4441"
+       xlink:href="#linearGradient4342-4"
+       inkscape:collect="always" />
+    <filter
+       inkscape:collect="always"
+       id="filter4480"
+       x="-0.18364665"
+       width="1.3672934"
+       y="-0.23997138"
+       height="1.4799428"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="9.9535211"
+         id="feGaussianBlur4482" />
+    </filter>
+    <clipPath
+       clipPathUnits="userSpaceOnUse"
+       id="clipPath4507">
+      <path
+         transform="matrix(1.7543859,0,0,1.7543859,-354.37534,-156.7703)"
+         d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+         sodipodi:ry="40.714287"
+         sodipodi:rx="40.714287"
+         sodipodi:cy="623.07648"
+         sodipodi:cx="352.14285"
+         id="path4509"
+         style="color:#000000;fill:#ededed;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+         sodipodi:type="arc" />
+    </clipPath>
+    <clipPath
+       clipPathUnits="userSpaceOnUse"
+       id="clipPath4507-9">
+      <path
+         transform="matrix(1.7543859,0,0,1.7543859,-354.37534,-156.7703)"
+         d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+         sodipodi:ry="40.714287"
+         sodipodi:rx="40.714287"
+         sodipodi:cy="623.07648"
+         sodipodi:cx="352.14285"
+         id="path4509-8"
+         style="color:#000000;fill:#ededed;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+         sodipodi:type="arc" />
+    </clipPath>
+    <filter
+       color-interpolation-filters="sRGB"
+       inkscape:collect="always"
+       id="filter4501-0">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="3.929404"
+         id="feGaussianBlur4503-0" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4547"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="6.0452369"
+         id="feGaussianBlur4549" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4571"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="1.1115556"
+         id="feGaussianBlur4573" />
+    </filter>
+    <clipPath
+       clipPathUnits="userSpaceOnUse"
+       id="clipPath4507-9-7">
+      <path
+         transform="matrix(1.7543859,0,0,1.7543859,-354.37534,-156.7703)"
+         d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+         sodipodi:ry="40.714287"
+         sodipodi:rx="40.714287"
+         sodipodi:cy="623.07648"
+         sodipodi:cx="352.14285"
+         id="path4509-8-1"
+         style="color:#000000;fill:#ededed;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+         sodipodi:type="arc" />
+    </clipPath>
+    <filter
+       inkscape:collect="always"
+       id="filter4625"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="4.5339277"
+         id="feGaussianBlur4627" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4641"
+       x="-0.3823055"
+       width="1.764611"
+       y="-0.47600195"
+       height="1.952004"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="9.0109492"
+         id="feGaussianBlur4643" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4649"
+       x="-0.57345825"
+       width="2.1469164"
+       y="-0.71400291"
+       height="2.4280059"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="13.516424"
+         id="feGaussianBlur4651" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4661"
+       x="-0.23191024"
+       width="1.4638205"
+       y="-0.23260693"
+       height="1.4652139"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="12.425148"
+         id="feGaussianBlur4663" />
+    </filter>
+    <filter
+       inkscape:collect="always"
+       id="filter4738"
+       color-interpolation-filters="sRGB">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="0.13338853"
+         id="feGaussianBlur4740" />
+    </filter>
+    <clipPath
+       clipPathUnits="userSpaceOnUse"
+       id="clipPath4744">
+      <path
+         transform="matrix(0.08521814,0,0,0.08591999,4.0670251,-20.374151)"
+         d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+         sodipodi:ry="40.714287"
+         sodipodi:rx="40.714287"
+         sodipodi:cy="623.07648"
+         sodipodi:cx="352.14285"
+         id="path4746"
+         style="color:#000000;fill:#2c2c2c;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+         sodipodi:type="arc" />
+    </clipPath>
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4128"
+       id="linearGradient4750"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(-15.152288,311.12698)"
+       x1="223.01562"
+       y1="596.02582"
+       x2="244.1799"
+       y2="609.66284" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4768"
+       id="linearGradient4774"
+       x1="-8.5135946"
+       y1="1040.8162"
+       x2="-36.138241"
+       y2="1040.5483"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.61534323,0,0,0.61534326,14.59514,0.04606772)" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4768"
+       id="linearGradient4776"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(0.61534323,0,0,0.61534326,14.59514,0.04606772)"
+       x1="-22.697203"
+       y1="1040.3197"
+       x2="-39.949551"
+       y2="1039.9578" />
+    <filter
+       inkscape:collect="always"
+       id="filter4794"
+       x="-0.029811953"
+       width="1.0596239"
+       y="-0.1456968"
+       height="1.2913936">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="0.18351365"
+         id="feGaussianBlur4796" />
+    </filter>
+    <clipPath
+       clipPathUnits="userSpaceOnUse"
+       id="clipPath4804">
+      <path
+         transform="matrix(0.08147906,-0.06254913,0.06129679,0.08116836,-38.523905,-0.095885)"
+         sodipodi:type="arc"
+         style="color:#000000;fill:#2e2e2e;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:4.45699024;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+         id="path4806"
+         sodipodi:cx="352.14285"
+         sodipodi:cy="623.07648"
+         sodipodi:rx="40.714287"
+         sodipodi:ry="40.714287"
+         d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z" />
+    </clipPath>
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4810"
+       id="radialGradient4816"
+       cx="10.46172"
+       cy="1017.2507"
+       fx="10.46172"
+       fy="1017.2507"
+       r="9.5885149"
+       gradientTransform="matrix(0.19619751,-0.12064592,0.46999446,0.76431711,-469.23407,241.69554)"
+       gradientUnits="userSpaceOnUse" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient4822"
+       id="linearGradient4820"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="translate(353.55339,-2.0203051)"
+       x1="215.9617"
+       y1="586.76971"
+       x2="253.67445"
+       y2="578.57703" />
+    <filter
+       inkscape:collect="always"
+       id="filter4914"
+       x="-0.061783516"
+       width="1.123567"
+       y="-0.10365072"
+       height="1.2073014">
+      <feGaussianBlur
+         inkscape:collect="always"
+         stdDeviation="0.77641645"
+         id="feGaussianBlur4916" />
+    </filter>
+  </defs>
+  <metadata
+     id="metadata1906">
+    <rdf:RDF>
+      <cc:Work
+         rdf:about="">
+        <dc:format>image/svg+xml</dc:format>
+        <dc:type
+           rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
+        <dc:title></dc:title>
+      </cc:Work>
+    </rdf:RDF>
+  </metadata>
+  <g
+     id="layer1"
+     inkscape:groupmode="layer"
+     inkscape:label="Taso 1"
+     transform="translate(0,-1004.3622)">
+    <text
+       sodipodi:linespacing="125%"
+       id="text3796"
+       y="609.03595"
+       x="-131.45427"
+       style="font-size:41.48686981px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:FreeSans;-inkscape-font-specification:FreeSans"
+       xml:space="preserve"><tspan
+         y="609.03595"
+         x="-131.45427"
+         id="tspan3798"
+         sodipodi:role="line" /></text>
+    <path
+       style="color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4547);enable-background:accumulate"
+       d="m 263.40625,861.375 c -41.40153,0 -74.9375,33.56722 -74.9375,74.96875 0,41.40153 33.53597,74.96875 74.9375,74.96875 41.40153,0 74.96875,-33.56722 74.96875,-74.96875 0,-41.40153 -33.56722,-74.96875 -74.96875,-74.96875 z m 0,3.53125 c 39.44891,0 71.4375,31.98859 71.4375,71.4375 0,39.44891 -31.98859,71.43745 -71.4375,71.43745 -39.44891,0 -71.40625,-31.98854 -71.40625,-71.43745 0,-39.44891 31.95734,-71.4375 71.40625,-71.4375 z"
+       id="path4494"
+       clip-path="url(#clipPath4507)"
+       inkscape:connector-curvature="0"
+       transform="matrix(0.15234083,0,0,0.15234083,-3.588174,896.00387)"
+       inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/text4764.png"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806" />
+    <path
+       sodipodi:nodetypes="sssss"
+       inkscape:connector-curvature="0"
+       id="path4350"
+       d="m 19.002637,1019.1304 c 2.257937,0.8279 11.784525,9.0752 16.335834,13.3706 1.356388,1.2801 -0.01672,2.5743 -1.251365,1.5234 -4.260991,-3.6267 -10.985076,-9.7625 -16.172619,-13.561 -1.673691,-1.2256 -0.341266,-1.8571 1.08815,-1.333 z"
+       style="color:#000000;fill:url(#radialGradient4380);fill-opacity:1.0;stroke:none;stroke-width:0.35433071999999999;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+    <path
+       style="opacity:0.35655738999999997;color:#000000;fill:url(#linearGradient4441);fill-opacity:1;stroke:none;stroke-width:0.35433071999999999;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       d="m 18.632723,1018.8098 c 2.257926,0.8278 11.784523,9.0751 16.335833,13.3706 1.356387,1.2801 -0.01672,2.5742 -1.251366,1.5234 -4.260991,-3.6269 -10.985075,-9.7625 -16.172619,-13.5611 -1.673691,-1.2256 -0.341265,-1.8571 1.088152,-1.3329 z"
+       id="path4340-7"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sssss" />
+    <path
+       d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+       sodipodi:ry="40.714287"
+       sodipodi:rx="40.714287"
+       sodipodi:cy="623.07648"
+       sodipodi:cx="352.14285"
+       id="path4352"
+       style="color:#000000;fill:#2e2e2e;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:4.45699024;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       sodipodi:type="arc"
+       transform="matrix(0.21247535,0,0,0.21247535,-61.734636,883.97609)" />
+    <path
+       sodipodi:type="arc"
+       style="color:#000000;fill:#2c2c2c;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       id="path4354"
+       sodipodi:cx="352.14285"
+       sodipodi:cy="623.07648"
+       sodipodi:rx="40.714287"
+       sodipodi:ry="40.714287"
+       d="m 392.85714,623.07648 a 40.714287,40.714287 0 1 1 -81.42857,0 40.714287,40.714287 0 1 1 81.42857,0 z"
+       transform="matrix(0.2672646,0,0,0.2672646,-57.578671,872.09085)"
+       inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/text4764.png"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806" />
+    <g
+       id="g4752"
+       transform="matrix(0.99202587,0,0,0.92871672,0.27451699,74.105593)"
+       inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/text4764.png"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806">
+      <text
+         transform="matrix(0.15234083,0,0,0.15234083,-59.761767,943.67847)"
+         sodipodi:linespacing="125%"
+         id="text4551"
+         y="646.5647"
+         x="593.79944"
+         style="font-size:72px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;filter:url(#filter4571);font-family:FreeSerif;-inkscape-font-specification:FreeSerif"
+         xml:space="preserve"><tspan
+           y="646.5647"
+           x="593.79944"
+           id="tspan4553"
+           sodipodi:role="line">Pb</tspan></text>
+      <text
+         xml:space="preserve"
+         style="font-size:10.96853924px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#eeeeee;fill-opacity:1;stroke:none;font-family:FreeSerif;-inkscape-font-specification:FreeSerif"
+         x="30.829479"
+         y="1042.3079"
+         id="text4376"
+         sodipodi:linespacing="125%"><tspan
+           sodipodi:role="line"
+           id="tspan4378"
+           x="30.829479"
+           y="1042.3079">Pb</tspan></text>
+    </g>
+    <g
+       id="g4356"
+       transform="matrix(0.15234083,0,0,0.15234083,-5.9011556,943.3707)"
+       style="opacity:1">
+      <path
+         sodipodi:type="arc"
+         style="opacity:0.35245900000000002;color:#000000;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707000000000;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4641);enable-background:accumulate"
+         id="path4358"
+         sodipodi:cx="63.57143"
+         sodipodi:cy="683.07648"
+         sodipodi:rx="32.142857"
+         sodipodi:ry="15"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         transform="matrix(0.83309894,-0.60922647,0.70597542,0.69306694,-284.83936,153.03103)" />
+      <path
+         style="color:#000000;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.35433071999999999;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4480);enable-background:accumulate"
+         d="m 219.28571,665.21933 c 66.78572,27.14286 107.85715,-14.28572 124.28572,-68.57143 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         id="path4360"
+         inkscape:connector-curvature="0"
+         sodipodi:nodetypes="ccc"
+         mask="url(#mask3953)" />
+    </g>
+    <path
+       sodipodi:nodetypes="ccccc"
+       inkscape:connector-curvature="0"
+       id="path4362"
+       d="m 570.23111,600.31891 10.60661,-12.6269 30.68927,36.94111 -10.8017,9.82617 z"
+       style="color:#000000;fill:url(#linearGradient4382);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4124);enable-background:accumulate"
+       transform="matrix(0.15234083,0,0,0.15234083,-59.761767,943.67847)"
+       inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/text4764.png"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806" />
+    <path
+       style="color:#000000;fill:url(#linearGradient4403);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4192-5-8);enable-background:accumulate"
+       d="m 459.07101,491.18655 10.6679,-13.40246 39.92639,39.30492 -7.75997,7.26977 z"
+       id="path4202-2-0"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc"
+       transform="matrix(0.15234083,0,0,0.15234083,-59.761767,943.67847)" />
+    <path
+       clip-path="url(#clipPath4804)"
+       transform="matrix(1.6507431,1.2720788,-1.2466097,1.657062,1.7389029,933.14042)"
+       d="m 32.393744,29.196428 a 1.3223162,2.5735531 0 1 1 -2.644632,0 1.3223162,2.5735531 0 1 1 2.644632,0 z"
+       sodipodi:ry="2.5735531"
+       sodipodi:rx="1.3223162"
+       sodipodi:cy="29.196428"
+       sodipodi:cx="31.071428"
+       id="path4798"
+       style="opacity:0.45081967;color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:6.21632814;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4738);enable-background:accumulate"
+       sodipodi:type="arc" />
+    <g
+       style="opacity:0.98000004;fill:#333333"
+       transform="matrix(0.12043176,0,0,0.12043176,-20.43703,941.11723)"
+       id="g4364">
+      <path
+         transform="matrix(0.68865217,-0.50491892,0.58356994,0.5744048,-198.94895,219.24158)"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         sodipodi:ry="15"
+         sodipodi:rx="32.142857"
+         sodipodi:cy="683.07648"
+         sodipodi:cx="63.57143"
+         id="path4366"
+         style="opacity:0.31557378;color:#000000;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4649);enable-background:accumulate"
+         sodipodi:type="arc" />
+      <path
+         mask="url(#mask3953)"
+         sodipodi:nodetypes="ccc"
+         inkscape:connector-curvature="0"
+         id="path4368"
+         d="m 218.26583,662.15968 c 84.07219,31.02539 107.45764,-22.43928 116.12665,-82.8498 47.44111,99.17711 -51.34018,183.44447 -116.12665,82.8498 z"
+         style="color:#000000;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4661);enable-background:accumulate" />
+    </g>
+    <path
+       clip-path="url(#clipPath4507-9-7)"
+       id="path4665"
+       d="m 263.40625,861.375 c -41.40153,0 -74.9375,33.56722 -74.9375,74.96875 0,41.40153 33.53597,74.96875 74.9375,74.96875 41.40153,0 74.96875,-33.56722 74.96875,-74.96875 0,-41.40153 -33.56722,-74.96875 -74.96875,-74.96875 z m 0,3.53125 c 39.44891,0 71.4375,31.98859 71.4375,71.4375 0,39.44891 -31.98859,71.43745 -71.4375,71.43745 -39.44891,0 -71.40625,-31.98854 -71.40625,-71.43745 0,-39.44891 31.95734,-71.4375 71.40625,-71.4375 z"
+       style="color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4625);enable-background:accumulate"
+       inkscape:connector-curvature="0"
+       transform="matrix(0.15234083,0,0,0.15234083,-3.6001409,895.98861)"
+       inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/text4764.png"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806" />
+    <path
+       transform="matrix(0.12009891,0,0,0.12009891,-18.652602,903.86961)"
+       inkscape:connector-curvature="0"
+       style="color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4625);enable-background:accumulate"
+       d="m 263.40625,861.375 c -41.40153,0 -74.9375,33.56722 -74.9375,74.96875 0,41.40153 33.53597,74.96875 74.9375,74.96875 41.40153,0 74.96875,-33.56722 74.96875,-74.96875 0,-41.40153 -33.56722,-74.96875 -74.96875,-74.96875 z m 0,3.53125 c 39.44891,0 71.4375,31.98859 71.4375,71.4375 0,39.44891 -31.98859,71.43745 -71.4375,71.43745 -39.44891,0 -71.40625,-31.98854 -71.40625,-71.43745 0,-39.44891 31.95734,-71.4375 71.40625,-71.4375 z"
+       id="path4667"
+       clip-path="url(#clipPath4507-9-7)" />
+    <path
+       transform="matrix(0.15234083,0,0,-0.15234083,-76.298336,1107.5559)"
+       style="color:#000000;fill:url(#linearGradient4820);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4914);enable-background:accumulate"
+       d="m 577.55725,597.53928 -1.70131,-13.07078 c 0,0 33.61973,-17.56543 45.63461,-15.80715 0,0 2.94201,5.35937 1.76983,14.4438 -15.53143,-1.75828 -45.70313,14.43413 -45.70313,14.43413 z"
+       id="path4818"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc" />
+    <path
+       sodipodi:type="arc"
+       style="opacity:0.45081967;color:#000000;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:6.21632814;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4738);enable-background:accumulate"
+       id="path4669"
+       sodipodi:cx="31.071428"
+       sodipodi:cy="29.196428"
+       sodipodi:rx="2.3400502"
+       sodipodi:ry="2.8629718"
+       d="m 33.411479,29.196428 a 2.3400502,2.8629718 0 1 1 -4.680101,0 2.3400502,2.8629718 0 1 1 4.680101,0 z"
+       transform="matrix(3.1362406,0,0,3.110622,-70.33384,935.46713)"
+       clip-path="url(#clipPath4744)"
+       inkscape:export-filename="/home/petteri/svn-jpa/nanopb/docs/text4764.png"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806" />
+    <path
+       style="color:#000000;fill:url(#radialGradient4384);fill-opacity:1;stroke:none;stroke-width:0.35433071999999999;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       d="m 12.311735,1016.9223 c 1.550635,4.0379 10.914009,12.0675 16.063795,15.8189 1.507517,1.0981 -0.06039,3.1767 -1.414591,2.2851 -5.838796,-3.8444 -16.020602,-13.7073 -17.0431309,-16.88 -0.6363502,-1.9743 1.8481339,-2.6454 2.3939269,-1.224 z"
+       id="path4370"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sssss" />
+    <text
+       sodipodi:linespacing="125%"
+       id="text4372"
+       y="1042.2502"
+       x="1.0272956"
+       style="font-size:8.53108596999999946px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Baroque Script;-inkscape-font-specification:Baroque Script;stroke-opacity:1;stroke-width:0.29999999999999999;stroke-miterlimit:4;stroke-dasharray:none"
+       xml:space="preserve"><tspan
+         y="1042.2502"
+         x="1.0272956"
+         id="tspan4374"
+         sodipodi:role="line"
+         dx="0 0.089285716 -0.40178573 0.17857142">nano</tspan></text>
+    <text
+       xml:space="preserve"
+       style="font-size:5.24954605000000019px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:url(#linearGradient4776);fill-opacity:1;stroke:none;font-family:Baroque Script;-inkscape-font-specification:Baroque Script;filter:url(#filter4794)"
+       x="-16.312414"
+       y="641.44263"
+       id="text4764"
+       sodipodi:linespacing="125%"
+       transform="matrix(-0.61516641,0.01474994,0.03895428,1.6246424,0,0)"
+       inkscape:export-xdpi="66.074806"
+       inkscape:export-ydpi="66.074806"><tspan
+         dx="0 0.05494136 -0.24723613 0.10988271"
+         sodipodi:role="line"
+         id="tspan4766"
+         x="-16.312414"
+         y="641.44263"
+         style="fill:url(#linearGradient4776);fill-opacity:1">nano</tspan></text>
+    <path
+       sodipodi:nodetypes="sssss"
+       inkscape:connector-curvature="0"
+       id="path4808"
+       d="m 12.311735,1016.9223 c 1.550635,4.0379 10.914009,12.0675 16.063795,15.8189 1.507517,1.0981 -0.06039,3.1767 -1.414591,2.2851 -5.838796,-3.8444 -16.020602,-13.7073 -17.0431309,-16.88 -0.6363502,-1.9743 1.8481339,-2.6454 2.3939269,-1.224 z"
+       style="color:#000000;fill:url(#radialGradient4816);fill-opacity:1;stroke:none;stroke-width:0.35433071999999999;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+  </g>
+  <g
+     inkscape:groupmode="layer"
+     id="layer3"
+     inkscape:label="Taso#1"
+     style="display:none"
+     transform="translate(0,-2)">
+    <path
+       transform="translate(0,-1002.3622)"
+       style="color:#000000;fill:url(#radialGradient4116);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       d="m -35.379815,1018.4927 c 2.32122,0.8511 12.114835,9.3296 16.79371,13.7454 1.394403,1.316 -0.01718,2.6465 -1.286446,1.5661 -4.380417,-3.7284 -11.292967,-10.036 -16.625913,-13.9411 -1.720605,-1.26 -0.350832,-1.9092 1.118649,-1.3704 z"
+       id="path3794"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sssss" />
+    <path
+       transform="matrix(0.21843081,0,0,0.21843081,-118.38007,-122.81195)"
+       sodipodi:type="arc"
+       style="color:#000000;fill:#141414;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:4.45699024;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       id="path3003"
+       sodipodi:cx="352.14285"
+       sodipodi:cy="623.07648"
+       sodipodi:rx="40.714287"
+       sodipodi:ry="40.714287"
+       d="m 392.85714,623.07648 c 0,22.48588 -18.22841,40.71428 -40.71429,40.71428 -22.48588,0 -40.71428,-18.2284 -40.71428,-40.71428 0,-22.48588 18.2284,-40.71429 40.71428,-40.71429 22.48588,0 40.71429,18.22841 40.71429,40.71429 z" />
+    <path
+       transform="matrix(0.27475574,0,0,0.27475574,-114.10762,-135.03034)"
+       d="m 392.85714,623.07648 c 0,22.48588 -18.22841,40.71428 -40.71429,40.71428 -22.48588,0 -40.71428,-18.2284 -40.71428,-40.71428 0,-22.48588 18.2284,-40.71429 40.71428,-40.71429 22.48588,0 40.71429,18.22841 40.71429,40.71429 z"
+       sodipodi:ry="40.714287"
+       sodipodi:rx="40.714287"
+       sodipodi:cy="623.07648"
+       sodipodi:cx="352.14285"
+       id="path3001"
+       style="color:#000000;fill:#1b1b1b;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       sodipodi:type="arc" />
+    <g
+       id="g3957"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.981634,-61.75258)">
+      <path
+         transform="matrix(0.83309894,-0.60922647,0.70597542,0.69306694,-284.83936,153.03103)"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         sodipodi:ry="15"
+         sodipodi:rx="32.142857"
+         sodipodi:cy="683.07648"
+         sodipodi:cx="63.57143"
+         id="path3865"
+         style="color:#000000;fill:#282828;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4049);enable-background:accumulate"
+         sodipodi:type="arc" />
+      <path
+         mask="url(#mask3953)"
+         sodipodi:nodetypes="ccc"
+         inkscape:connector-curvature="0"
+         id="path3863"
+         d="m 219.28571,665.21933 c 66.78572,27.14286 107.85715,-14.28572 124.28572,-68.57143 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         style="color:#000000;fill:#030303;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4077);enable-background:accumulate" />
+    </g>
+    <path
+       style="color:#000000;fill:url(#linearGradient4134);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4124);enable-background:accumulate"
+       d="m 216.67772,602.33922 10.60661,-12.6269 38.38578,25.25381 -9.09136,16.66752 z"
+       id="path4118"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.981634,-61.75258)" />
+    <g
+       id="g3961"
+       transform="matrix(0.1232991,0,0,0.1232991,-75.821959,-63.79082)"
+       style="fill:#333333">
+      <path
+         sodipodi:type="arc"
+         style="color:#000000;fill:#252525;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter3979);enable-background:accumulate"
+         id="path3963"
+         sodipodi:cx="63.57143"
+         sodipodi:cy="683.07648"
+         sodipodi:rx="32.142857"
+         sodipodi:ry="15"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         transform="matrix(0.75135225,-0.54944696,0.63670255,0.6250607,-232.37743,195.04269)" />
+      <path
+         style="color:#000000;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter3937);enable-background:accumulate"
+         d="M 219.28571,665.21933 C 285,705.93362 343.57143,661.6479 343.57143,596.6479 c 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         id="path3965"
+         inkscape:connector-curvature="0"
+         sodipodi:nodetypes="ccc"
+         mask="url(#mask3953)" />
+    </g>
+    <path
+       transform="translate(0,-1002.3622)"
+       sodipodi:nodetypes="sssss"
+       inkscape:connector-curvature="0"
+       id="path3792"
+       d="m -42.258257,1016.2227 c 1.5941,4.1511 11.219916,12.4058 16.514047,16.2623 1.549768,1.1289 -0.06211,3.2658 -1.454242,2.3492 -6.002457,-3.9522 -16.469643,-14.0915 -17.520831,-17.3531 -0.654184,-2.0297 1.899933,-2.7195 2.461026,-1.2584 z"
+       style="color:#000000;fill:url(#radialGradient4108);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+    <text
+       transform="translate(0,-1002.3622)"
+       xml:space="preserve"
+       style="font-size:8.77020359px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Baroque Script;-inkscape-font-specification:Baroque Script"
+       x="-54.180252"
+       y="1042.3066"
+       id="text3847"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3849"
+         x="-54.180252"
+         y="1042.3066">nano</tspan></text>
+    <text
+       transform="translate(0,-1002.3622)"
+       xml:space="preserve"
+       style="font-size:11.27597618px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#eeeeee;fill-opacity:1;stroke:none;font-family:FreeSerif;-inkscape-font-specification:FreeSerif"
+       x="-23.221466"
+       y="1042.3199"
+       id="text3851"
+       sodipodi:linespacing="125%"><tspan
+         sodipodi:role="line"
+         id="tspan3853"
+         x="-23.221466"
+         y="1042.3199">Pb</tspan></text>
+    <path
+       transform="translate(0,-1002.3622)"
+       sodipodi:nodetypes="sssss"
+       inkscape:connector-curvature="0"
+       id="path4136"
+       d="m -37.752827,1067.2187 c 2.321221,0.851 12.114834,9.3295 16.79371,13.7453 1.394404,1.3161 -0.01718,2.6464 -1.286445,1.5661 -4.380418,-3.7284 -11.292968,-10.036 -16.625914,-13.9411 -1.720604,-1.26 -0.350831,-1.9091 1.118649,-1.3703 z"
+       style="color:#000000;fill:url(#radialGradient4166);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+    <path
+       d="m 392.85714,623.07648 c 0,22.48588 -18.22841,40.71428 -40.71429,40.71428 -22.48588,0 -40.71428,-18.2284 -40.71428,-40.71428 0,-22.48588 18.2284,-40.71429 40.71428,-40.71429 22.48588,0 40.71429,18.22841 40.71429,40.71429 z"
+       sodipodi:ry="40.714287"
+       sodipodi:rx="40.714287"
+       sodipodi:cy="623.07648"
+       sodipodi:cx="352.14285"
+       id="path4138"
+       style="color:#000000;fill:#ededed;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:4.45699024;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       sodipodi:type="arc"
+       transform="matrix(0.21745941,0,0,0.21745941,-120.45056,-73.52041)" />
+    <path
+       sodipodi:type="arc"
+       style="color:#000000;fill:#ededed;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       id="path4140"
+       sodipodi:cx="352.14285"
+       sodipodi:cy="623.07648"
+       sodipodi:rx="40.714287"
+       sodipodi:ry="40.714287"
+       d="m 392.85714,623.07648 c 0,22.48588 -18.22841,40.71428 -40.71429,40.71428 -22.48588,0 -40.71428,-18.2284 -40.71428,-40.71428 0,-22.48588 18.2284,-40.71429 40.71428,-40.71429 22.48588,0 40.71429,18.22841 40.71429,40.71429 z"
+       transform="matrix(0.27475574,0,0,0.27475574,-116.48063,-86.30449)" />
+    <g
+       id="g4142"
+       transform="matrix(0.15661078,0,0,0.15661078,-63.354645,-13.02673)">
+      <path
+         sodipodi:type="arc"
+         style="color:#000000;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4172);enable-background:accumulate"
+         id="path4144"
+         sodipodi:cx="63.57143"
+         sodipodi:cy="683.07648"
+         sodipodi:rx="32.142857"
+         sodipodi:ry="15"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         transform="matrix(0.83309894,-0.60922647,0.70597542,0.69306694,-284.83936,153.03103)" />
+      <path
+         style="color:#000000;fill:#c2c2c2;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4077);enable-background:accumulate"
+         d="m 219.28571,665.21933 c 66.78572,27.14286 107.85715,-14.28572 124.28572,-68.57143 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         id="path4146"
+         inkscape:connector-curvature="0"
+         sodipodi:nodetypes="ccc"
+         mask="url(#mask3953)" />
+    </g>
+    <path
+       transform="matrix(0.15661078,0,0,0.15661078,-61.013712,-61.76127)"
+       inkscape:connector-curvature="0"
+       style="color:#000000;fill:#a0a0a0;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4625);enable-background:accumulate"
+       d="m 263.40625,861.375 c -41.40153,0 -74.9375,33.56722 -74.9375,74.96875 0,41.40153 33.53597,74.96875 74.9375,74.96875 41.40153,0 74.96875,-33.56722 74.96875,-74.96875 0,-41.40153 -33.56722,-74.96875 -74.96875,-74.96875 z m 0,3.53125 c 39.44891,0 71.4375,31.98859 71.4375,71.4375 0,39.44891 -31.98859,71.43745 -71.4375,71.43745 -39.44891,0 -71.40625,-31.98854 -71.40625,-71.43745 0,-39.44891 31.95734,-71.4375 71.40625,-71.4375 z"
+       id="path4494-3-1"
+       clip-path="url(#clipPath4507-9-7)" />
+    <g
+       style="fill:#333333"
+       transform="matrix(0.12363792,0,0,0.12363792,-78.263621,-15.25058)"
+       id="g4150">
+      <path
+         transform="matrix(0.75135225,-0.54944696,0.63670255,0.6250607,-232.37743,195.04269)"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         sodipodi:ry="15"
+         sodipodi:rx="32.142857"
+         sodipodi:cy="683.07648"
+         sodipodi:cx="63.57143"
+         id="path4152"
+         style="color:#000000;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter3979);enable-background:accumulate"
+         sodipodi:type="arc" />
+      <path
+         mask="url(#mask3953)"
+         sodipodi:nodetypes="ccc"
+         inkscape:connector-curvature="0"
+         id="path4154"
+         d="M 219.28571,665.21933 C 285,705.93362 343.57143,661.6479 343.57143,596.6479 c 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         style="color:#000000;fill:#a1a1a1;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter3937);enable-background:accumulate" />
+    </g>
+    <path
+       style="opacity:0.29098361;color:#000000;fill:url(#linearGradient4204);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4192);enable-background:accumulate"
+       d="m 89.653056,803.08367 12.096464,-10.90246 39.39593,41.08013 -9.27519,7.18311 z"
+       id="path4202"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.981634,-61.75258)" />
+    <text
+       transform="translate(0,-1002.3622)"
+       sodipodi:linespacing="125%"
+       id="text4158"
+       y="1091.0328"
+       x="-56.553265"
+       style="font-size:8.77020359px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Baroque Script;-inkscape-font-specification:Baroque Script"
+       xml:space="preserve"><tspan
+         y="1091.0328"
+         x="-56.553265"
+         id="tspan4160"
+         sodipodi:role="line">nano</tspan></text>
+    <text
+       transform="translate(0,-1002.3622)"
+       sodipodi:linespacing="125%"
+       id="text4162"
+       y="1091.0461"
+       x="-25.594479"
+       style="font-size:11.27597618px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#4f4f4f;fill-opacity:1;stroke:none;font-family:FreeSerif;-inkscape-font-specification:FreeSerif"
+       xml:space="preserve"><tspan
+         y="1091.0461"
+         x="-25.594479"
+         id="tspan4164"
+         sodipodi:role="line"
+         style="fill:#4f4f4f;fill-opacity:1;stroke:none">Pb</tspan></text>
+    <g
+       transform="matrix(0.15661078,0,0,0.15661078,-63.354645,-13.02673)"
+       id="g4541">
+      <path
+         transform="matrix(0.83309894,-0.60922647,0.70597542,0.69306694,-284.83936,153.03103)"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         sodipodi:ry="15"
+         sodipodi:rx="32.142857"
+         sodipodi:cy="683.07648"
+         sodipodi:cx="63.57143"
+         id="path4543"
+         style="color:#000000;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4172);enable-background:accumulate"
+         sodipodi:type="arc" />
+      <path
+         mask="url(#mask3953)"
+         sodipodi:nodetypes="ccc"
+         inkscape:connector-curvature="0"
+         id="path4545"
+         d="m 219.28571,665.21933 c 66.78572,27.14286 107.85715,-14.28572 124.28572,-68.57143 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         style="color:#000000;fill:#c2c2c2;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4077);enable-background:accumulate" />
+    </g>
+    <path
+       sodipodi:nodetypes="ccccc"
+       inkscape:connector-curvature="0"
+       id="path4148"
+       d="m 200.0102,910.94082 9.59646,-11.61675 39.39593,29.29442 -6.0609,11.11168 z"
+       style="opacity:0.29098361;color:#000000;fill:url(#linearGradient4750);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4192);enable-background:accumulate"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.981634,-61.75258)" />
+    <path
+       transform="translate(0,-1002.3622)"
+       style="color:#000000;fill:url(#radialGradient4170);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       d="m -44.631268,1064.9485 c 1.594098,4.1512 11.219915,12.406 16.514047,16.2625 1.549767,1.1288 -0.06211,3.2657 -1.454242,2.349 -6.002458,-3.952 -16.469642,-14.0913 -17.520832,-17.3529 -0.654182,-2.0298 1.899934,-2.7196 2.461027,-1.2586 z"
+       id="path4156"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sssss" />
+    <path
+       transform="translate(0,-1002.3622)"
+       sodipodi:nodetypes="sssss"
+       inkscape:connector-curvature="0"
+       id="path4258"
+       d="m -34.484897,966.58744 c 2.321221,0.85108 12.114835,9.32955 16.79371,13.74539 1.394405,1.31601 -0.01717,2.64647 -1.286444,1.5661 -4.380418,-3.72845 -11.292968,-10.03607 -16.625915,-13.94115 -1.720603,-1.25992 -0.35083,-1.90914 1.118649,-1.37034 z"
+       style="color:#000000;fill:url(#radialGradient4288);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate" />
+    <path
+       transform="translate(0,-1002.3622)"
+       style="opacity:0.35655739;color:#000000;fill:url(#linearGradient4348);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       d="m -34.484897,966.58744 c 2.321221,0.85108 12.114835,9.32955 16.79371,13.74539 1.394405,1.31601 -0.01717,2.64647 -1.286444,1.5661 -4.380418,-3.72845 -11.292968,-10.03607 -16.625915,-13.94115 -1.720603,-1.25992 -0.35083,-1.90914 1.118649,-1.37034 z"
+       id="path4340"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sssss" />
+    <path
+       d="m 392.85714,623.07648 c 0,22.48588 -18.22841,40.71428 -40.71429,40.71428 -22.48588,0 -40.71428,-18.2284 -40.71428,-40.71428 0,-22.48588 18.2284,-40.71429 40.71428,-40.71429 22.48588,0 40.71429,18.22841 40.71429,40.71429 z"
+       sodipodi:ry="40.714287"
+       sodipodi:rx="40.714287"
+       sodipodi:cy="623.07648"
+       sodipodi:cx="352.14285"
+       id="path4260"
+       style="color:#000000;fill:#6c6c6c;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:4.45699024;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       sodipodi:type="arc"
+       transform="matrix(0.21843081,0,0,0.21843081,-117.48515,-174.71724)" />
+    <path
+       sodipodi:type="arc"
+       style="color:#000000;fill:#727272;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       id="path4262"
+       sodipodi:cx="352.14285"
+       sodipodi:cy="623.07648"
+       sodipodi:rx="40.714287"
+       sodipodi:ry="40.714287"
+       d="m 392.85714,623.07648 c 0,22.48588 -18.22841,40.71428 -40.71429,40.71428 -22.48588,0 -40.71428,-18.2284 -40.71428,-40.71428 0,-22.48588 18.2284,-40.71429 40.71428,-40.71429 22.48588,0 40.71429,18.22841 40.71429,40.71429 z"
+       transform="matrix(0.27475574,0,0,0.27475574,-113.2127,-186.93561)" />
+    <g
+       id="g4264"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.086715,-113.65786)">
+      <path
+         sodipodi:type="arc"
+         style="color:#000000;fill:#9c9c9c;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4049);enable-background:accumulate"
+         id="path4266"
+         sodipodi:cx="63.57143"
+         sodipodi:cy="683.07648"
+         sodipodi:rx="32.142857"
+         sodipodi:ry="15"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         transform="matrix(0.83309894,-0.60922647,0.70597542,0.69306694,-284.83936,153.03103)" />
+      <path
+         style="color:#000000;fill:#4b4b4b;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4077);enable-background:accumulate"
+         d="m 219.28571,665.21933 c 66.78572,27.14286 107.85715,-14.28572 124.28572,-68.57143 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         id="path4268"
+         inkscape:connector-curvature="0"
+         sodipodi:nodetypes="ccc"
+         mask="url(#mask3953)" />
+    </g>
+    <path
+       sodipodi:nodetypes="ccccc"
+       inkscape:connector-curvature="0"
+       id="path4270"
+       d="m 222.39201,270.91065 10.60661,-12.6269 38.38578,25.25381 -9.09136,16.66752 z"
+       style="color:#000000;fill:url(#linearGradient4290);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4124);enable-background:accumulate"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.981634,-61.75258)" />
+    <g
+       style="fill:#333333"
+       transform="matrix(0.1232991,0,0,0.1232991,-74.927039,-115.6961)"
+       id="g4272">
+      <path
+         transform="matrix(0.75135225,-0.54944696,0.63670255,0.6250607,-232.37743,195.04269)"
+         d="m 95.714287,683.07648 c 0,8.28427 -14.390847,15 -32.142857,15 -17.752009,0 -32.142856,-6.71573 -32.142856,-15 0,-8.28427 14.390847,-15 32.142856,-15 17.75201,0 32.142857,6.71573 32.142857,15 z"
+         sodipodi:ry="15"
+         sodipodi:rx="32.142857"
+         sodipodi:cy="683.07648"
+         sodipodi:cx="63.57143"
+         id="path4274"
+         style="color:#000000;fill:#acacac;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter3979);enable-background:accumulate"
+         sodipodi:type="arc" />
+      <path
+         mask="url(#mask3953)"
+         sodipodi:nodetypes="ccc"
+         inkscape:connector-curvature="0"
+         id="path4276"
+         d="M 219.28571,665.21933 C 285,705.93362 343.57143,661.6479 343.57143,596.6479 c 32.14286,86.42857 -77.85715,135 -124.28572,68.57143 z"
+         style="color:#000000;fill:#414141;fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter3937);enable-background:accumulate" />
+    </g>
+    <path
+       style="opacity:0.71672136;color:#000000;fill:url(#linearGradient4317);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4192-5);enable-background:accumulate"
+       d="m 112.11094,164.13302 10.6679,-13.40246 39.92639,39.30492 -7.75997,7.26977 z"
+       id="path4202-2"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="ccccc"
+       transform="matrix(0.15661078,0,0,0.15661078,-60.981634,-61.75258)" />
+    <path
+       transform="matrix(0.15661078,0,0,0.15661078,-57.781488,-162.39201)"
+       inkscape:connector-curvature="0"
+       style="color:#000000;fill:#434343;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4501-0);enable-background:accumulate"
+       d="m 263.40625,861.375 c -41.40153,0 -74.9375,33.56722 -74.9375,74.96875 0,41.40153 33.53597,74.96875 74.9375,74.96875 41.40153,0 74.96875,-33.56722 74.96875,-74.96875 0,-41.40153 -33.56722,-74.96875 -74.96875,-74.96875 z m 0,3.53125 c 39.44891,0 71.4375,31.98859 71.4375,71.4375 0,39.44891 -31.98859,71.43745 -71.4375,71.43745 -39.44891,0 -71.40625,-31.98854 -71.40625,-71.43745 0,-39.44891 31.95734,-71.4375 71.40625,-71.4375 z"
+       id="path4494-3"
+       clip-path="url(#clipPath4507-9)" />
+    <path
+       transform="translate(0,-1002.3622)"
+       style="color:#000000;fill:url(#radialGradient4292);fill-opacity:1;stroke:none;stroke-width:0.35433072;marker:none;visibility:visible;display:inline;overflow:visible;enable-background:accumulate"
+       d="m -41.363336,964.31737 c 1.594097,4.15111 11.219915,12.40584 16.514046,16.26235 1.549766,1.12894 -0.06211,3.26578 -1.454243,2.34916 -6.002456,-3.95218 -16.469642,-14.09147 -17.520831,-17.35303 -0.654184,-2.02975 1.899932,-2.71959 2.461028,-1.25848 z"
+       id="path4278"
+       inkscape:connector-curvature="0"
+       sodipodi:nodetypes="sssss" />
+    <text
+       transform="translate(0,-1002.3622)"
+       sodipodi:linespacing="125%"
+       id="text4280"
+       y="990.40137"
+       x="-53.285336"
+       style="font-size:8.77020359px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;font-family:Baroque Script;-inkscape-font-specification:Baroque Script"
+       xml:space="preserve"><tspan
+         y="990.40137"
+         x="-53.285336"
+         id="tspan4282"
+         sodipodi:role="line">nano</tspan></text>
+    <text
+       transform="translate(0,-1002.3622)"
+       sodipodi:linespacing="125%"
+       id="text4284"
+       y="990.41461"
+       x="-22.326546"
+       style="font-size:11.27597618px;font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;text-align:start;line-height:125%;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#eeeeee;fill-opacity:1;stroke:none;font-family:FreeSerif;-inkscape-font-specification:FreeSerif"
+       xml:space="preserve"><tspan
+         y="990.41461"
+         x="-22.326546"
+         id="tspan4286"
+         sodipodi:role="line">Pb</tspan></text>
+    <path
+       clip-path="url(#clipPath4507-9-7)"
+       id="path4629"
+       d="m 263.40625,861.375 c -41.40153,0 -74.9375,33.56722 -74.9375,74.96875 0,41.40153 33.53597,74.96875 74.9375,74.96875 41.40153,0 74.96875,-33.56722 74.96875,-74.96875 0,-41.40153 -33.56722,-74.96875 -74.96875,-74.96875 z m 0,3.53125 c 39.44891,0 71.4375,31.98859 71.4375,71.4375 0,39.44891 -31.98859,71.43745 -71.4375,71.43745 -39.44891,0 -71.40625,-31.98854 -71.40625,-71.43745 0,-39.44891 31.95734,-71.4375 71.40625,-71.4375 z"
+       style="color:#000000;fill:#a0a0a0;fill-opacity:1;fill-rule:nonzero;stroke:none;stroke-width:3.54330707;marker:none;visibility:visible;display:inline;overflow:visible;filter:url(#filter4625);enable-background:accumulate"
+       inkscape:connector-curvature="0"
+       transform="matrix(0.12349317,0,0,0.12349317,-76.338029,-53.66762)" />
+  </g>
+  <g
+     sodipodi:insensitive="true"
+     inkscape:label="Taso"
+     id="layer2"
+     inkscape:groupmode="layer"
+     style="display:none"
+     transform="translate(0,-1004.3622)">
+    <image
+       style="opacity:0.61065572"
+       width="415"
+       height="330"
+       xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZ8AAAFKCAIAAABNc8VfAAAAA3NCSVQICAjb4U/gAAAgAElEQVR4 nO292Y8kR57n9zOPiIyMPD0z68o6WDybXewedkPHNji70GAGPeB0L7CPetQ/sW/7pP9Af4AAAYKg h33QiyRAmp0ZzQJaaGY0rUGTzeFVB6vIJItZeUVkZtwRbnqwCEsLu9zc3NzcPCq/IMCszDjMzM0/ /v397EIfffQRXOs1VhzHCCEAaLfbGGPpC9rttvdyLRQAIXR2dpZa1KILkOn1rgqZ9dvNPxMMWrKI bzfRzs4O+SFPM6Jrur22Mr8Jy+riVKSve4YaJxPKu+Wa+Mn5L4FdCX0+4bgS5qn4Nd1eO1k7IP8m jitq6ZBVFcCbqcxzCXKS10Pja0poV/Frur1Gyu8svAHOeUd3KLYAxZk1zbdnpYzDQhbEOJMSWnz1 Nd2WX26dRdHP8II6uluVlQHkCpDaAgXB1237x3Hc6XQMS5jpq6/ptswqNA3k1kBZ8KIsE0dbNY5j ACgXsqoW8GAq87e/dSENGXdNtyWUH2dRbp7bbRnMvwuEVi03UhZbwGewbN3+TgqZ+u3XdFsqlZIG sru3HSK4aL6ktmo4kTKUESxnqr7zLqr59mu6LYPKTQNlhUsRCC4x282+uCwT52R2WE6lXoJCH73S b7+mW4VVem6bK0lZSW72813xxXpemGcT53B2mMPycAXwFlJw335Nt0pK7NPlTpKgpZIWwyeFc97e Torq53LoJ82UzjjSAv5TJey3X9OtStLce+EAjr2vSuncYNUa4S+f4j7cZBFV6cMd5c6YuaZbNVSJ WWBcSSDsNBD3ypCXT3EfmGnSjP8uwRay3D55TbegVaFZYPTb6Vyw0rOBkNYafvyFkytSiXkzqkKW xbhrugWqnL3ZP+DEAgfiJcvNc2vKYP5GCH7eTJixxTXdwpKr3uz5cQ0Bb6DEFqNCU2eqMm/GIlj2 1h+u6RaECrrrSn9cs68s18SFMCMMzJrCw7wZV5cjzrJEtIgC6HVNt5JVoSlg9AOrsoES/d7QZs+o bu9KLKJi355z3kzRjLumWznyPAXMyf3spEP7JEtoSW5ObGtcT53J/1Hix17TzbfKmt9Y7oPaVUnM vwLSnhzhmDi4njpTzCKTa7p5UiD92GJBKBRQ5oLIUonpYNy3k7GOEIykpik8PJKdXAsuD3hNt8JV 7qRtsTAmWPHTmx0CrloTaEKePcM1RbWmznDlvKabY3300Z8ihBCqp77y+OQEY3j89T+Fs1+NZ4Pp 6nGd//Yrfb6r52JoRMtQ4lM5UztoynlNNwf66KM/XV/fID+j+TZb/f5Q9fpGY4X8cHJyyl6S4Wjo DXbcU7rcrmxhnYoAcTgTaMpNCFZl9kxqk17TzUYszoAhGgA0m6v05263n/pRnc4F+8/xeER/Pjo6 /vHHxwDFxoYhBM6untVOSuKcLBYFLsvEhTl7RloGk6l213TLpr/4i3+DEJpMFtqUJRonDeCiWo38 0G6fAwBOEvE1xycnyXRycPClc8aFMMrBKfVe8gNit5Nd8xTYJ1xCnj3DlcG8Va/pZqR/9a/+bHNz E+Y2bTxONERjFdVqJg6OAE6qo6MjAJxMp5PJ5Mcfn+THnPh8Lr37Umke1J4NZk6yuCqwtwk0oS0R VZUBsjyPr+mWImLWaOzZbLbID+PxVPUWasqocgIOAI6PTzBOCObsrJy+c4QQgxBZP6iLLkmmd1Vi RZ3FBJqyOgk7ewaMzyG7pptSKq5RcYATocZKBTiuX3XUjDs+OZm/ZQoAo+HIMCtn2InDARyEFDhn mkMDhRXYuXsyyVt5KIbhl3JFNbwo13STKJVrVFNJrkypbrdv0pd0gDs+nv2EEABgPP32xT9rAFet 2a1sGbI+pT0UqcSZroYlyfQhgS8RZb9IFW2kluGabgv6+ON/jRCKotlsNQ3XarWrGW2j8UT/sfTS mISooAbcdDo9OTmNIsT8Dl92eyfHz1jG5fQRZZk4aVcOx1GWPtNVUxLzN7pdIlr6BBo9467pdqWP P/7XURSRn1dXN1QvY7lGJQWc6rroGZdMEwBotzua15ycnNKfowh1e73jo6cA2GEy2ydTUue4hgO4 0me6ciXJ9PoiVtQ5N3EOJ9Bc0w1gbtmI31ltzf0a5vNoUq5RUcCZXBQRcIkQ5ZoDjnxtfzA4OX5a iamt9CsMPWYIITMRmelaejaQyOQaVWWJKP0oi2ygqhjXdFu0bK3FUHQOOD3XqIajlBCVVbfbF4km SmTceDwmP5yd8T17PB4nyfTk5Bsn8+OKY4rdLVeuiWPLHA5tU9fV+VwiGsgcGlqM15pucRz/6lf/ Uok2AMA1Q67RSzJSzxRhRbhmmIZrtzuUaJxEwE0mEwzJ0aunriYAu2VK/gmupYzZqWa6hhYys/8s JSEYwhwaWozXlG6Ea5JodFGNeiNJIv1HiZdEDzjRr+kZN51OAeD0VNdjjo9PhCLhV68cTP0lcnIb O+zE3rCSWuZwTBwEM43GvE2KXlT3etGNXv5/8S/+WGfZABr1Bv1ZBTjNJZECThOHSgFHuEYlBdxg OFurf3lxSX9J6pgkU7eAs7uNC7rligZcphsvBBNH2xmqMI0G8qXYDPW60I3trH/2Z38WRVGj0dJY NvGXHONMrgplnEl+jQKOgxonlnEUbUQEcOyS/iSZJjg5PnpWiokrOj4qyDdZ5wTLMnFigUOgLZG0 JN4C5yWnm2gcCNoAYHNrV/oWKdqICODML8l4PJlOM1y/8/PL9BcBnJ6ecVyj6l52mX/NHBzGydGR 1zSc5wmuru5kJ9NcA5lJE07IzJbEc0JwaekmbUeKtlZrDQDqDX4lvAZtAAAQmdNqPJ8gYvgWMnwh jhJwGo5GIJkOMlO/1weAZLbdyNzEIZhOxn4AV0o+Oz9T3OYEPWDFyWRXnyqlYywb3TRZHg5tRBRw aVwDgFlkakKr8eLkXv1bxGFZFeMI2qg4xhG0ESVJwtINMEynjgHH3TblTnDNmRYsYpprofP4M2Ws gppJ47MkS0K31NS1FG1E9caqOdqINLQaK1Zlqd6imnEiAo5DGxEFHIs2oiSZfyOhHIZpMjlyN84A i5nsECa4mt88HoYXA5nHX1xhDL9XXADvrSSVp5vJ9dagDQA2N7e43SgFScZMpbRSoU36rtSZdCzg pGgjOjk5FdEGANMkAQAEiNINADscSA1k/gEnk6G6Cs1xZT8nf7F9WqfU1XUeGGc0VTVAZbq12GFE TpubWwBQr/Pb7c6lnOxWqyEWValc495lMkl4ZycGgB8PX6V8ZiTZeWk63+kXA57hDQFgFEW1mzff yRmich03nOQOAJC7t9yhOq48OdvHYbHzF8ZEJgXWXCaHqp53y3qxNcaNoI1KAFzKPF6YezFDtBGN x+OGMJqhEqnj4asjzWvaZ7OlWpeXV0Ou08V9zGd8x+Qj8eHh13Z00w/SBTILgYgtT+mL3sGqfYor dkEXy+ECeCeqDN3s4qBf//rX5IdUtBExgEtHGwAMBkPzFwOzRNQEcGw1VYBrtzsspijgprJTGmiM inFyeJjhPBrDxg8QcEHFzoFM4s9aGPMPdLgA3okqQDfrK/3rX/86iqIkSQzRRjSZ4IxoI0p/i7hW VMM4sbIi4Di0EV1eXkrRRoTIAKrxSoasjR8O4GjJ4wBOemelbyL/acH8WHFVZuedJ9y8W/4HL3l7 JrQBwP7+7ZcvdZEg0SLaACDRA066DH48HkgBJ63v7Vs3gWGcFG0AsLGxcXp2qsrrYZwgFAFghFJw bNdl/WR29OJKTrdjC4RxqiYqKy0IObDitszOO0+I3s1JkxHjVq/XYTGFr0fbzZu3CBN/+EGXyxfQ RiVBhmp7DyoOcKm1Pnx1pEIb0enZKagGLuYfjhBSxaeVG55jv1Q/TheIrySi5QkkLZgJK4WW2RXj AvJurFmL4zhnq7HjpNPphNzqhmgDgLt3b6kAp0YbiA4uFW2w6OBMan371s1O+xwr8HbWnvUJWmt5 QZMEIXTr1rs0PnWbpSIXMZD5B6UUKVXtMI7KpoUB4wdAnhSb88JoVL53U91UeerGGjeqWq2uoRuL NioRcFq0sYrADG1Uvf5ga3Pb5JU//PCSNNTlZU/8KzFurBYYN29h8gkIoSSZTCanUEzqPZD5B56L ZF6MUmbw66Vvn2qlBcukW2pL2V11gjYA4Oi2vb2NkPxQPinaiFjAGaMNQHvgqahef0B+SAUcRRsR B7iz9pnYmBjjOrsYA88mhtBfHB09LrSzhjP/oOgiGX61WOxAmEsV1Eo768YpgW6ZIiCLXvjnf/7n CCERbeQHEXAatBERwGVCW7fbBYCVFaN5bRRtRBrAcWgjYgEnGjeYg+wKcIv2DQDqjcYP33/ucIWW KLc0cZUZ9A8UfUwXlImDeXkCCZ8zNQ4ps1e62TVTplpJY1Jg6AaLgEtFG9E33xyYl5mgjcgEcBzd iETGSdFGdXnZkxo3WLRp9XpDRreVH77XnYvqREFNPmA/0A9QDEsepokrHW1sYfSNwxbYx6hCznR1 pmSwFFUs2kxez+nw8KjVWgGAXi/dvrFoA4DRaABaxknRBgDnFx0OcPqm29hYkxo3TpPJuC4MNUzG o7v3PijavgU1+YAtVdGAy1RyP0uUTBRgZpAdYlYdlMNa42K9m8MeadK+UuMmRRuxbybG7fDwiC28 HnAc2lhJAadCGxUFnN64AcDBwQHGGANfHcm7mDScZ/tGZBFiQMHrDQpyTDkzg2WZuCpmBqVlLsS7 FdEjTZ6xJkaMCOPprVv7WdEGAGtrTRXgNGgDgNFowAEuFW0wd3CpaAM6BkqWkgqM4zSZjIHNxPmy b0SGdslnTOTcMeUvfCkmTlPsVN/kWWz7qLKZjulWaI80uStqtYVBA1VM+v77PyVoOztTnogsoo1I Cjg92ohYwJmgjejp0ycY41ZrXfOag4MD9p8IJCZO1GQyXpwQZ/psyC/9rPSycj1OotTAp+9rZDKL LZzAmQghRM7PlhbbDd38hA+g7X+//vWvzb0b1c7OthRwKrQRcYAzQRsRScNNMswVmV22fr+rAZxY VEPANVfXAGA4mI263n/w84PvPvMTn0rvk9Jz2HloUlxmEAoGStaS+2SuSlyZpeXJRTdvUGOlAhxF G8aY/Jxq3IikgEutDgWcOdqIOp1zAFjf0K2aoDpiVs6rAMcZNyoEuD8YNJvpg7bN1bXhoDcZj+qN FZNSORS9mqVzjS0SWCUHCy18QUCxLnm5Jk60mdLyWNKt3L6oAhwNS8koj/S9HNqIOMAdHqavogeA tbXmy5cv6/WmabnnaAOA7uV5KuCOXvH+sd/vAgDHOP0lGA6NABfv3GyfHYFf+0ZEg4sQ0EZlSJPq JgedlNy/idMXmytPNrqVYtak4gBnF5ayooDTx6SsXr58iTFW7fMhiqKNqHupM3Ei2qhYE6cybqxM ANfvd+OdmwBwealMRDqXGFwEks0h0tOk3ORgHqA4zwyCr2uXKTOYYTZvOIEDK9qmZH0CO6RQq9U2 Nze510uNG6svv3ySCW30n6mA49DGSgScBm1UrdY6mQWiekF/wA9czBjHvGVt/eqrCTFXms0oqv3h k78uem2WtDuFBjii0JKD0lKZv6ugBfCFmji7Nk/xbuGYNalYB8ehDQAuLi5EwGn0+MmTqIanZruI c60xHg9AzTgN2kAWpZo0db/fHY+H9XqGTJlhlJrTBetlElmEBjhql+g/Q7gXspq4oqFc0JSRPMVW 0o1+KOltIVxOqdrttiYsZQGXatyIanVIBdzLly+lv5dGqXq0EbFR6pH2FAWqw8NDAJhMRpkA12y2 gBkk7XXPWftGNDUEfEYZdtMQxuNEtdvtMJODYGDiKp0czOM0ebqJZo1sbRra45SVnlkEcKloe/zk KiYlk8BU9zgXk3IyT8OJ6l6e93oDw0tJyzCZjACAY5wYlrIig6TSP42Gw5VmhnESE1lMOICQolS2 /GGSV1Wq1zw5WGc/CxSPpjDjBVZiWMrq4uJC/3YWbVefIzNxerQRsYAzMW5Up6enGOPVVd3EXSJi 3FhlNnFqwAHAH/3i105Sb3n6aAi9Tix/aOQlUk0eLHSPSYsimcghkeuZ4oWgrijVeDwWNwVh1Wg0 Pv30kw8//EXWjBIHOBO0zYs0AIBeT3nEslTkwweDLgDoGScthgXgVH/Kn3qr6IQDquv8oNsimScH HRK5bv5ZYV5RTqJxI8IYqwAnNW5XHzgHnDnaiNrtNsbQbCoJwun0dGGHj8GgqwKcaNyoSJQ6nijP xBK1vrHZvbyAxYkmeVJv1Z1wQFTp/GBQaCMyHG0oIoiuZ71jgwIcfVKNx+NGo6F/sQZwehHAWaAN AIbDngngSEzK/VIKuMPDw9SSIMVk3K0t+Qzn9Y1NACCMs1ahw+t+Ol6l84Pi5MGgyJs6ebCIILr2 4MGDTG9otVoDbcbaj+I4brVanU6n3++/8847dLIb2XOcFUe9V68Ob9++TQGnN25UT548bhgHfRRt RNPpeDodL+z9vSgp2ogmk/FkMmbjTfbAecVbElAsiCcDpqy2tmP62pWVJinGdDqt1et39t99dfiN /ruI2GtRXN8YDAZxHBf0+WwV7ApW7n1B6MAWfjAYFNpidhLbirZ8EU4z80qscodQNQZhPB6vrhod 8E4dnCHavv76Mca4178EgLXWhsFXSH6pMXGpZaAmThOTipqdO2/0qpk2trYB4PK8A2apN89DckUE g67yg1CSiatcfpANVKHgCNpmnWkpTaa6in/yJ39C78Ner7e2tkAQabhKAWdRjF7/Ug84TbNIAcel 21QaDLqdzmVqP5gIGTdVlKrRxtb2anPt/FxXsBKnGoAjjjivguf7Yjnyg4X2H8tV9N4uZCrjOYsh Ak4qjPHf/u3/hTF+8MZD/SuJcVv4CjXguJhUFAc4TUwqe28fjE+iYUUaaFORdFNpa2v3g9PTz3d2 uPKFsA4pZ/crrgp+UHKdHzSU/Q5IRQPOuguaAw4Avvv2hQZwItpmXyGLUlPRRjQc9gCg2VzLhLaj o2Pyg7jHr6EaK83xKNsMlS92dx+dnHyxu0tKGQLXqOw44qEKRaPEOgEfgokTC19oc+Xa360gwOXv ggRwmlFUNh7UA073LYyJM0Qb1cuXBysrfI5fpaOjY7YpVCfRiGEpp8bKCgCYMw4TwJ2evnz7bQiG a1SZbozrFCEEnx90Tt68e/M6BJyfRCMR9/lSwKmMGwDcuX2n38cA0Dl/tdZaB8VIgr4A1MRlLS1R JhO3s3eL/txYWTEH3HYcv4zj/WfPEEB7d9fwXT5l0gNLmbUfbIrQs4kzzw+Ca/I62Hk8P+CKeK72 ej3V3rzSRD4HOD3aEJol67e3ZtQ4ax9ijHd3jHDDFiB1QhyNSUWxgNMbNy47aWji4nin3T7DGBOu PTo9pVFqUNL0wNKj6TBThN5MXNbnilvyujlXwW7hjluzliQLt/d4PD4+Pr5x44b4StV3UcCp0Dbn GgDA2lrU611940/ee+vrx9+cng0AQM84Md2mARwXk4pKPS9Voxs398nbVaLXhZSARKkhA469K0rn mqZsJvKTIizOxFmX3yF53dAt6yQ4h1eu1+ttbSm38BYBp5+B8d23L0CNPw7iNcXi1tOzwXA43L8j cY6qkQRVlGrYPpOp7mVsWMoKITTbEGmomsKKuX8EDjgIdUfCrHest1C6IBOXv/xOyMvP7M9ZmtSX xXG8s7PT6XTOzs6cXLx//Md/1H/O8fHx8fFVcJf6pUdHR5cX8t23yfp2AKjVarVaba21ALtHj96r 1Wbt2Ww2X/4o+RD9txPGMSVRxqQSIQQKB53qrMU1DET/8r/6r7n3UsD5Oxwwi8JEG5XJPUJvEJ/l JwUjG9jllMPyt9ttYpusC+byPNPU9AcU0O0wxr1eb309ZdcgYuJMps6S4l1edDY25Wk7dqH+Wgv1 +rPqIITef//dr756gjFOEkwAxzo4k2+nUWpqTEoV1Zjt2BDKPMABAADNZmtjY6u/uCeSFIsUcIDx F3t7gSDE5yyqPNJYknJD6fwmLsAUoePTmkXA+blmvV4vdRnW8fFxqos5OrraF5cDXBxvAcBo1G+p 1ypQwM1Wu2J4+bKzv78NWSbuEgdng7Z5IQCuBnFVYWkc74lvJHuEkJO3NCKAgzDGGaQdLKj5q5zE slU9RQjFh9J2BXNMN7Yc9J/+r9l4PJb+vtvt6l0eV1QSohLGtdvnO/EWAPT7lyzgWPsGi36ntbba 7w0g45oEALi47EU1lGizaSmamzg10JWgb7XWV1vr/a5uuX4I4wypUCh6wnkesbdJCFyjskgR+kGz xRPLWd6Nir1mrpJrJkrd3aHX64H2cGXWuLFSpeGouATc+++/S5nSWlv98cdsz7SLy1l4GNVQVNOZ TYlxY6XOxJmotb6xtr6pgSCUl4Yzz94apoNLkZ+1lnYyycQ5z6G7KhiVS+8m5j48Pzb7/X6rlb4A QOXgNFeIi1I5+8aJTcABQJLkuvB5TNzejTsIoSSZ2r39r/6P/wHjlPUPngdSLZyC58mrJir9TjGR 3iuVMkGaiB0c119TB3RTGez8u1dbyBpwKuNGRRzc3m48/6IFwG2s1/qLU8ciFE3xFADW1lu9br/Z NEIMNW4LH1VDAMAxLsW4AcD8EkRRDQBYxolJN5bdq/MdelPRNnuZl3GGPBFQOGk4VZYwNP5SBTuR 0OSa5opMWWsqulMympvn8w01nS6Aw3ADQi5ENblUlxedZ8+eca+MoohsmdlaHNX46aP3alEtQhEA rK23hsNar5ey+a0UbVdfxESpJmjbu3FnsZzsnuyOHzwEcF/s7RURpbqKgEqPUonfkdaCzn4opWB6 sWXTVKEU6QNVG7qRjzPpcH76kzjlTQQcSbpxooBLNW5EZ2dnnc5VDq7fv+S2AmYBhxD66aP3EEIR igjjAEADOD3aiFIzcaxE7xxFtUXG6VSvNzJBEBeThnN7Ozmc2JVJhrPAyiqeiRBCOzs7CKFAuEal eTBko5verKm+u2jASYth7uC63a7hBSMvY+1bt6s70I8CDgA2NtZrtRgAer2LVBOnF4rS90DnjBur nb3bkfYIsTxyCLiC5rV6dklZjWeAJo5UgRQstLJRSR8Mpr08Z9bDQ8pDfKoY5uDOz89BfZgWFc07 kNer1FoFNgHHGqiNjfXLS5hO2wDQ612srW3SP5kYN1Y4ZbZH+p+iej2ZzA6+Us1btlP+cQZvSywL 7ZPh3zImEkcPgs0Sipm4lFNj4jhutVrWB2pQFX2ARRzHTeYEdbqifjKZkF3eVDPgAGA4HAIAxlg8 cYaKe/D2ej3i0gFgPB6urCxkwRp1mDAH5t24sXtyPFulsLKyMhzOjNt4PGo0mpARbRgvbFonpRgZ KpW+Pd65QaeJoChCUYSTZKW5kDKsN1YA4G/+8n80HFWQ6rjVenR6emzwdFkoXo7TW7Kq6GNonNwy JR5GE6vPcwnzSBoitt2UdItdH3RUaHMcHR3dv3+f/pPdL2QymWjQxhoxDeC4bjocDs0BhxBiAbe6 usUCbjweYWyaH+DQRsWyTIM2AFhd46fCoChqrW3QEVU6YPrN098blkolAribvd6xwVbJPrlGVQRB NFDIqhIhYkLn0vmr0mAwIJ6Mj0wLnT9dnN/GGF9cXGxubkr/OhgMTI7LgvnwKxelmjjwbvd8fV25 VQlJwH35xWxjpai2nUxnoxPTJALAJvl7FdoAAGNMiaZBW7wj2Q+KiPi1yTjb1uR6GS7Yqvr6Sqri Flr6jAQz1SKcqTasSHkwxnX2Vx46WXGT4DDG5+fnqt2QzAEH5EDPOeBUyeDz8/Nnz569/fbbqhqt r9X6zAotQPDBB+9/8cXXSZJsbmxcXEIy7UwT6trw7EW2IoW8cXNf9yJZUdkjnOuNlXpjZTIezQdM 8/YE/YKtQGZOQah7TFL5gYh1LcLJxHFViMDviorixlw+//xzAjjVC0T/rHkxnUOnaZDz8/Pnz59L x0/JxIvW4gothNCjRz+JogghtLW5GdXEXL7yuzTGbfFlFpePRx5hXPbPUUocSC1lEY9e1rMxvE0B K3T6Qc5ahDDUK1ah9uGHH5aS7CgiVr916xYANJtNbp/eyTwHNplMJpNJfT4fgownqIQxZme3SbWy stLpdGg4Px4PV1fXELrKozUaiB1hQAgdHZ2Qn5vNZr+vmhqyuKuaGdp2926TgWM2UKVixxOotrZi 9rto0u0v//f/Ps+QglQkDTfZ3/efXzNU1jyXwxSbocJPFJaSiVNVISrl4VnEU4giRj9jA+YmLvVl AJAkib5xxA+5uODNeYvf5PInFD17u3cVH2xzRViiJUnCIV6xol7yy3q9UUSX2I7jl2+/vf/s2d2n T+02ofMjk85Zovd065KcG0//Jk5ThZQZIcXJoYOj5D46Orpx4wZCqN/vsxNEJqx9mv+GW78lis1x aNKF9IFPXzMaDbjdblkHhxC6cWPveD6EutbaVDs4AECZjBv3S2ripMYNFnflpcYtimqPv/pd/qQb 1dV46GBw3GodWU0W8SmNByllbFdU/tunUOPpx8SlVqE0uoHTK0S7GglOa7UaCziRbgDQ7/f1M3jF gqkYt7q62ul0tre36QvEvby5+JQF3GSMk0QxWImNlkNJ0Tb7AIwxxq11yY4mXFhKc20Ow1IVC+xm w/mUGKUGwjUqa4L4qUjR01lM5qy4398tk6xDVJPQIDX2HKmPvJMOTskHTy8uv/3uAGP84sUL+oLU +JSMMBAkbW1tNeqy/ZRwAwAQYJRmo/Qj0fHuTcI48X3iix2GpZqQoayN4bKK9k9vQweZZBEGeq5I QStnxRUUUpXp3YgyPXxS106Q8xMQQiTrNBwOm82m6N0uL2cbz06nU3b+B5WmSCxKzi9mn9M5P9/e 2jKPT2HRwTWbTZmDuyoVmqFIQgONcQOAePcm99c5UgscTzCMesJ3cMnFsfQAACAASURBVABA+1tQ XGNlaOL8j4EQuTVxmWpRPt0Ma26+doIArlarUcD1+/2VlYUpDpxr4wBnMqsIIUTRRtQ5P8c4yQq4 m7duHB+dgDiEKku3iYDTow0AWmsSV0jP+qOiYenTr/8pT8Yta9STaT2DZ5G6tNvtfr8f5qR8Kj1B QoipnWTisq5vKzkyJdLHp1nHp6SvoWZNJco7wwmTqpJ8++237D/FEHVjo44idPUfQh/87H0yCe5q CFU9ksAFqqkxqfT3m5vbbKxKjVu9bjSCIf8uq2HEQjeGs5ZYlxDmc6VKeh+FE1PnacPYasOY8r0b kfTJY/3MIfaNTokgw6Oj0Yg6OGnGjTg4w2fLZAKN+spksrCCtXN+HsfbZAYc/SXr4IhDXGlE4/EC oW7cnIWoa2tbvV56AYiJszNuIAx6NPKNJzixBuFEqRqDEOzScSrWIpUViuplYeKyWjaqUOgGTNdJ Ta6ZqF6v0zFTOvmDAk41ntDt9hGKUu9wGl026isc49qdjgg4QhM2+BUBR2f5rq2t93opZ+4BQBzv Ak6QejdKMeNGxGXcKAHrjZXxcBTHdzqdw9Rvn5fBZchTOuBMcBDs0nEqGqWGM7zLyTwTlxPQ6KOP PrIqYSEiYyuu1uvt7++TdfX6NQmsBoMZ9ZJEMomESDa9BPqDBR69+fANAHj48CH9TRxLVrB3e1dz 7jDGX3z+Na348fErTTnjeJclVFTnF04Zog1YfzdpP378hESsL55/or8EBa2sRCWdkWpRndCWjlPR upApSqWv/dRIvzrVcGBUo1C8G5fBdfJgvLy8rNVqq6ur9Xqdnbs7Go9VM90mk9nLSFZMauISmbHj TNx2vI0AWPs2HPZXV/nEOevg2PgUtA6OQxsA4GSKkynr4wxjUhZtAHh3d2dvb/fsrL29fVvl4IpO UXt2cNbVCTBK5eoS8i5sRKoSuoqpy/du0semqwfj/v7+dDqN45i1b6P5dm8rjYUkOjVurDgTJzVu rKiJY+0btVHb28IJ8BkdnIg2VsTEZTVu9cbKpH/FMozxkyfPSNaSNXEF+TVRxMEVesIWUX53EI6D 09QlnEKqxJq4/BeFqjS6xdqN5HZ2dlw5arJ6gd2CfMRsZskCTko3YACXijaq/qAbRc03HtwGgIcP H7KsEQHH0g3SACce1sdpe/dmvSE5MUsXk44PATCgq3cRwNEolcQ4PrcqIgUtLkp1SGp9eOVBJnUp vZAmcv74LIFuhnVw+MC5detWrdZYWZltDTJa3KqXAE6FNqrRyJhtAIAaw2EfAAjg3nzzTfaP1oDT GzcA2N65SdeTcrsYbW0tzBdnBxMmPWYWy5xx5NufPHmGAD179k+ljLsVkYYryIGW5Y8yOZ2QTRyp CEnmuKKwV7pl7Vhu41MKuJGwEflKo5FKNxQ1hgOz1Ay68oOjUf/BfTeAy4Q2KsK4dOO2UP4FE/fN sxckSi2FcQ4BV3Rk7ZkddtUJ0MSJFXHVkp7oZt2xXNWT2DcAWFmpi3QDgChamYyVQ6sougJWCuMQ PyHWCeDa7fbGhnxf9dmnydBGtLm921icpkvR9sOLvyeff+/emwv4YwCHAJ4+fU6i1OoCzmE2R/8t HtiRH9PhmDjVdXHSkoWPmeYcYnM16NPtdtfWWlFUm04T0QBF0QoARLU6PTyFFYs2AKjXG1NVBk5A GwDUao2N9SYIU8nFUVQyhIrmq0oRQjfno6irq6vn5+fc2TSsVhWDpADQXG0lc9WiGhuTtk+fE+N2 cdFZ9HdTgCmgOgBECO3sxGdnHQDY2dlvt39UfVFxyrNgy+ekVg/DlE4msgUylqp55DhpyaK8m37Q wOLTHIWo98gPUa3BLlmPmPOPRQfH0Y2KN3EytFHdvrUFwggDLDo4smnw+flCATDGn6c5OK1x2+Fj 0vm6q6/++W92Ynb3c8Q7OIAoWqXFAICnT5+XFaVajDN4G+SVfrVzc+S8OiVGqeZ1yVNI93QLPGtL ABfVGgBAARcJp7tTxqnQRnQFOC3aiAjgVPFpnTkfXgM4OiPv6hPs0PbZ39DZfLu7dMABwWKUurra HI2uPgFjXIkotUSusWVwCLjiImv/UapFXewK6ZJuVcna7u/fI3SDOeBEugHAZDzUo41oOOiboI1I BTgWbUQawA0uL+urswkudmj7j3/1PyXJ9M7dtyKY8Z0BHFATt7o6C4SrBTg/KTYTOTFHHkjtzcTl qYtFId3Qzc+j0uEkOBZwUVRXrbtCUUMz1DB/UQNShxoAAABDDQDu3FoHAXB7e7fF1+sBBwC7+2+o VtGnoo1esv392cYkIuC4MxIp49goNSjAhWDZRFk/lT1Xp2gT5+Spk6mQuejmNrlm+I2uLsC9+2+S H6KoDrKFpdS46QC36No0jMPMVpROAFdvzOxbs8Un2vVo29ra5O6Zu3fv0VdSxpH5z3fvLhSSM3Hf fPMiIdPiHv/OfxqOXc8QJteoLPptKQ60IMC5vTrmhbSk23LkazWAE2NSCeNkAakUcCzaiNwCDhjG adD2ye/+tyRJpFeNi1LZpR0awCEET5+9IFFqKYADgO2wuUZlHliVS2rnUWoRmDYsJPrNb36TCRYh PCQdAu7uvbcQwoRuREkyUaXbFgCnzbWxjBPRRuQccACwd/seF6uyaDs9PVVfNQSAiYlDCO7eXTiK kAMczBkXRQhjXBbgaFd8dHLif1sRO+m7bgg3Fy1J/lus9EQ8+u1vf2vI6XCaHlwCDt299ya3ZQjW LgmYTEz3dxwO+iq0wZxu4A5w64xra7XWQMi1mZT53r1ZlJoKuMkkooUBgKfPXiRJ4g1wrCMoa98k O6m6bjiDIUQ5b7EQpk+jjz76yOR5Ah6Ta4ZyBbidnZ3W2k6tNt+EHc14JN/DEtUAYCJb7cCJcE0/ 2kABx82DswDcuhCQbmzO5rL9P//x3xuijej2/pv1aFZBDeNardWLi6s5g8TEkdlwhTJO+pStNOCC 8g2s7KJU/9VRoWCWd5P+OdhGp8r/eJlXEO49eBsARYtb3fKAQwt/VTFO9Gsaxt25tY4xRgjlBNz2 jXvsn6zRBgAkStWbuFZrNpwqAq64KFXfISsHOAKO0CybqEx3WVnVkYL4alSBrUP4XKOyG42SuVEE APcevBtF/Ek6GCcc16hEwGlCUY5xK/VZRLmzgwAgE+BoobnF9ts37rFcwzjJcwU1gKN0I6KMKwhw hh3S28ZwTuR2J+pCZWLiQoAGR4OFMdNgg1CNMk2CM7gA6N6DdwFQFM0pg2qgilLnIozTcI0VYRxF G5E54Gq1+unZwp69HODuvfkIELKybBJJo9TV1dV79x5ygTALOAB4+uwFYPj66//XyTo8cztQ9MZw TsT2w3AWtKdKU9RwHCgL4gXvVjp67WTSP7LUDgHAvTd+EgkHsqgYh3ENALjzsVSaJlEk27zcEHC1 Wh0AdIBD6PnzT7B0f3Qbodv7D1nAsVN87917k30pF6V+8823SYIB7Bln3SdDjlJFEAS4K5FK4r0W JjdIOdFvfvMb1q9V6EnCSv9UsWp9OeNYwBGocdIwbprwMS+HuVTAEbQRaQCHMX7x4lN3ve0qDbey snL//n32byrARVGEMX76dBalZgVc/nsmQMDpK1WVW49lcTiWTVQcx+iP//iPucJVpZU5FfNUWWAc xgtzIDRiGSdCjRNl3PbujQifAMCbb77JTVvb27vNoo3II+CALZUecABwcTEi6UsLwDn0AkEBzgQE Fbr1wrRsnORrFSrUyqxosV03PQKA+w8/4E+i0n74ZDJO5RrV9vZuNMdZhI9F+4Yxvn37vvhGn4BD CN2683BtdVYqlnEc4JrN5ulplxYJAJ4+fZEkSSrgnHuBEMYZMvXGStx6NEEP7nYJL0Jyujlcr+5Z RT5S0hmXYH4a8HisO41hW9hMnOBQBBz5ltIBBwC399+UAg7mjKOHZFPAwdzEkdlwUsYVd+FKHGew q1TgaTjuCRQyjpXrTEMutFS0J8VxXGTPILHqzzgqJWndl8WcCDVRdQZw7L0RAuBY8oqAo3QDGeDE KNVPjOM/Ss3pQwO8AVVXKsCiEulW0QdbaE5co3sxnjM23bn/MwBElznoGbfSXKvXU3aC29ykm+Xi /vk3CC0caE9kCDgAIIzzCbhmsymm4dgolQWc54MEvQHOFa+DugH1sA7Tb6bsERJU+4oK4GFyZcEI 6QCguZpyjjrHOIZoC1prbZwcfmoNOGBMXEGA49Jw1LWZA85zTtoD4NymDkOghjmsQ8NFCt2CTcCl tngZDY3Y/z98+79gd81dX5echyCeArO2tgkAX/7hrzHg9lkbAL/33nviIAOEAThYTMO9/fbbbCE5 xrGAQwg9ffY8SfBXX/5DKYArYpyhuBC7RGpkhXUIOKZK398tNB5X5kmyCKOUNNtccbyDEJydndHa IYTefffdKIqsAZck+IsvvsYYA8bPX3wKztP2CD18+LDRaADwNlMFOJJMJKvuSwEcODVxHlKH/jtz nkoFAg2j3SsDKatFcwdSckPR5yS/XM4WcLSdMC4ccO+88w4pWyrg2IFguq1IWSYuP+C8zWj1aYvy VyqEW890b95yvXGe1a8htHKqRHDnBxzXVIEArl6vHR1dsKWiq+4rB7hSZrQW3Z8dVqr0KNWUbqUk 4JZy7ImTpo55AEdecHxyyf7SA+Bu3X5ja3N2wBjLOAK4ev1q7RplXBUBV+5M/eL6cxE+tMS7L8O5 Cj5L6bz3BAg4kzraAY79kwZwGOBFAYy7feehFHD1ev3evQVPV1HAhbC40nl/LpTXZd192U6N8VDK glo5qMHfPEtzUgHH/RI0gAMowsSRbctu3LhB/kkBR85s1QAO5tuXBzuQGtTiSodxnwde+49SDz4+ yHwmVqGuuNwzJjzIemmOIeDu3Hkg/QQ/gGNrx6Xh2OOoVYCDUscZUgdSQ7BsovL3ap/18nMPHnx8 gBG+/x/uZ6ZbESbI2yOx9LER6zoaAi5J8N27b0g/wTngfv/732+tzhbWtvvwp3/6p9xNwgJOmAqX AjjAGGP8ZRhRalCWTZR1ry5rVKRQE3fw8cG9v7qHMAJsdZ6pQ0b4b99qzRviPkcKOJgfOpMwu8Xd vcsvbwCngPv973//v/67/7wWIQAgM93+4r/9uz/68BeclyTjDDtxC4Sjv1SAQ2hhPUO5gAuca1QW yCjXihZ0G87Qlsy327H4CLJSPWc54jje2dnpdDrszFUPclJ4Q7mtI1dyjPGTJ0+SJMEYv3jxgvv8 H354IX7Cjb0N9p8IoUePfvLBB+8jhAChNx9+CELOTiWMcS1Cq82V1eZKMp0k04m0ghjjwx9fnLZ7 APD8+fPnz5/TP33//UIJb97cvHlzk3w/Quiddx4ihBBCP/3pr8RMYqHCAF/s7j46Pd2JY//9007t dpscQGPyYtotS6yX89vw4OOD7/7iOxZtYEc3yFe4srhG5QFwBdVRCjjicZ49e2YHOMK4rICLoqjR aIzH47HB4YevfvyWAA4ANIBLkmR3d50WrETAbcfxy7ff3n/27NHxsdcvzieTjh0Hg2xSWjIGlVPE sj34ywcs2sCabmDFiNK5RlUc4IquowZwz58/twAczE0cAdzDh3+UumwsjuMkSUy4RvXqx28PDw/J zxzgCONoWM0B7t1334yiyCfgZvd/u/3F7u4Xe3uPTk+XA3AhWDZOmSynSlfRqFAtm7wblfkIQ5j5 C7fBv886ijm4t956izgdcddykxwczE5H/QpjDIABw4sXfwChv9A6Jknyh08/2VrF//O//S//m//u d6dd/Ecf/kI8LJHTzs7O7duzMyLYNFwURbdvL5zHKt35sugcnPQKBrV9uaHENFyYA75UdkMNV2Oj ifwBlItuYACIMLlG5HD813/vyQ84WGQcThKM8RdfPp7XAr94fgU48TqSH/7w6Sd/9OGHJMY1KbYU cASLJoADgCIYp++lVQQczHtIyDcgp0xugx0bVSkv3TRlqkSzOpkuVFY1HQKOnhAoAi6OdXtMkqlt mYrNAY51fKmAK2Ig1eTJVF3AhWzZRBnej9zYqEoO6CaWqRJco6rWdCGxDPkBd3R0zv6TA9y3L/7g vII7OzuN5uZuvAYApMD0Tz4Bl+kKVgtwtGpkA+RwFuqkSh+lpkajrNzQjYR4cQWPsifKCrgQuMYW Jg/gptMpLEIE6MblM8YthKgOdevOG7vxWq1Wg8UVqRzgFouHn1DAfZELcCa+5v6DdzB7F2EABBsb W9IXD4bDXq8PgI9ePS+iucwlVi2EhTqZJC2wSTTKyhndoIJQY2V4+YPiGpU14AjaiDjAwYKJKxBw N/dmuxbrAXd2tWldXsDpL+L9B+/E8WyaAmm68SgRXyZVfzAkZaRN1et75Z2malUEHGviDKNRVg5G FWhrVq75OOnLHybXqOwAx9INSgLczs7O3bt3yc8qwJHZJ5eXI1oqO8BJL+L9B+8gBNvbC0RjtdJI OSiD1WW3x/5zMBiQIrO8O3r1TREtmepGq3iHxnH82a8+M49GWdnTTdpRqth8rKTlD5xrVFkBx6GN SA841UyRnFIBDgBu377HTqzLAzj25r93/82dndkuJiLOtjb52HMwyDC5jwOcqMGgf3nRG41GFxff m3+sXoYDCEUv83Sug48Pfv67n7dP2xadznKdqepuD2qjIQtx5a8K16jMATedTjHmF3sSaQEHBZk4 DeB2d2+x/2QBBwBPyFQ4LeDY6/jhh/8Zmb/CHa0tEo2TBnCtFm/uzs8XphMOR0PxXZ32+Xg8BsAn Jy/ytKdFL62KC6HRqB2UM+/vltqOVWk4lSo3S4iTIeAmk9np0eLpfETiOEOAgIO5iVMBTso18qcE o1SisVpbW+/3JZBSiQOcVKenZ5PJBACPxxM7K2c95yPw+1Q6Npq1zBnOVTC/2wNvOL2Wb4REBBxF G9HSAO7w8NXpyVVKi9z5d+893Nvdg8UIdHs7BoDpNL38a2vr7D8zAQ4MGHd6OvMjFHMnJ89NGjb/ AzjYKFUzNpqJLUYn/lk0YhUBt8QjJCzgptOpuO2lOeBgPlMEJ8m3334WFOBoGo5M8lrf2N7d2ROh xkoKOI5onAwB12jMtl/vdC70rzw+OUmYHOhkMgYAPeYcTtMNraunjo2aQ1lHtzwPh2ol4F6HERJy k7/11ltJkiDZ8c+GgIPZilSyMRwuCHCNlY2bN7YQQm+8sbAZZwrgnrzAgDHGjfoEIcxuByByjYil mx5qrKSAozgTlQo4ADg+OQEADnOj0eT09DnbwkXkTMLp6ubTPkzKLKebkxYMp8n00jwGq1IFldjy 02tKDFFOwE2nyZd0IBXAOeMI4G7d3AaAVMDRS4cxfvHiCVcSFdeoms01ixJOJtnqaw44KkK6Xn9A w+3iVlaV3tUzLUIgSjVxPN3cPhlKbzK9XpNBEnEBCVm+bg24JMEAgDH+kl2wVSTgYJFxLODG4/Fg MPveZ8/+GWNcq808VCrXNjY25h9iOl+32VylP3e7fcN3EakAh5iVtsfHJwCA8UJ5ut0eThKM24Wm g0tMw2VdhMBKc4de0a2gUcIw6fCaDJJo1sZpAAcKxlHAEbqBF8ABwL17s2m9IuDoVLjPP/8M5mnB Wm3FnGtUqYBjuUaVCXBRrdZun6e+jACOE8ZJ97J7woyZFCT/vd1iEQInVZnRRx99VOjsh9AScBaV Da0KhqJRjKr8FoADgONj/nAGAKBRakFpOCngNjdnqws+//wzejXjOI4iZf4LZFyjkgJOCjVOGsZF tRr3G2vAAUD3spvg6anZoKq1vAHOIhpVSWo80W9/+9uiZz8E4n3yQDyQKhhKrKmq/FkBNxyNAeDi nM+pMybOH+AwxgcHP8CcsMB4VYQa4odouEZFAWcCNVYc4ESocUpnHIbj42PZF/UwJCfHxZo4D1Fq nmhUJX4kzckq+qzf6lmvzyCJxSLqTIAjdIM0wEEx4wws4AjaRK5RsYAz4RqV3vpp1O32U6HGSgI4 ocHkgOv1ADDG2APjCurz+aNRlVgue6IblESH12eQJM8ICQUczA8PZP9KAUfRRqQFHBSUhqOAY48E EdFGhFAjE9eazdmCqvFYsgJXIwq1rOMM7fZ5agtxgKNJz8FgAICPjp5WC3AOo1GNSLH90Q380uF1 GyQxnCigBxyoB1I5tBF5Btx8kOEB/Y2KawCwsbGFkKmTolyjMgScaNbMAUcaqWOUhjumUGM1GA4A 8NGrygCuiGhUpTiOvdLNT3q+6CWiQQHO7QpqTZR64ya/4RoVx7gixhloNT/44Oe0YHq0kR9SASdy jUoPOE0Qmgo47lrpAUe3cjk5ORV/P56MEcCrV/wsP7dykoYrLhpVySvdoGA0eFv6HgLgChokkQJu NBqRef937z2UngeoT8MlODn47nPr248605/97GeUViZoI9IAToM2IingTJJrKsBprpWUcdwuVSzg 6J/IAtWiAQc5ur2faFSUb7pBMWjwv6VHiYArepCEA9xoNGL+iCwAl+AEAFsAjq3pz372M4QQQGTO tatCC4BL5RoVC7hMgwawyDiTa8UCTrr7HswBx/6V/IxxEibgfEajnEqgGzhFQ1lbFZU1Cc7P8mkW cMKpzJkBN03IrZgBcNxlnaMN4ng3K9pmhZ4DzpxrVOPxNCvXqLrdfqZr1Wmfq7hG9erVEftP8nqE UJJMMcBRSFGq/2iUVTl0c4WG4pbdGX67T/vmefk0Adx0OuWWeQJAVsB9/sVXdJzBBHDcZaVo29zc BIB6XTJjQ482otXVDOOnVLVaHQBG40nqK0WRGmQaSE2mSbvd0byAPmzOzmYXjtIQIZQkCQZcNODA oPOXFY2yKodukBsNgewu6QdwhVZWU4X79+/Tn7nNiDSAA4Fx5Pb78qur2XAqxok15dAGAt1MuAYA q2T7XJzNghG0EWUCHHehTACXTBdWSkgZx/loAjiWbuT/02RSLuBKjEZZlUY3sEVDIFyjWoJxkkIB lzDnQM8BB6KJk9ZURBsRBVw2tM3KYQQ4lmusTBgnvVZ6wHFoI+IAJ6QIAADOztoi3QDBdFoa4MqN RlmVSTfIiIbQuEZVEOB8xt36KlDGiYCDtIFUSjdQA05aUxXa5gXeU4GV06pw6EEq4FRoI9IATn+t VICToo2IBZyUboPh8PJitvKXyUgiQJBMJ37GGWgaLoRolFXJdDNMwAXLNSq3gCulvraAA30ajqUb CIDrXv4Asi1M9GhbX19vGJzCJ+HaVTnkgNNzjUoKOMNrxTFOgzYiAjgp2gBgMJx55MuLS45ugAHj 6eHh46IBBwBxHH/2q89CiEZZ1R48eJD+qsI0GAziOJ6f+ShRHMetVqvT6fT72da4eFZqRQxVYn31 VTg/P9/a2gKATqcTx/z+QhcXnc2tbQng8JTb5REhdGNv9+aNPTKzYWVla2Vl67yzMAiYijYASJJJ rSZZKk+lQxsAIMyu5SIyRBsA1GrRdMGTGr4PAGBlpTEeTwAgmSYmT6/V1dWLC+XhDJN5WLrSXBkN R1fBKRDERZeXkpWqzvXkT578/Hc/H/ayHTpRtEr2bkRS1xC+XxOVx8EFUl+3Dm44O5sdBgPeoaii VBO0UakcXArargoxc3DmXGNFHJzd5bo457c7Vomm1ej5MlTUuFF1L+nHotmlwMmPP35dqH3LeS5f cQqCbqDYI7tCXCOym+kSWn0NAQdp4wwUbUQmgPvFLz4kN7MUbSDQDWSAM0XbrBA1O7QBAMZ4lHG9 PRGJRk0GUrm5bxzgRLr1e32Y5Tpn9q3Q+NTJuXzFqeTIlKrVapHIqBJxqEoW8SlJqAdVX8MQFWRR 6sVF5+Kivbm1PRyMuDfW60gapc5XF6Gt7Zsb6/UkSczRBgBsfLraatUbunBVVKNRx9gmBT7fBzia yta3a0QTbTRETf0Wqlar1e9fXZeJMO93Mp4AAEIIY1x0fEos2/aTbbTYgK6yNPkVindbglNEqQyf XaFZNk6ptdBHqXt7+9J3SR0czGfDkTv/4cNt8Y1StBER+5bNsgE06lccTBI+B6eXeMkMTZx0DEFl 4jSLFk5Pz0TjBnPvNvsugl1ETJvj+NThuXzFqXy6sTd5OJ42p/QVCZxrVNaAGw6HAOjuXeVsOE2U KgWcBm1Em1u7+hdwYtFGZAg4zSXTA04/NioCLnU91g8vfxR/ydJtmiSIiU9dAS7TtI9y7+gyI1Mx Dg3H0+aUqiLVCr1TL4d0IHU49xQXF53NTdlAqjZKxQkGgE5nGMezvb9T0dZqrSXJJDJOn4loAwCE cGqIqn8aaaLU1GkfXJSairbhaLS21hJ70YT5EFpahAjlUP74VBWNqlTuHV3mSqxlPUWUiqtIuati rWXu4ADgzp07i39EAKAycVIH9/nndFEqPHy4bYI2+nO9kX4YghRtVBoHZ3jhRAeXijYq4uBS0QYA w/nGLeyeSKxxAwB2zgpCKL99s16EUNYdXc4OSPq4rKJnUElFrmtVQlGVTAA3nd/D9+7dFf6ujFJF wE0mUwD46qvHGONHj/ZVO4IQsWgj0gNOjzYiKeAyXTgWcOZoI6rV6nR5vErDET9iQxinoRsRAmQH uPyLEEpJw/needzwJl8a+7Y0oyUmV2R/f8a1TICDRcYRSmKMv/rq8U9/uq+Bm4g2IhXgTNBGxALO 7sIRwGVFG8xn3ukBJ9INAE5OTlPpBhgjFGWdIOJwSbzn+zrbUJG14jje2dnpdDpnZ2cm3YX4HQ8F K06kyuRaVh1tYHZFBoPZ3fX99z8If8Q//PBCdUetrvL9ECH0/vvvffnlS1XLqdAGAJMxn+Vp1Bvm aAOAKLpa+W/+LlYrjZoFDOjMu50dZVNL0QYAe3v8uEotEu5uhDBOEMpw119Foy66sOf7unDvVtAG 2YGLS7FVtyKcVBVhrzJ1cCAxcSlpuClvdi6k3k2DNirq4DJxwarLSwAAIABJREFUjdV0ar8UnA4R TKem3V6cVCx1cCq6AUD7rAMAl5dXy7ak9g3MNvItbkm8tyi1wDHT/OODZIqv21IVLVprluZLPBYs XuXLyws6Hffi4mJri5+aqxpLrdcRdxp8rTYRH4omaAMAMopqjTaAKIqQnXVjRz8NP0S6XqLVWm21 VrluoxlzGAyGALCyskI3i9dYim73VPUnyD42mkmDwcDPHVEI3VzNe6gWFPS1rlZdNGIrolpocXl5 QRmXCXAAk1oNJ3OzEEVjYbK+EdqILDYZnyuaFyAz4MTlB6kfol8KxgJOY9xgTjdgACeh29wMr6/v drty9+RngzYPd4TjyNTz7tiB6DUcLTGscqZxBvZ4mvE4AoBarQvMDnGZ0La5OVsuxk2sM5AkLWUY YGpWVmk+wWShK4lSdWFpuyMGmp1z2VmCs+AUv3rFjy3436Ct0DvCGd3K2h27dGWdxRZyXUxEL3Qc xyapEz3ggEnDLR6+BeNxROgGc8CZ042ijSgL4JQZ91TApS4alX6I+Rr+Hw9faf5Kkm6cTs9OJZ8/ pxt3TmBZ24UXl4ZzMGaadTzUQvpJT2WJVjxTrSs9HExQTi702dmZSUVevpyNn37//Q/CWCqmY6kj wZU0Ggs5OGu0AUC9bth/dLdDrab7EBO0iR+SaXuS27du3r510/z1RNOpUDCEYHZPXRXG7dhoJrXb bcO+lFW58m7e1hWFlrTKWfHXbbTEJA23tibZFwTj2Z3ZaDQicX6DTCLaiKIIieOH3EtSP1yVQTNE G/chmdBGm31jfb3b7YkvGAxki+oHfQDAOME4kTZgt3t68PFB573O/b8qebvwIu5x+8jU/7qiEGI6 VwF4CHUxl/5am9dFFaUOBgMAdP/+W6ybSJLZk6Nen1HABAcquhGpQ9QMQQwXXWZCG6MMp3OJLX+4 eKSpNOkGAKdnCwOjVw3IBqdHjwE8bE5uJLdRqk1kaheR5VfpMR0bl+X8qNLrYiiTa21eFzZKpb+c P67xwcE3BwfPNPeZJMhalB5toAxRs90FbHRpizYYC1OOM4mPUs3642QyP5yBDU5DOgnBbZSaLTIt fYuLsmI6aVyWU6GF25wyXWvzurAharfbazR4O3Z+3t7aipNk9lHUuBGpIiwwQBuREKLaPOBJdJkD bWMASJJJkkxSDammy9EoVRqWwjwyZZUkSZIkUXTlHDVTQ8qSq1vD9NJ6GDowUUHZR40KrXiwDs7C pRrW5Ze//OX+/p13332nVqsBwJlkpA8fHHxDfuLQRiR1cIZom38sNV/2o2rj8Qgg8zJSEE63ym/i LN51ZeIADA9O9Cwnt0b61Q2Ea1TeiOCn4qEBLk/awaQuCKGNjQ2E0FtvvUmGwkXA7e/fkbyTEQe4 TGgjqtdRHrQxXikb4KQH92kAZ3IVJuPxxkaGmYCzd03Gk8mYXIJbt94NkHGkO5F9KCwUx7HuAofG NaqiieC54uEALn9i0bwuCKG33npIAUcZt78/2/VIatyoKOAs0AYAN2/eunv3lsUbQRIGmgJOdSYp AIzHg5wmLjPgEIIrExcc2ois03CkJ8s7UPj7kRU3A66UPSYJFEocRXV4xTV1+eUvf8meCIMQevTo ffaf9Gc92qis0Ua+6+7dWz/8oJsiK0qR4UpSnaAGbcxrBg1m+6as12JjY+3y8mqyyFmbz6bNT5NZ UHM1s+/zrEx3B9uT+UsSrF/jVEQCrqyxYKKyZiwXccVVDo6r4+rqKmKU9Vs2NlK27ZWKoo0ok4NT Je8BwC4HJ4o6OMNr8cMPL9l/bmysURNn+Am97jkAvPeTj8KcM09kGKVywUfE/qESXKNyGNCFUHf/ AybgdI4LJ/Hq/PKXvzS8fwyNGwBgnO04UQ5tRIaA06KNKFExzsS4MS/OEKJKL5xFGi5ktBGlRqli 1BVBGPe2nfIDLqi6+0zAeTCqXHXIeAL95+qqfAddQ7Rtb88OzTIHnBRtRKmAM0AbFQ+4TGgj6py3 zy8k60Y5ccaNVVbA9fvdsru/kVT3iDShFIVzb9spDxGKcy7W8gM4bxUvqDoUbUQmgNOgjUgDuCxo I7oCnAXaqFIBp798Yc3TdSexU6ly5fUlOJ/FwlSHPGxS6AiD/4rT6rDGTSUyCc5CGE8R0r3XpJNI Bxmyo40oAYjs0NZjTps/v+hsbUrOrjYXAoxDHRK1Fj2Jif5T2p89natQqDJlrIIKRVUqwvKUWHFS ncnkapKaKiw1EWfcqDQO7uZN06GDu3cXZorYoo3IZpyBRRvR+UVHauI0YSknQxMX+MACJ/r41zyq l4FuYIaDSnCNyi3gSo/BTW4bYtz0JVShjUgKuNSYVJT1VDhW3W53NBqMRm5W2omA0zfUwcEB9xsJ 4ObNQoZNK4Q2mO/dcHZ2pukSS0I3SMNB6be3hZwArtxpLlQPHjygN0+qcctTVA5wFmgjunv31nCo 2+Zbr263S382B5xo3FiZjDNQSdtQ7+CqMrAAi4k2zWSRDDtMhS9pPw45xZaqPI/TACs+mUxUQ6Jc xg1jLNZdb9yY985ycNZoA4DDw6NWa6XXs4lMWbQRjUaDlZUUpuvRRkQAt7W5bR6WchoOBwDQbNpn BkqXOIZAolQxW7083g2EBFy1QlGprCfBVdGrcuJKboi2+XunOdFGvn1trZn1vSLaiFyFqABwfpHX iRPGiQo/9aZZSiTGOkvl3WBxMCUo22KtrEOoAVo2AFhfn60rkIalqqFS6uAyoQ0A3n//pwgh2QYk 6aJoI1pba9o5OFEEcFITZ2LcqI5eHWGMWy3lUg0x6UbUZ/YUmpm4lQV8h4w2k47N3SxL5d2Ilglt ROYJuPAtW575X1m1s5N5LgWHNqK1taahiVMZN1b5TRwpYb/f7fflX2d+9Zura2SdKRlYCFbmHZtN w0WB7E7hRKRWhNzB3t52SgVcIKMHJuIAp5/jhjG2M27k50yAk6KNKhVwJmgj4gCX1bix/1QBLpPo Qvp+v/vo5CQ0/5Z1Ywu6ZisK2Yuai0uxlbJms2hp1qAEnl788MMP83Szi4sL8xezaCMyB1xq62kA Z442Igq4TGgDWSFdAW59Y3N9Y/OL3b1Hp6cfBMM46z172u12VHUQqO7tcDZNcyjVGpRgucap2ZzR wTw+Jc4uE+BE7exspzLu8PBI/wIiKeCyoo3IYjYcZ9yo2ChVlXQzFYIvdne/2Nt7dHpaOuBybkcW QWVBkOpZKlovvagxqVAoKhUBnPnSKxPAicaNlQZw+piUk8VAqkqdznn3MkPCS19IArj8/QEDYIAv dnfLBVxOtAEdVahcfGroWSpXr1QRrx14KMqJDphmFcc+PeD0aCOSAi4T2ohYwNkZNwDodGZcMwSc yrix6ve7k4n9JGRWJQLO1ZN7RrcKxaeZal6hehmKznepBNf0StLOTxalApwJ2og4wFmgjYgMpOZH G1H3Mt3EmZTz8PAQAKSA62c/YqoUwDlMtlzNCAk/jrPzLOHXy1Bs9ZeG2poEnCpozZmDAwZw1mgj evnyZc7DEDhpAGdi3IAhoHMH52ecIX80ymphvluwcVzOWGwJACc+0CpXKTqkkF8c4MyNGxUBXE60 kbdbAI4zbqxUgLMo6mQycsI4AjgP4wxu0QYc3cJ0BE6carDgTpUmEq8K4PTnPUvtW+poAwWcBdqI jk+M3JBK7OXIBDgN2ojEKNXQuJGwlJMGcFtbpp3HwziDc7SBuFYhqBvG4bBgmODWy8SxBnW9Monl l90Chjwh6uMnTzDGacfAK/XyJb+IPf+RfZxYwBn2f9XL1CYuG6mKA1wRaAPpSqwQbE4Rw4LVAkHW pSd+SlWcWMCZTxMZZM+Uwxxts+/KDjgak4pKBVyqcWNFAGdo3FLl5K52DrhCJzZJ6FauzSl0ukMl QGBxvUN4IOmlD06Jsjq4RqMBAJ9++knOflKrZ2CcBm1EGsBlQhtR9/K83780eaU0LKWaTBIAQC4Y 5xBwRc9Fl6+iL4sCHmbeBw44uxaoYtytUtajFTDGmQDHGreF7zUAXCraiByGqKenpwAwGKTPO8nw LMzNOCcDqQVFo6yUe4R4tgM+Z96H6XRytkDg1AaAXu/qmHQVwsztGzFuROaAU6FtVqo0wJlfGjEN Z2HcTk9P6TcOBl0N4/TGTSongLMeSPWANtDQzZsd8D/zPjSn46oFwgdcqpIkYSFoLhPA6dFGpAGc OJKQKgo4C7SBDKYqwOnrRcJSUY2VlcbKikXBZl9qG6X6QRvo93cr+m4pcUVROCBwG4yHUy+pDMmV +jLWuFHpAWeCNiIp4AxjUlHj8cAObSQmFWUSpWZSfsZlApw3tEHq7pXFBXGlb25ROggKCsZLr5de +QEnRRtR1hycShzgrNFGNBz2hsPMhlTzjVyUahGWAsDO3sK5Xzdu7jebrWazZfFRhoDzv+9DCt2K COLC2dyixARcoXAPHHCqpBu37NRhiGpu3KjoQGpOtNFdsDMBTmXcWFHA2YWlXOfPeS+kjjOU4mbS dx53eKuEtrlFKQk4P3APGXDm2BJfqTFuVBzgLNBG9fTZ45xoY99tCDh2MEGvwaD73Xcv7MrmXJpx Bp/RKCujcxXye5zQuEblkwKeGyGcoeFPPuHNVB7AmYgCLg/aZgUwm24mikMbkUmUmqnAGGOHp21t bGY+iWKhMLIotSy0gSHdcnqc0lNsevkBnP9GCGdo2KTKmt2QKOBMjBv7pTlzcF9/PTNudoDTfLMG cCYxKdXR0TH5Ies2v1zSza1YwJWINjA/E8sOAeGk2PQq1OaU2AiBxKfSMmQ1ZZnQRnRycvLdt5aB G0UbUa9/mYlxqSc0qgCX1bix/xQBZ5h0i+M98sPf/af/xUkvxQAv33770elpp9Sj6TKc+JcJAcGG olIVZ3NK962lA460gPRPhcanNHv13bcvsjKOQ9tVMcwAJ41JRYlRqp1xY2VxVgMA0Lm9rnppHMft TsfnxnBSZaCbIQKqxTUq5xQIx7eWuK6OtsDlpZwLBFupm/SOx+PjY8nNrBHX7OaAU6GNKBVwhmij ooAzH0wg0rzYYSbOQjQa9bYxnErZTmvW3ycV5RqVKwoE2A7+AceZ1qdPn+ZvCnPASU2QdZTKSQO4 rGgjIoDL1D5S48ZqNBpMpvIPVCXdcg4pEHGJNg8bw2mU+Sx6VXxaegjmRE5Gh8NsB2+Ak5rWVPtm KBPAaUxQKuD0xo1KlYazvuYvXx5kmhBn2rsQAqFLFz1FXyxbWYDLTDcxPg0nBMuvPAm48NvBA+A0 cB+NlJvEZtq89/j4WM84fftrAGeINioOcKkjCSpRHBsCLtW4AUBUY/Z51+LM1ZCCfni0FMBlphvI jtQM0KpYywIBFWqHQp/berhjjDW76ZpsAMdKBTiTxLwUcFnRRkQBZxeTguA0UyfEHR0d2/QxmYmj fyP/s+66hs91/4CzoVsVj9TMpEyACzYUlaqg0WGTRnj27Jm+iaSA0+yJJALOPDHPAc4ObUS9/uXZ mSXaQMEUDeBMyrlg3FghtHdz37hoRsrU/1MXbLmVDd3oGH8l7mc7mXic8ENRqdzGp+aNQF4g2jf2 jTkdXKYLYTFTRKVe76LXsznkQeM0pSbOJCbVCyEURbUoyrZFqEoWk3V9DqRmo1tF72cLpXqcalk2 Tg5HhzM1AjFi5+e6HYFYwJlsZkkBl2myGNV3377IY9wAoH02S7dlBZyJ0+QAl8u4AezduHP1sqgW RbWdvdvkn59+8tdZG8F6HYK3gVRTuomhaDgLfQqSCgHLgficgLNrBMN5IRYO7uTkxO5yHB0dXZxb jgYAQPtsYS5+JsAZFpiaOCfGTfxNVK9H9XrW4d78S6w8AC6dbpoUW+nz4IsWV8ElyzZaXz5r30pe nySJ3r5ZqNu12dPx6Gh2Fv3lhXw1hV4c2ogMo9SsTnM47OU0bg7lavVo0YBLoVtqPw5nI4qCRBFQ 6VBUpayAc+hbU+NT8zMWyIy5rICjaCO6vOhkYpwUbUyRdIDLuiwBAC4ue1ENRTX7240NS4ninRvk h0/+v//TsDzOA5dCxxmUdDOsxtLHpwCAEFqCUFQl8+eTE76bM8swPmUnA2cCnLQWhoDTo21eMLmJ s0Mb/VkDOL1xk1xolG0uSEEP+OLGGSR0yxp/LXd8GscxmaW5lGiDLMuHnfCdTb2lxqdZE3BgDLij I+URyKmAM0EblQi4/G1oYeLyG7dC9zIqaJxhgW7WeaWljE9Z97rcFtVw+bCbvXEWP0QFOGrx9ICT ruJKBRwXk4rSAy5rO7CAsxjYZY0bK45xhRo3P9u0OQfcFd3y2M4lu/mllF9ui6oZIHYejHz55ZfT 6ZT+07ODS0UbkSoNR+d/ZBKJUi0GdlVoozIxcaJxyySfO1C6BVwEjh7OS3Pza+7npbSoVKoBYufd WvxAO8Dpl993u12RcYZoo+IAlykm5XR6epp1Qlwq2oiiGkKR7sg+sd+ah6U+0UbkcJwhcjjFoeo3 f+r9vGQWVZS3AeIvv/wy6ydzgDPcWYQDnEV1KOByoo2813pVQ6owxtLiyY2bQVha4rxOV+MMkcMe XOmb3/B+XhqLqpKfAWK9fVONq1qEqMAATjOSoNflRefs1P42EQdJTQBnaNwAAOMG8zPPODvjVvr8 JyfjDDbrTDWq4s2f9RlVxToaigwQn52dbW872MhQr88//9xwhIEVAVzWjci73W7WmJTV2dnZxUX7 4sJySYP0e/Umzg5t7DfqKptm3PxHoyrlBJxjukGl4tPrMWIqDvEeKogxJgOI7HeZAy6Tzs/PJ5NJ 1ncRsX3DAnD6QdKColQijPHOLr8NLzVuW1vyJ3Q4aCPKAzj3dKtKfHo9RkwlNoWfCkqPeTcZYRgM BoOB6dEB9APZgVpDid0jE+BMJu6KJi6ncaPa3buNEEqSZOHYivmz5P/+238vli00tBFZA8493SD4 2O16jJhK0xR+Kii1NoarUM0BRzWdTs0Zp3ryGUapmdYkUMC5QhssmuJkLnylhZN6At8bwm4gtfbg wYMiStNqtSw6X9GK47jVanU6Hbv8NKfBYBDHcYDVNBR5UGuawkMFLy8va7Vaq9Vif5kkyXA4bDYl 01O50k4mk3q9rvl8KSgxxlGU/lzXd5LRaNBsrqr+arHcajweDYYTulOugXR7tBHjxv0y3r1JfvnJ P/0lW7zUnhCIjlut47W1R6enx4sdRqVCvBsEGbsVMQxU0QSc+YO60g5O8wmpDu7s7Cz1q1UmzgJt ADBNyM1o9EaTmJT75QLamFg1zGhUqqwDqUXRDUKK3Ypz3QFCPFVZKV/0dXz58qXqTxyeVOZCCrhU OGqi1EyPQA5wdmhbFNYzLlNMKvml4NoqgTYqc8AVSDcIw9oUPXMnHIibyK43e6ijamzRzsGZ7x8n As6iq1DAWaNtbtxYyRmXirbd+Xa7rOLdm+QHNiatItqIDAFXVN6NqNzMFM2yFX39KpGAy9kahdbx 8vJyc3Oz3++TBBx3ND3JwaVmhdgc3HA4NP92Ng1n/RQcjQYnpye1mi4JqJIMbZzYuzhfum3ettVF G9Vxq/Xo9PRmr3e8tiZ9QbHeDUqyb/430Q3cwTkxsIVeShKfOnFwFhv/EgeXp33OLy4xxoNh5sS8 AdqAmjgnMWngw6PmSl2wVTjd/GemylpEEkIYLsphV/ZzKVWAUx1lz+n4+FhzLLT+eznPaK7zi6uy DYZ9c8aZoY0IA04xhqkx6fb29jJtnQ9p4wyF0w08+ppyH0oBjjA4B32hl5IOL4iHupNIMxVw9AVZ Adduz1bIWzQUizYqE8BlQRsAbgAAAowUAw4mMSn5eTm4xkoFOB90Ay++pvR1vxBSfFoc6MsCHJGh g4MsgOO+K1OLSdFGpDdxFmijkjIuNSali4gD6aJuJQVcsaMKVIXmpL2NHpgohBGGoidnFj3CsLW1 hTEeDAarq7PpsuzI5mg0WlmRbGcmgm86ndZqKccSqzAKBo9kDdqoJtPJZDqp1xfwlAdtVGg21oDA wLhtb2/TGySELlqQuHEGT94Ninnm+x89MFGJCThvsbkfl6pxcBzLVJ5uNBppTJwGbZBm4kzQRsWa OCdoo0KA43gHT/k9oxbQtrXFdYlwggy34sYZPHk3IrfLs4JdPlLWs9FzgxRXTWrfyLeonhbUxKWG q1ITp0cbK7EAmdBGREwcirKcN5qGNgCI410ECABwMiX/oagGAK21DQCYjEfjYbvTkey7SS5fmCsm 84uYOPTRRx/5/NZ4fsRUzg9BCNFMcJhyUlPz7yqrQYqr5q1bs917arXGyorNPDJONJ61KPDCNk3Z 0UYURU0AyDAnLo1ucbwrXZe6vXuT/P6fP/1bbrW87EP8dVSfQj4jU6L8ljiE0QMT+RwpLrFBigvD X716RX8ejZS7s42MD0glIardnUzbNifaAGA6nUynBpvNWaNtJwPaYKmjVN90gxz3Q+VmIRadgAuh QQodg0sFHEGbOeDOzy+jyNIGjsd4PLZs50gISFMYlwdtKAPaiJYScHEc+45M6RdneoRWIhSVqjjb H9RKmkKjm1u3btVqs7udDVE5qK00UogwGFwNLyRJtq16uZ19+wPTQ+9FroniY1W/aGM+dnlCVHJ3 lODdIOOzoiqhqFQFPRWDQhsU/PCXOjjRr43GY42JY9EGAFFUNzdx4qblrdV1kzeaoA04H1cS2mCJ HBy9O8qhG5hFbSFEXvnlttME2yYFz/L9nv48Gk00FBP/NBiMOLRRpQJuMpGgjai1uq5nnCHaqKbT CZ6m3BTFoY1oCQDHPvhLo5s+XxPmRDZruUrABW5jvQEuilYi9fnELOBUXGM+Sgk4k3NmVIDLirYI GhE0AAAnE6yImotGG1GlAcfFNKXRDdTtGPg9bKH8qfdgLRsnD4CL5jm4VMClom3+OXyUqrFsojgT F0VNC7RxvxEZ5wdtRBUFnJiuKZNuIJiaqtzDFsrTY6qF+4I3Svr++4Pn9J8qwEXRymSK6o0MlKGA szsakAAuK9dAhjYqyjifaCOqHOCkmWivaxVEsfPdg1174EoWk/uDWkJrqEKXahx8fNB5r4N+j7c2 Z/ceQjWMr1ahRtEKQlfLEqJaPUlMD8GKas0oakxtTz5tNNbr9YbRXDbyddBA2q0oiTZbG8lkQv6L mPWqBG3Dfu+rL/6TW7QRVWg5qmqQrZwZIZyqO+Ejq3Z2dkyOIyEKbWA0k4qYXnDw8cG9v7qH5htk 3Lv/pvl7J2Pdbr0oWjBQw0HGRyzi/dcwbQckjWWj2lzbkv5+Y+cGsXJPHv8DOXjerJQ2Cn+aiOY2 KZluhGvAbLC19DLpLsuBe7c3xgxtyUKA9uCNd9iQTT+LTQo4jmusjBgncG3hE2SMM+EaaNAW3wCE To6/8papIL3R/KnsU3oHUCbd2JKF/4hwKH1lK23ZODm5rAcfH2CE7/+H+xzaAICg7cEbb1swTsM1 VkrGabm28AkM4/KgjXANAJ48/ociQlG9ArxDU++U0tYqiN4kwOYrTtLKLodl45TzsnLRqEIoE+Cm 02xokADOGG1XHzLs54pGvVs2UUHdoSYmoAS6qYqVKSe1BOL6yjJZNk7Wd4U0GlUIAcCDh+/B3NRw gBOdmj4TJ2rGuOxcAwA8Hz2YaA/r0lu2ctFGFALgzE2AV7qlFiuEtvMmSvOltGycsl5ZbTSq0Zxx cx+nj+CyAQ41IPuAA1aMinKY01u2J4//IY63A+kh5d6kmUyAg22zTGR4A4d5rFRBIlN8l55rRJmu rFk0KhUGgO9ePKaAQygCNePIhDgd4wSn1lxtgRnjVFybfXWzCXPGpVq2cNAG86lwpQAua3zjY76b +US2Ck2xcSJyOPEST/GjMr+yWaJRpc47p+edk+34JuEdQkh6rjtRVKvz0+JQA1ANkBJP9XqjXpfP jMNQA4gM58mvrm42VlYxQhihiCnhRnwDarUnX/99kly22+3Qekgp96lF6qbYyNTOm7wO8SnbMq9D fYn0NbWNRjUigepPiQkCPE0JVCeZByJZE6c3a6xW6i3Vn7Z3bjz5+u9mPzNHvQQon/3WLitdYGRq nSZf+viUa5mlry+VJqjJEY1qRALVL8k/Hjz8KTlzQB2o1gBgYrwXJswDVcMFraDm2vbODUDoyVd/ d3T0mM6RChlt4DFEtSdJEd4tfzppWe2MqmWWtb5SiZV1Eo0aaPb5xM2lDTikME7q1FT5uFSoERDT XhE+2qiK7rp5msIx3RymyZfvhtdfp+Wrr0a0sgVEoya6whzWekWWceaBJzCY03Dtydd/z0GNqEJo Iyqu6+ZsCpd0c3tVlmn6myH0XzfAffarzwqIRjNphrl7bzySbsJBNZlkCFe5E0uj5MokEqhhjBGS nJda3TH0Irpufp64oVtBV2U57nbzi7RMQE/VwccHP//dz9sngVxfI8xJGZd6+vLJ4VekJ2MMUqgR Vc6ycXK7HNVJa+SlW9FPm0oDzqJxKl1fQ9FodHd7Nzya6xzc/oMP6AvGY8l0kJPDr2SXOn0lddXR RuWkA7tqjVx083BJqmtnrBtnuQHHjY1WrbKpyUGbzMPSoI0o5zV12BqWe/N620S30OMyC1LOxqnc tqjmuhobnTdM1SqL0/7TSVrZJUMbuNiG2lVr2NAt9rsRdrVuACeNs5Qz4FTTPqp1fXNK3Gp/ydBG ZHdNnbdGttm8ZY3pVOJud9g4xLFWKmTTKXXaR4lLFz2LXtnqDo8aKus1LQL0pnm30i9G4L2/iGsT eJUNZb4IYTnqa6JltWyiDK9pQQ1iFJl6DkWlCjl+KejahFxlQ4mJNo2WoL4mIr1le3u77IL4kMk1 LY71KZFp6ZaNVYDxadHtE2CVDWW3CGHpQ1R6Jy99Tan0NS3UxuroFpp/Di0b5aF9QquyofIsia8u 0FPFdZhrwBV9B8kjU28TPrIqkODFZ/sEUmVzZYpGRVWjxSUGAAADbUlEQVRxDpCJpHdy5S6utcSa ejAHvHcLKhSVqvRnu39LW5WHvKsl8VWpr6H099SSVVYjtqZ+bqKFMdPQQlGVyuoN5aI/8HvA+QZt gdfXUIb31HJU1kQ+b6KIfmWYoahUpfj50geOSzetGuWMRqVagqjN3C4sQWUNRdDmZ8i4DtWxbKx8 3uqBROthjjAUukFbpaO2rLdVpStrqHi2V4qnIWP029/+tvT71k5+ukJo6A/qBihmu3BeQVXZUNbd poqVNZTYJkVXNir9/FdrFW3fwozWwwlhiohGpQo5JBeVs9uEc33dqpQhY0/nmRahQiO10Cwbq9Lv ds/bhYcZkkvlpNssX4iqaZZCK+v1LPoi5LxpAsmy6VVi7/cTjYoK/4Z3+0QMv76GMmmWgiprub9b OHJrZEofGDVUWfGLt2hUVOAhm3OzH3h9DWXYLAVVtvLeDdxtdhy+ZePk8/Fe0uFVvMJ0NMXlMcKs r6GyNovzylbeu4EL8FfFsnHyloAjlu3BXz4oF20QpKMpNEUbYH0NZdEsziu7DHSDfPd5yAMIevlZ klliNCpVODe8n1H1cOprLut7ym1ll4Rudvd5mHM+Mqnoru/rlPhsCuGG9+n3Q6ivofLfUw4rW+EZ IZyyDi1X17JxKmhMPZBEm0rlTovx33kqMU3EVbO05zuz5zwPb3noBsY9vooDCHo5v9XLmvZhrhIn wZX1XAwccG6bhW4lkqe+SxKZEpnEpxUdQNDLbQIutESbSiVuplBW5wk2RC2oWXLWd6noBtrmWIIs m0ZO+v3Bxwff/cV3ASbaVPJ8t4eQzQgQcMGOGi9VZEokDdNC6JdFK2fkEn40KpWfeC2obEZQIaqH O8u6vsvm3UAI05bbsnGyTsBVJRqVqmg7E2A2IxAH58002NV3GdYqSBXPz8R9TbhGlfUpF/jYqLkK sjMhd6FyHZz/lsla3yX0bkQIodfHsrHK9JQLZxFCfhVhZ0JGG5Tq4Eppmaz1XU66UcYH2y8LlWEn qHQ0KlURWyoE3oVet4HjTPVdtsiUy/6Gk3z1L03dlyYaFeXqilcCbVQ++3kILWNY36UaMxXbvfSN HkuUqu4VHRs1VP7xxKCGRw3lbRQ1BLSBcX2XJzKVtvuyHv1rImndly8aFZUnWAtweNRQHkLUQNBG ZFLf/x+azoveae3jGgAAAABJRU5ErkJggg== "
+       id="image3787"
+       x="2.5000002"
+       y="400.93362" />
+  </g>
+</svg>
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/lsr.css
@@ -0,0 +1,240 @@
+/*
+Author: Peter Parente
+Date: 2008/01/22
+Version: 1.0 (modified)
+Copyright: This stylesheet has been placed in the public domain - free to edit and use for all uses.
+*/
+
+body {
+  font: 100% sans-serif;
+  background: #ffffff;
+  color: black;
+  margin: 2em;
+  padding: 0em 2em;
+}
+
+p.topic-title {
+  font-weight: bold;
+}
+
+table.docinfo {
+  text-align: left;
+  margin: 2em 0em;
+}
+
+a[href] {
+  color: #436976;
+  background-color: transparent;
+}
+
+a.toc-backref {
+  text-decoration: none;
+}
+
+h1 a[href] {
+  color: #003a6b;
+  text-decoration: none;
+  background-color: transparent;
+}
+
+a.strong {
+  font-weight: bold;
+}
+
+img {
+  margin: 0;
+  border: 0;
+}
+
+p {
+  margin: 0.5em 0 1em 0;
+  line-height: 1.5em;
+}
+
+p a:visited {
+  color: purple;
+  background-color: transparent;
+}
+
+p a:active {
+  color: red;
+  background-color: transparent;
+}
+
+a:hover {
+  text-decoration: none;
+}
+
+p img {
+  border: 0;
+  margin: 0;
+}
+
+p.rubric {
+  font-weight: bold;
+  font-style: italic;
+}
+
+em {
+  font-style: normal;
+  font-family: monospace;
+  font-weight: bold;
+}
+
+pre {
+  border-left: 3px double #aaa;
+  padding: 5px 10px;
+  background-color: #f6f6f6;
+}
+
+h1.title {
+  color: #003a6b;
+  font-size: 180%;
+  margin-bottom: 0em;
+}
+
+h2.subtitle {
+  color: #003a6b;
+  border-bottom: 0px;
+}
+
+h1, h2, h3, h4, h5, h6 {
+  color: #555;
+  background-color: transparent;
+  margin: 0em;
+  padding-top: 0.5em;
+}
+
+h1 {
+  font-size: 150%;
+  margin-bottom: 0.5em;
+  border-bottom: 2px solid #aaa;
+}
+
+h2 {
+  font-size: 130%;
+  margin-bottom: 0.5em;
+  border-bottom: 1px solid #aaa;
+}
+
+h3 {
+  font-size: 120%;
+  margin-bottom: 0.5em;
+}
+
+h4 {
+  font-size: 110%;
+  font-weight: bold;
+  margin-bottom: 0.5em;
+}
+
+h5 {
+  font-size: 105%;
+  font-weight: bold;
+  margin-bottom: 0.5em;
+}
+
+h6 {
+  font-size: 100%;
+  font-weight: bold;
+  margin-bottom: 0.5em;
+}
+
+dt {
+  font-style: italic;
+}
+
+dd {
+  margin-bottom: 1.5em;
+}
+
+div.admonition, div.note, div.tip, div.caution, div.important {
+  margin: 2em 2em;
+  padding: 0em 1em;
+  border-top: 1px solid #aaa;
+  border-left: 1px solid #aaa;
+  border-bottom: 2px solid #555;
+  border-right: 2px solid #555;
+}
+
+div.important {
+  background: transparent url('../images/important.png') 10px 2px no-repeat;
+}
+
+div.caution {
+  background: transparent url('../images/caution.png') 10px 2px no-repeat;
+}
+
+div.note {
+  background: transparent url('../images/note.png') 10px 2px no-repeat;
+}
+
+div.tip {
+  background: transparent url('../images/tip.png') 10px 2px no-repeat;
+}
+
+div.admonition-example {
+  background: transparent url('../images/tip.png') 10px 2px no-repeat;
+}
+
+div.admonition-critical-example {
+  background: transparent url('../images/important.png') 10px 2px no-repeat;
+}
+
+p.admonition-title {
+  font-weight: bold;
+  border-bottom: 1px solid #aaa;
+  padding-left: 30px;
+}
+
+table.docutils {
+  text-align: left;
+  border: 1px solid gray;
+  border-collapse: collapse;
+  margin: 1.5em 0em;
+}
+
+table.docutils caption {
+  font-style: italic;
+}
+
+table.docutils td, table.docutils th {
+  padding: 0.25em 0.5em;
+}
+
+th.field-name {
+   text-align: right;
+   width: 15em;
+}
+
+table.docutils th {
+  font-family: monospace;
+  background-color: #f6f6f6;
+  vertical-align: middle;
+}
+
+table.field-list {
+  border: none;  
+}
+
+div.sidebar {
+  margin: 2em 2em 2em 0em;
+  padding: 0em 1em;
+  border-top: 1px solid #aaa;
+  border-left: 1px solid #aaa;
+  border-bottom: 2px solid #555;
+  border-right: 2px solid #555;
+}
+
+p.sidebar-title {
+  margin-bottom: 0em;
+  color: #003a6b;
+  border-bottom: 1px solid #aaa;
+  font-weight: bold;
+}
+
+p.sidebar-subtitle {
+  margin-top: 0em;
+  font-style: italic;
+  color: #003a6b;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/menu.rst
@@ -0,0 +1,13 @@
+.. sidebar :: Documentation index
+
+    1) `Overview`_
+    2) `Concepts`_
+    3) `API reference`_
+    4) `Security model`_
+    5) `Migration from older versions`_
+    
+.. _`Overview`: index.html
+.. _`Concepts`: concepts.html
+.. _`API reference`: reference.html
+.. _`Security model`: security.html
+.. _`Migration from older versions`: migration.html
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/migration.rst
@@ -0,0 +1,276 @@
+=====================================
+Nanopb: Migration from older versions
+=====================================
+
+.. include :: menu.rst
+
+This document details all the breaking changes that have been made to nanopb
+since its initial release. For each change, the rationale and required
+modifications of user applications are explained. Also any error indications
+are included, in order to make it easier to find this document.
+
+.. contents ::
+
+Nanopb-0.3.5 (2016-02-13)
+=========================
+
+Add support for platforms without uint8_t
+-----------------------------------------
+**Rationale:** Some platforms cannot access 8-bit sized values directly, and
+do not define *uint8_t*. Nanopb previously didn't support these platforms.
+
+**Changes:** References to *uint8_t* were replaced with several alternatives,
+one of them being a new *pb_byte_t* typedef. This in turn uses *uint_least8_t*
+which means the smallest available type.
+
+**Required actions:** If your platform does not have a standards-compliant
+*stdint.h*, it may lack the definition for *[u]int_least8_t*. This must be
+added manually, example can be found in *extra/pb_syshdr.h*.
+
+**Error indications:** Compiler error: "unknown type name 'uint_least8_t'".
+
+Nanopb-0.3.2 (2015-01-24)
+=========================
+
+Add support for OneOfs
+----------------------
+**Rationale:** Previously nanopb did not support the *oneof* construct in
+*.proto* files. Those fields were generated as regular *optional* fields.
+
+**Changes:** OneOfs are now generated as C unions. Callback fields are not
+supported inside oneof and generator gives an error.
+
+**Required actions:** The generator option *no_unions* can be used to restore old
+behaviour and to allow callbacks to be used. To use unions, one change is
+needed: use *which_xxxx* field to detect which field is present, instead
+of *has_xxxx*. Compare the value against *MyStruct_myfield_tag*.
+
+**Error indications:** Generator error: "Callback fields inside of oneof are
+not supported". Compiler error: "Message" has no member named "has_xxxx".
+
+Nanopb-0.3.0 (2014-08-26)
+=========================
+
+Separate field iterator logic to pb_common.c
+--------------------------------------------
+**Rationale:** Originally, the field iteration logic was simple enough to be
+duplicated in *pb_decode.c* and *pb_encode.c*. New field types have made the
+logic more complex, which required the creation of a new file to contain the
+common functionality.
+
+**Changes:** There is a new file, *pb_common.c*, which must be included in
+builds.
+
+**Required actions:** Add *pb_common.c* to build rules. This file is always
+required. Either *pb_decode.c* or *pb_encode.c* can still be left out if some
+functionality is not needed.
+
+**Error indications:** Linker error: undefined reference to
+*pb_field_iter_begin*, *pb_field_iter_next* or similar.
+
+Change data type of field counts to pb_size_t
+---------------------------------------------
+**Rationale:** Often nanopb is used with small arrays, such as 255 items or
+less. Using a full *size_t* field to store the array count wastes memory if
+there are many arrays. There already exists parameters *PB_FIELD_16BIT* and
+*PB_FIELD_32BIT* which tell nanopb what is the maximum size of arrays in use.
+
+**Changes:** Generator will now use *pb_size_t* for the array *_count* fields.
+The size of the type will be controlled by the *PB_FIELD_16BIT* and
+*PB_FIELD_32BIT* compilation time options.
+
+**Required actions:** Regenerate all *.pb.h* files. In some cases casts to the
+*pb_size_t* type may need to be added in the user code when accessing the
+*_count* fields.
+
+**Error indications:** Incorrect data at runtime, crashes. But note that other
+changes in the same version already require regenerating the files and have
+better indications of errors, so this is only an issue for development
+versions.
+
+Renamed some macros and identifiers
+-----------------------------------
+**Rationale:** Some names in nanopb core were badly chosen and conflicted with
+ISO C99 reserved names or lacked a prefix. While they haven't caused trouble
+so far, it is reasonable to switch to non-conflicting names as these are rarely
+used from user code.
+
+**Changes:** The following identifier names have changed:
+
+  * Macros:
+  
+    * STATIC_ASSERT(x) -> PB_STATIC_ASSERT(x)
+    * UNUSED(x) -> PB_UNUSED(x)
+  
+  * Include guards:
+  
+    * _PB_filename_ -> PB_filename_INCLUDED
+  
+  * Structure forward declaration tags:
+  
+    * _pb_field_t -> pb_field_s
+    * _pb_bytes_array_t -> pb_bytes_array_s
+    * _pb_callback_t -> pb_callback_s
+    * _pb_extension_type_t -> pb_extension_type_s
+    * _pb_extension_t -> pb_extension_s
+    * _pb_istream_t -> pb_istream_s
+    * _pb_ostream_t -> pb_ostream_s
+
+**Required actions:** Regenerate all *.pb.c* files. If you use any of the above
+identifiers in your application code, perform search-replace to the new name.
+
+**Error indications:** Compiler errors on lines with the macro/type names.
+
+Nanopb-0.2.9 (2014-08-09)
+=========================
+
+Change semantics of generator -e option
+---------------------------------------
+**Rationale:** Some compilers do not accept filenames with two dots (like
+in default extension .pb.c). The *-e* option to the generator allowed changing
+the extension, but not skipping the extra dot.
+
+**Changes:** The *-e* option in generator will no longer add the prepending
+dot. The default value has been adjusted accordingly to *.pb.c* to keep the
+default behaviour the same as before.
+
+**Required actions:** Only if using the generator -e option. Add dot before
+the parameter value on the command line.
+
+**Error indications:** File not found when trying to compile generated files.
+
+Nanopb-0.2.7 (2014-04-07)
+=========================
+
+Changed pointer-type bytes field datatype
+-----------------------------------------
+**Rationale:** In the initial pointer encoding support since nanopb-0.2.5,
+the bytes type used a separate *pb_bytes_ptr_t* type to represent *bytes*
+fields. This made it easy to encode data from a separate, user-allocated
+buffer. However, it made the internal logic more complex and was inconsistent
+with the other types.
+
+**Changes:** Dynamically allocated bytes fields now have the *pb_bytes_array_t*
+type, just like statically allocated ones.
+
+**Required actions:** Only if using pointer-type fields with the bytes datatype.
+Change any access to *msg->field.size* to *msg->field->size*. Change any
+allocation to reserve space of amount *PB_BYTES_ARRAY_T_ALLOCSIZE(n)*. If the
+data pointer was begin assigned from external source, implement the field using
+a callback function instead.
+
+**Error indications:** Compiler error: unknown type name *pb_bytes_ptr_t*.
+
+Nanopb-0.2.4 (2013-11-07)
+=========================
+
+Remove the NANOPB_INTERNALS compilation option
+----------------------------------------------
+**Rationale:** Having the option in the headers required the functions to
+be non-static, even if the option is not used. This caused errors on some
+static analysis tools.
+
+**Changes:** The *#ifdef* and associated functions were removed from the
+header.
+
+**Required actions:** Only if the *NANOPB_INTERNALS* option was previously
+used. Actions are as listed under nanopb-0.1.3 and nanopb-0.1.6.
+
+**Error indications:** Compiler warning: implicit declaration of function
+*pb_dec_string*, *pb_enc_string*, or similar.
+
+Nanopb-0.2.1 (2013-04-14)
+=========================
+
+Callback function signature
+---------------------------
+**Rationale:** Previously the auxilary data to field callbacks was passed
+as *void\**. This allowed passing of any data, but made it unnecessarily
+complex to return a pointer from callback.
+
+**Changes:** The callback function parameter was changed to *void\*\**.
+
+**Required actions:** You can continue using the old callback style by
+defining *PB_OLD_CALLBACK_STYLE*. Recommended action is to:
+
+  * Change the callback signatures to contain *void\*\** for decoders and
+    *void \* const \** for encoders.
+  * Change the callback function body to use *\*arg* instead of *arg*.
+
+**Error indications:** Compiler warning: assignment from incompatible
+pointer type, when initializing *funcs.encode* or *funcs.decode*.
+
+Nanopb-0.2.0 (2013-03-02)
+=========================
+
+Reformatted generated .pb.c file using macros
+---------------------------------------------
+**Rationale:** Previously the generator made a list of C *pb_field_t*
+initializers in the .pb.c file. This led to a need to regenerate all .pb.c
+files after even small changes to the *pb_field_t* definition.
+
+**Changes:** Macros were added to pb.h which allow for cleaner definition
+of the .pb.c contents. By changing the macro definitions, changes to the
+field structure are possible without breaking compatibility with old .pb.c
+files.
+
+**Required actions:** Regenerate all .pb.c files from the .proto sources.
+
+**Error indications:** Compiler warning: implicit declaration of function
+*pb_delta_end*.
+
+Changed pb_type_t definitions
+-----------------------------
+**Rationale:** The *pb_type_t* was previously an enumeration type. This
+caused warnings on some compilers when using bitwise operations to set flags
+inside the values.
+
+**Changes:** The *pb_type_t* was changed to *typedef uint8_t*. The values
+were changed to *#define*. Some value names were changed for consistency.
+
+**Required actions:** Only if you directly access the `pb_field_t` contents
+in your own code, something which is not usually done. Needed changes:
+
+  * Change *PB_HTYPE_ARRAY* to *PB_HTYPE_REPEATED*.
+  * Change *PB_HTYPE_CALLBACK* to *PB_ATYPE()* and *PB_ATYPE_CALLBACK*.
+
+**Error indications:** Compiler error: *PB_HTYPE_ARRAY* or *PB_HTYPE_CALLBACK*
+undeclared.
+
+Nanopb-0.1.6 (2012-09-02)
+=========================
+
+Refactored field decoder interface
+----------------------------------
+**Rationale:** Similarly to field encoders in nanopb-0.1.3.
+
+**Changes:** New functions with names *pb_decode_\** were added.
+
+**Required actions:** By defining NANOPB_INTERNALS, you can still keep using
+the old functions. Recommended action is to replace any calls with the newer
+*pb_decode_\** equivalents.
+
+**Error indications:** Compiler warning: implicit declaration of function
+*pb_dec_string*, *pb_dec_varint*, *pb_dec_submessage* or similar.
+
+Nanopb-0.1.3 (2012-06-12)
+=========================
+
+Refactored field encoder interface
+----------------------------------
+**Rationale:** The old *pb_enc_\** functions were designed mostly for the
+internal use by the core. Because they are internally accessed through
+function pointers, their signatures had to be common. This led to a confusing
+interface for external users.
+
+**Changes:** New functions with names *pb_encode_\** were added. These have
+easier to use interfaces. The old functions are now only thin wrappers for
+the new interface.
+
+**Required actions:** By defining NANOPB_INTERNALS, you can still keep using
+the old functions. Recommended action is to replace any calls with the newer
+*pb_encode_\** equivalents.
+
+**Error indications:** Compiler warning: implicit declaration of function
+*pb_enc_string*, *pb_enc_varint, *pb_enc_submessage* or similar.
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/reference.rst
@@ -0,0 +1,765 @@
+=====================
+Nanopb: API reference
+=====================
+
+.. include :: menu.rst
+
+.. contents ::
+
+
+
+
+Compilation options
+===================
+The following options can be specified in one of two ways:
+
+1. Using the -D switch on the C compiler command line.
+2. By #defining them at the top of pb.h.
+
+You must have the same settings for the nanopb library and all code that
+includes pb.h.
+
+============================  ================================================
+PB_NO_PACKED_STRUCTS           Disable packed structs. Increases RAM usage but
+                               is necessary on some platforms that do not
+                               support unaligned memory access.
+PB_ENABLE_MALLOC               Set this to enable dynamic allocation support
+                               in the decoder.
+PB_MAX_REQUIRED_FIELDS         Maximum number of required fields to check for
+                               presence. Default value is 64. Increases stack
+                               usage 1 byte per every 8 fields. Compiler
+                               warning will tell if you need this.
+PB_FIELD_16BIT                 Add support for tag numbers > 255 and fields
+                               larger than 255 bytes or 255 array entries.
+                               Increases code size 3 bytes per each field.
+                               Compiler error will tell if you need this.
+PB_FIELD_32BIT                 Add support for tag numbers > 65535 and fields
+                               larger than 65535 bytes or 65535 array entries.
+                               Increases code size 9 bytes per each field.
+                               Compiler error will tell if you need this.
+PB_NO_ERRMSG                   Disables the support for error messages; only
+                               error information is the true/false return
+                               value. Decreases the code size by a few hundred
+                               bytes.
+PB_BUFFER_ONLY                 Disables the support for custom streams. Only
+                               supports encoding and decoding with memory
+                               buffers. Speeds up execution and decreases code
+                               size slightly.
+PB_OLD_CALLBACK_STYLE          Use the old function signature (void\* instead
+                               of void\*\*) for callback fields. This was the
+                               default until nanopb-0.2.1.
+PB_SYSTEM_HEADER               Replace the standard header files with a single
+                               header file. It should define all the required
+                               functions and typedefs listed on the
+                               `overview page`_. Value must include quotes,
+                               for example *#define PB_SYSTEM_HEADER "foo.h"*.
+============================  ================================================
+
+The PB_MAX_REQUIRED_FIELDS, PB_FIELD_16BIT and PB_FIELD_32BIT settings allow
+raising some datatype limits to suit larger messages. Their need is recognized
+automatically by C-preprocessor #if-directives in the generated .pb.h files.
+The default setting is to use the smallest datatypes (least resources used).
+
+.. _`overview page`: index.html#compiler-requirements
+
+
+Proto file options
+==================
+The generator behaviour can be adjusted using these options, defined in the
+'nanopb.proto' file in the generator folder:
+
+============================  ================================================
+max_size                       Allocated size for *bytes* and *string* fields.
+max_count                      Allocated number of entries in arrays
+                               (*repeated* fields).
+int_size                       Override the integer type of a field.
+                               (To use e.g. uint8_t to save RAM.)
+type                           Type of the generated field. Default value
+                               is *FT_DEFAULT*, which selects automatically.
+                               You can use *FT_CALLBACK*, *FT_POINTER*,
+                               *FT_STATIC* or *FT_IGNORE* to force a callback
+                               field, a dynamically allocated field, a static
+                               field or to completely ignore the field.
+long_names                     Prefix the enum name to the enum value in
+                               definitions, i.e. *EnumName_EnumValue*. Enabled
+                               by default.
+packed_struct                  Make the generated structures packed.
+                               NOTE: This cannot be used on CPUs that break
+                               on unaligned accesses to variables.
+skip_message                   Skip the whole message from generation.
+no_unions                      Generate 'oneof' fields as optional fields
+                               instead of C unions.
+msgid                          Specifies a unique id for this message type.
+                               Can be used by user code as an identifier.
+anonymous_oneof                Generate 'oneof' fields as anonymous unions.
+============================  ================================================
+
+These options can be defined for the .proto files before they are converted
+using the nanopb-generatory.py. There are three ways to define the options:
+
+1. Using a separate .options file.
+   This is the preferred way as of nanopb-0.2.1, because it has the best
+   compatibility with other protobuf libraries.
+2. Defining the options on the command line of nanopb_generator.py.
+   This only makes sense for settings that apply to a whole file.
+3. Defining the options in the .proto file using the nanopb extensions.
+   This is the way used in nanopb-0.1, and will remain supported in the
+   future. It however sometimes causes trouble when using the .proto file
+   with other protobuf libraries.
+
+The effect of the options is the same no matter how they are given. The most
+common purpose is to define maximum size for string fields in order to
+statically allocate them.
+
+Defining the options in a .options file
+---------------------------------------
+The preferred way to define options is to have a separate file
+'myproto.options' in the same directory as the 'myproto.proto'. ::
+
+    # myproto.proto
+    message MyMessage {
+        required string name = 1;
+        repeated int32 ids = 4;
+    }
+
+::
+
+    # myproto.options
+    MyMessage.name         max_size:40
+    MyMessage.ids          max_count:5
+
+The generator will automatically search for this file and read the
+options from it. The file format is as follows:
+
+* Lines starting with '#' or '//' are regarded as comments.
+* Blank lines are ignored.
+* All other lines should start with a field name pattern, followed by one or
+  more options. For example: *"MyMessage.myfield max_size:5 max_count:10"*.
+* The field name pattern is matched against a string of form *'Message.field'*.
+  For nested messages, the string is *'Message.SubMessage.field'*.
+* The field name pattern may use the notation recognized by Python fnmatch():
+
+  - *\** matches any part of string, like 'Message.\*' for all fields
+  - *\?* matches any single character
+  - *[seq]* matches any of characters 's', 'e' and 'q'
+  - *[!seq]* matches any other character
+
+* The options are written as *'option_name:option_value'* and several options
+  can be defined on same line, separated by whitespace.
+* Options defined later in the file override the ones specified earlier, so
+  it makes sense to define wildcard options first in the file and more specific
+  ones later.
+  
+If preferred, the name of the options file can be set using the command line
+switch *-f* to nanopb_generator.py.
+
+Defining the options on command line
+------------------------------------
+The nanopb_generator.py has a simple command line option *-s OPTION:VALUE*.
+The setting applies to the whole file that is being processed.
+
+Defining the options in the .proto file
+---------------------------------------
+The .proto file format allows defining custom options for the fields.
+The nanopb library comes with *nanopb.proto* which does exactly that, allowing
+you do define the options directly in the .proto file::
+
+    import "nanopb.proto";
+    
+    message MyMessage {
+        required string name = 1 [(nanopb).max_size = 40];
+        repeated int32 ids = 4   [(nanopb).max_count = 5];
+    }
+
+A small complication is that you have to set the include path of protoc so that
+nanopb.proto can be found. This file, in turn, requires the file
+*google/protobuf/descriptor.proto*. This is usually installed under
+*/usr/include*. Therefore, to compile a .proto file which uses options, use a
+protoc command similar to::
+
+    protoc -I/usr/include -Inanopb/generator -I. -omessage.pb message.proto
+
+The options can be defined in file, message and field scopes::
+
+    option (nanopb_fileopt).max_size = 20; // File scope
+    message Message
+    {
+        option (nanopb_msgopt).max_size = 30; // Message scope
+        required string fieldsize = 1 [(nanopb).max_size = 40]; // Field scope
+    }
+
+
+
+
+
+
+
+
+
+pb.h
+====
+
+pb_byte_t
+---------
+Type used for storing byte-sized data, such as raw binary input and bytes-type fields. ::
+
+    typedef uint_least8_t pb_byte_t;
+
+For most platforms this is equivalent to `uint8_t`. Some platforms however do not support
+8-bit variables, and on those platforms 16 or 32 bits need to be used for each byte.
+
+pb_type_t
+---------
+Type used to store the type of each field, to control the encoder/decoder behaviour. ::
+
+    typedef uint_least8_t pb_type_t;
+
+The low-order nibble of the enumeration values defines the function that can be used for encoding and decoding the field data:
+
+==================== ===== ================================================
+LTYPE identifier     Value Storage format
+==================== ===== ================================================
+PB_LTYPE_VARINT      0x00  Integer.
+PB_LTYPE_SVARINT     0x01  Integer, zigzag encoded.
+PB_LTYPE_FIXED32     0x02  32-bit integer or floating point.
+PB_LTYPE_FIXED64     0x03  64-bit integer or floating point.
+PB_LTYPE_BYTES       0x04  Structure with *size_t* field and byte array.
+PB_LTYPE_STRING      0x05  Null-terminated string.
+PB_LTYPE_SUBMESSAGE  0x06  Submessage structure.
+==================== ===== ================================================
+
+The bits 4-5 define whether the field is required, optional or repeated:
+
+==================== ===== ================================================
+HTYPE identifier     Value Field handling
+==================== ===== ================================================
+PB_HTYPE_REQUIRED    0x00  Verify that field exists in decoded message.
+PB_HTYPE_OPTIONAL    0x10  Use separate *has_<field>* boolean to specify
+                           whether the field is present.
+                           (Unless it is a callback)
+PB_HTYPE_REPEATED    0x20  A repeated field with preallocated array.
+                           Separate *<field>_count* for number of items.
+                           (Unless it is a callback)
+==================== ===== ================================================
+
+The bits 6-7 define the how the storage for the field is allocated:
+
+==================== ===== ================================================
+ATYPE identifier     Value Allocation method
+==================== ===== ================================================
+PB_ATYPE_STATIC      0x00  Statically allocated storage in the structure.
+PB_ATYPE_CALLBACK    0x40  A field with dynamic storage size. Struct field
+                           actually contains a pointer to a callback
+                           function.
+==================== ===== ================================================
+
+
+pb_field_t
+----------
+Describes a single structure field with memory position in relation to others. The descriptions are usually autogenerated. ::
+
+    typedef struct pb_field_s pb_field_t;
+    struct pb_field_s {
+        pb_size_t tag;
+        pb_type_t type;
+        pb_size_t data_offset;
+        pb_ssize_t size_offset;
+        pb_size_t data_size;
+        pb_size_t array_size;
+        const void *ptr;
+    } pb_packed;
+
+:tag:           Tag number of the field or 0 to terminate a list of fields.
+:type:          LTYPE, HTYPE and ATYPE of the field.
+:data_offset:   Offset of field data, relative to the end of the previous field.
+:size_offset:   Offset of *bool* flag for optional fields or *size_t* count for arrays, relative to field data.
+:data_size:     Size of a single data entry, in bytes. For PB_LTYPE_BYTES, the size of the byte array inside the containing structure. For PB_HTYPE_CALLBACK, size of the C data type if known.
+:array_size:    Maximum number of entries in an array, if it is an array type.
+:ptr:           Pointer to default value for optional fields, or to submessage description for PB_LTYPE_SUBMESSAGE.
+
+The *uint8_t* datatypes limit the maximum size of a single item to 255 bytes and arrays to 255 items. Compiler will give error if the values are too large. The types can be changed to larger ones by defining *PB_FIELD_16BIT*.
+
+pb_bytes_array_t
+----------------
+An byte array with a field for storing the length::
+
+    typedef struct {
+        pb_size_t size;
+        pb_byte_t bytes[1];
+    } pb_bytes_array_t;
+
+In an actual array, the length of *bytes* may be different.
+
+pb_callback_t
+-------------
+Part of a message structure, for fields with type PB_HTYPE_CALLBACK::
+
+    typedef struct _pb_callback_t pb_callback_t;
+    struct _pb_callback_t {
+        union {
+            bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
+            bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
+        } funcs;
+        
+        void *arg;
+    };
+
+A pointer to the *arg* is passed to the callback when calling. It can be used to store any information that the callback might need.
+
+Previously the function received just the value of *arg* instead of a pointer to it. This old behaviour can be enabled by defining *PB_OLD_CALLBACK_STYLE*.
+
+When calling `pb_encode`_, *funcs.encode* is used, and similarly when calling `pb_decode`_, *funcs.decode* is used. The function pointers are stored in the same memory location but are of incompatible types. You can set the function pointer to NULL to skip the field.
+
+pb_wire_type_t
+--------------
+Protocol Buffers wire types. These are used with `pb_encode_tag`_. ::
+
+    typedef enum {
+        PB_WT_VARINT = 0,
+        PB_WT_64BIT  = 1,
+        PB_WT_STRING = 2,
+        PB_WT_32BIT  = 5
+    } pb_wire_type_t;
+
+pb_extension_type_t
+-------------------
+Defines the handler functions and auxiliary data for a field that extends
+another message. Usually autogenerated by *nanopb_generator.py*::
+
+    typedef struct {
+        bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
+                   uint32_t tag, pb_wire_type_t wire_type);
+        bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
+        const void *arg;
+    } pb_extension_type_t;
+
+In the normal case, the function pointers are *NULL* and the decoder and
+encoder use their internal implementations. The internal implementations
+assume that *arg* points to a *pb_field_t* that describes the field in question.
+
+To implement custom processing of unknown fields, you can provide pointers
+to your own functions. Their functionality is mostly the same as for normal
+callback fields, except that they get called for any unknown field when decoding.
+
+pb_extension_t
+--------------
+Ties together the extension field type and the storage for the field value::
+
+    typedef struct {
+        const pb_extension_type_t *type;
+        void *dest;
+        pb_extension_t *next;
+        bool found;
+    } pb_extension_t;
+
+:type:      Pointer to the structure that defines the callback functions.
+:dest:      Pointer to the variable that stores the field value
+            (as used by the default extension callback functions.)
+:next:      Pointer to the next extension handler, or *NULL*.
+:found:     Decoder sets this to true if the extension was found.
+
+PB_GET_ERROR
+------------
+Get the current error message from a stream, or a placeholder string if
+there is no error message::
+
+    #define PB_GET_ERROR(stream) (string expression)
+
+This should be used for printing errors, for example::
+
+    if (!pb_decode(...))
+    {
+        printf("Decode failed: %s\n", PB_GET_ERROR(stream));
+    }
+
+The macro only returns pointers to constant strings (in code memory),
+so that there is no need to release the returned pointer.
+
+PB_RETURN_ERROR
+---------------
+Set the error message and return false::
+
+    #define PB_RETURN_ERROR(stream,msg) (sets error and returns false)
+
+This should be used to handle error conditions inside nanopb functions
+and user callback functions::
+
+    if (error_condition)
+    {
+        PB_RETURN_ERROR(stream, "something went wrong");
+    }
+
+The *msg* parameter must be a constant string.
+
+
+
+pb_encode.h
+===========
+
+pb_ostream_from_buffer
+----------------------
+Constructs an output stream for writing into a memory buffer. This is just a helper function, it doesn't do anything you couldn't do yourself in a callback function. It uses an internal callback that stores the pointer in stream *state* field. ::
+
+    pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
+
+:buf:           Memory buffer to write into.
+:bufsize:       Maximum number of bytes to write.
+:returns:       An output stream.
+
+After writing, you can check *stream.bytes_written* to find out how much valid data there is in the buffer.
+
+pb_write
+--------
+Writes data to an output stream. Always use this function, instead of trying to call stream callback manually. ::
+
+    bool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
+
+:stream:        Output stream to write to.
+:buf:           Pointer to buffer with the data to be written.
+:count:         Number of bytes to write.
+:returns:       True on success, false if maximum length is exceeded or an IO error happens.
+
+If an error happens, *bytes_written* is not incremented. Depending on the callback used, calling pb_write again after it has failed once may be dangerous. Nanopb itself never does this, instead it returns the error to user application. The builtin pb_ostream_from_buffer is safe to call again after failed write.
+
+pb_encode
+---------
+Encodes the contents of a structure as a protocol buffers message and writes it to output stream. ::
+
+    bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
+
+:stream:        Output stream to write to.
+:fields:        A field description array, usually autogenerated.
+:src_struct:    Pointer to the data that will be serialized.
+:returns:       True on success, false on IO error, on detectable errors in field description, or if a field encoder returns false.
+
+Normally pb_encode simply walks through the fields description array and serializes each field in turn. However, submessages must be serialized twice: first to calculate their size and then to actually write them to output. This causes some constraints for callback fields, which must return the same data on every call.
+
+pb_encode_delimited
+-------------------
+Calculates the length of the message, encodes it as varint and then encodes the message. ::
+
+    bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
+
+(parameters are the same as for `pb_encode`_.)
+
+A common way to indicate the message length in Protocol Buffers is to prefix it with a varint.
+This function does this, and it is compatible with *parseDelimitedFrom* in Google's protobuf library.
+
+.. sidebar:: Encoding fields manually
+
+    The functions with names *pb_encode_\** are used when dealing with callback fields. The typical reason for using callbacks is to have an array of unlimited size. In that case, `pb_encode`_ will call your callback function, which in turn will call *pb_encode_\** functions repeatedly to write out values.
+
+    The tag of a field must be encoded separately with `pb_encode_tag_for_field`_. After that, you can call exactly one of the content-writing functions to encode the payload of the field. For repeated fields, you can repeat this process multiple times.
+
+    Writing packed arrays is a little bit more involved: you need to use `pb_encode_tag` and specify `PB_WT_STRING` as the wire type. Then you need to know exactly how much data you are going to write, and use `pb_encode_varint`_ to write out the number of bytes before writing the actual data. Substreams can be used to determine the number of bytes beforehand; see `pb_encode_submessage`_ source code for an example.
+
+pb_get_encoded_size
+-------------------
+Calculates the length of the encoded message. ::
+
+    bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct);
+
+:size:          Calculated size of the encoded message.
+:fields:        A field description array, usually autogenerated.
+:src_struct:    Pointer to the data that will be serialized.
+:returns:       True on success, false on detectable errors in field description or if a field encoder returns false.
+
+pb_encode_tag
+-------------
+Starts a field in the Protocol Buffers binary format: encodes the field number and the wire type of the data. ::
+
+    bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);
+
+:stream:        Output stream to write to. 1-5 bytes will be written.
+:wiretype:      PB_WT_VARINT, PB_WT_64BIT, PB_WT_STRING or PB_WT_32BIT
+:field_number:  Identifier for the field, defined in the .proto file. You can get it from field->tag.
+:returns:       True on success, false on IO error.
+
+pb_encode_tag_for_field
+-----------------------
+Same as `pb_encode_tag`_, except takes the parameters from a *pb_field_t* structure. ::
+
+    bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);
+
+:stream:        Output stream to write to. 1-5 bytes will be written.
+:field:         Field description structure. Usually autogenerated.
+:returns:       True on success, false on IO error or unknown field type.
+
+This function only considers the LTYPE of the field. You can use it from your field callbacks, because the source generator writes correct LTYPE also for callback type fields.
+
+Wire type mapping is as follows:
+
+========================= ============
+LTYPEs                    Wire type
+========================= ============
+VARINT, SVARINT           PB_WT_VARINT
+FIXED64                   PB_WT_64BIT  
+STRING, BYTES, SUBMESSAGE PB_WT_STRING 
+FIXED32                   PB_WT_32BIT
+========================= ============
+
+pb_encode_varint
+----------------
+Encodes a signed or unsigned integer in the varint_ format. Works for fields of type `bool`, `enum`, `int32`, `int64`, `uint32` and `uint64`::
+
+    bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);
+
+:stream:        Output stream to write to. 1-10 bytes will be written.
+:value:         Value to encode. Just cast e.g. int32_t directly to uint64_t.
+:returns:       True on success, false on IO error.
+
+.. _varint: http://code.google.com/apis/protocolbuffers/docs/encoding.html#varints
+
+pb_encode_svarint
+-----------------
+Encodes a signed integer in the 'zig-zagged' format. Works for fields of type `sint32` and `sint64`::
+
+    bool pb_encode_svarint(pb_ostream_t *stream, int64_t value);
+
+(parameters are the same as for `pb_encode_varint`_
+
+pb_encode_string
+----------------
+Writes the length of a string as varint and then contents of the string. Works for fields of type `bytes` and `string`::
+
+    bool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);
+
+:stream:        Output stream to write to.
+:buffer:        Pointer to string data.
+:size:          Number of bytes in the string. Pass `strlen(s)` for strings.
+:returns:       True on success, false on IO error.
+
+pb_encode_fixed32
+-----------------
+Writes 4 bytes to stream and swaps bytes on big-endian architectures. Works for fields of type `fixed32`, `sfixed32` and `float`::
+
+    bool pb_encode_fixed32(pb_ostream_t *stream, const void *value);
+
+:stream:    Output stream to write to.
+:value:     Pointer to a 4-bytes large C variable, for example `uint32_t foo;`.
+:returns:   True on success, false on IO error.
+
+pb_encode_fixed64
+-----------------
+Writes 8 bytes to stream and swaps bytes on big-endian architecture. Works for fields of type `fixed64`, `sfixed64` and `double`::
+
+    bool pb_encode_fixed64(pb_ostream_t *stream, const void *value);
+
+:stream:    Output stream to write to.
+:value:     Pointer to a 8-bytes large C variable, for example `uint64_t foo;`.
+:returns:   True on success, false on IO error.
+
+pb_encode_submessage
+--------------------
+Encodes a submessage field, including the size header for it. Works for fields of any message type::
+
+    bool pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
+
+:stream:        Output stream to write to.
+:fields:        Pointer to the autogenerated field description array for the submessage type, e.g. `MyMessage_fields`.
+:src:           Pointer to the structure where submessage data is.
+:returns:       True on success, false on IO errors, pb_encode errors or if submessage size changes between calls.
+
+In Protocol Buffers format, the submessage size must be written before the submessage contents. Therefore, this function has to encode the submessage twice in order to know the size beforehand.
+
+If the submessage contains callback fields, the callback function might misbehave and write out a different amount of data on the second call. This situation is recognized and *false* is returned, but garbage will be written to the output before the problem is detected.
+
+
+
+
+
+
+
+
+
+
+
+
+pb_decode.h
+===========
+
+pb_istream_from_buffer
+----------------------
+Helper function for creating an input stream that reads data from a memory buffer. ::
+
+    pb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize);
+
+:buf:           Pointer to byte array to read from.
+:bufsize:       Size of the byte array.
+:returns:       An input stream ready to use.
+
+pb_read
+-------
+Read data from input stream. Always use this function, don't try to call the stream callback directly. ::
+
+    bool pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+
+:stream:        Input stream to read from.
+:buf:           Buffer to store the data to, or NULL to just read data without storing it anywhere.
+:count:         Number of bytes to read.
+:returns:       True on success, false if *stream->bytes_left* is less than *count* or if an IO error occurs.
+
+End of file is signalled by *stream->bytes_left* being zero after pb_read returns false.
+
+pb_decode
+---------
+Read and decode all fields of a structure. Reads until EOF on input stream. ::
+
+    bool pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+:stream:        Input stream to read from.
+:fields:        A field description array. Usually autogenerated.
+:dest_struct:   Pointer to structure where data will be stored.
+:returns:       True on success, false on IO error, on detectable errors in field description, if a field encoder returns false or if a required field is missing.
+
+In Protocol Buffers binary format, EOF is only allowed between fields. If it happens anywhere else, pb_decode will return *false*. If pb_decode returns false, you cannot trust any of the data in the structure.
+
+In addition to EOF, the pb_decode implementation supports terminating a message with a 0 byte. This is compatible with the official Protocol Buffers because 0 is never a valid field tag.
+
+For optional fields, this function applies the default value and sets *has_<field>* to false if the field is not present.
+
+If *PB_ENABLE_MALLOC* is defined, this function may allocate storage for any pointer type fields.
+In this case, you have to call `pb_release`_ to release the memory after you are done with the message.
+On error return `pb_decode` will release the memory itself.
+
+pb_decode_noinit
+----------------
+Same as `pb_decode`_, except does not apply the default values to fields. ::
+
+    bool pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+(parameters are the same as for `pb_decode`_.)
+
+The destination structure should be filled with zeros before calling this function. Doing a *memset* manually can be slightly faster than using `pb_decode`_ if you don't need any default values.
+
+In addition to decoding a single message, this function can be used to merge two messages, so that
+values from previous message will remain if the new message does not contain a field.
+
+This function *will not* release the message even on error return. If you use *PB_ENABLE_MALLOC*,
+you will need to call `pb_release`_ yourself.
+
+pb_decode_delimited
+-------------------
+Same as `pb_decode`_, except that it first reads a varint with the length of the message. ::
+
+    bool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+(parameters are the same as for `pb_decode`_.)
+
+A common method to indicate message size in Protocol Buffers is to prefix it with a varint.
+This function is compatible with *writeDelimitedTo* in the Google's Protocol Buffers library.
+
+pb_release
+----------
+Releases any dynamically allocated fields::
+
+    void pb_release(const pb_field_t fields[], void *dest_struct);
+
+:fields:        A field description array. Usually autogenerated.
+:dest_struct:   Pointer to structure where data is stored. If NULL, function does nothing.
+
+This function is only available if *PB_ENABLE_MALLOC* is defined. It will release any
+pointer type fields in the structure and set the pointers to NULL.
+
+pb_decode_tag
+-------------
+Decode the tag that comes before field in the protobuf encoding::
+
+    bool pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof);
+
+:stream:        Input stream to read from.
+:wire_type:     Pointer to variable where to store the wire type of the field.
+:tag:           Pointer to variable where to store the tag of the field.
+:eof:           Pointer to variable where to store end-of-file status.
+:returns:       True on success, false on error or EOF.
+
+When the message (stream) ends, this function will return false and set *eof* to true. On other
+errors, *eof* will be set to false.
+
+pb_skip_field
+-------------
+Remove the data for a field from the stream, without actually decoding it::
+
+    bool pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type);
+
+:stream:        Input stream to read from.
+:wire_type:     Type of field to skip.
+:returns:       True on success, false on IO error.
+
+.. sidebar:: Decoding fields manually
+    
+    The functions with names beginning with *pb_decode_* are used when dealing with callback fields. The typical reason for using callbacks is to have an array of unlimited size. In that case, `pb_decode`_ will call your callback function repeatedly, which can then store the values into e.g. filesystem in the order received in.
+
+    For decoding numeric (including enumerated and boolean) values, use `pb_decode_varint`_, `pb_decode_svarint`_, `pb_decode_fixed32`_ and `pb_decode_fixed64`_. They take a pointer to a 32- or 64-bit C variable, which you may then cast to smaller datatype for storage.
+
+    For decoding strings and bytes fields, the length has already been decoded. You can therefore check the total length in *stream->bytes_left* and read the data using `pb_read`_.
+
+    Finally, for decoding submessages in a callback, simply use `pb_decode`_ and pass it the *SubMessage_fields* descriptor array.
+
+pb_decode_varint
+----------------
+Read and decode a varint_ encoded integer. ::
+
+    bool pb_decode_varint(pb_istream_t *stream, uint64_t *dest);
+
+:stream:        Input stream to read from. 1-10 bytes will be read.
+:dest:          Storage for the decoded integer. Value is undefined on error.
+:returns:       True on success, false if value exceeds uint64_t range or an IO error happens.
+
+pb_decode_svarint
+-----------------
+Similar to `pb_decode_varint`_, except that it performs zigzag-decoding on the value. This corresponds to the Protocol Buffers *sint32* and *sint64* datatypes. ::
+
+    bool pb_decode_svarint(pb_istream_t *stream, int64_t *dest);
+
+(parameters are the same as `pb_decode_varint`_)
+
+pb_decode_fixed32
+-----------------
+Decode a *fixed32*, *sfixed32* or *float* value. ::
+
+    bool pb_decode_fixed32(pb_istream_t *stream, void *dest);
+
+:stream:        Input stream to read from. 4 bytes will be read.
+:dest:          Pointer to destination *int32_t*, *uint32_t* or *float*.
+:returns:       True on success, false on IO errors.
+
+This function reads 4 bytes from the input stream.
+On big endian architectures, it then reverses the order of the bytes.
+Finally, it writes the bytes to *dest*.
+
+pb_decode_fixed64
+-----------------
+Decode a *fixed64*, *sfixed64* or *double* value. ::
+
+    bool pb_decode_fixed64(pb_istream_t *stream, void *dest);
+
+:stream:        Input stream to read from. 8 bytes will be read.
+:dest:          Pointer to destination *int64_t*, *uint64_t* or *double*.
+:returns:       True on success, false on IO errors.
+
+Same as `pb_decode_fixed32`_, except this reads 8 bytes.
+
+pb_make_string_substream
+------------------------
+Decode the length for a field with wire type *PB_WT_STRING* and create a substream for reading the data. ::
+
+    bool pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream);
+
+:stream:        Original input stream to read the length and data from.
+:substream:     New substream that has limited length. Filled in by the function.
+:returns:       True on success, false if reading the length fails.
+
+This function uses `pb_decode_varint`_ to read an integer from the stream. This is interpreted as a number of bytes, and the substream is set up so that its `bytes_left` is initially the same as the length, and its callback function and state the same as the parent stream.
+
+pb_close_string_substream
+-------------------------
+Close the substream created with `pb_make_string_substream`_. ::
+
+    void pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream);
+
+:stream:        Original input stream to read the length and data from.
+:substream:     Substream to close
+
+This function copies back the state from the substream to the parent stream.
+It must be called after done with the substream.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/docs/security.rst
@@ -0,0 +1,84 @@
+======================
+Nanopb: Security model
+======================
+
+.. include :: menu.rst
+
+.. contents ::
+
+
+
+Importance of security in a Protocol Buffers library
+====================================================
+In the context of protocol buffers, security comes into play when decoding
+untrusted data. Naturally, if the attacker can modify the contents of a
+protocol buffers message, he can feed the application any values possible.
+Therefore the application itself must be prepared to receive untrusted values.
+
+Where nanopb plays a part is preventing the attacker from running arbitrary
+code on the target system. Mostly this means that there must not be any
+possibility to cause buffer overruns, memory corruption or invalid pointers
+by the means of crafting a malicious message.
+
+Division of trusted and untrusted data
+======================================
+The following data is regarded as **trusted**. It must be under the control of
+the application writer. Malicious data in these structures could cause
+security issues, such as execution of arbitrary code:
+
+1. Callback, pointer and extension fields in message structures given to
+   pb_encode() and pb_decode(). These fields are memory pointers, and are
+   generated depending on the message definition in the .proto file.
+2. The automatically generated field definitions, i.e. *pb_field_t* lists.
+3. Contents of the *pb_istream_t* and *pb_ostream_t* structures (this does not
+   mean the contents of the stream itself, just the stream definition).
+
+The following data is regarded as **untrusted**. Invalid/malicious data in
+these will cause "garbage in, garbage out" behaviour. It will not cause
+buffer overflows, information disclosure or other security problems:
+
+1. All data read from *pb_istream_t*.
+2. All fields in message structures, except:
+   
+   - callbacks (*pb_callback_t* structures)
+   - pointer fields (malloc support) and *_count* fields for pointers
+   - extensions (*pb_extension_t* structures)
+
+Invariants
+==========
+The following invariants are maintained during operation, even if the
+untrusted data has been maliciously crafted:
+
+1. Nanopb will never read more than *bytes_left* bytes from *pb_istream_t*.
+2. Nanopb will never write more than *max_size* bytes to *pb_ostream_t*.
+3. Nanopb will never access memory out of bounds of the message structure.
+4. After pb_decode() returns successfully, the message structure will be
+   internally consistent:
+
+   - The *count* fields of arrays will not exceed the array size.
+   - The *size* field of bytes will not exceed the allocated size.
+   - All string fields will have null terminator.
+
+5. After pb_encode() returns successfully, the resulting message is a valid
+   protocol buffers message. (Except if user-defined callbacks write incorrect
+   data.)
+
+Further considerations
+======================
+Even if the nanopb library is free of any security issues, there are still
+several possible attack vectors that the application author must consider.
+The following list is not comprehensive:
+
+1. Stack usage may depend on the contents of the message. The message
+   definition places an upper bound on how much stack will be used. Tests
+   should be run with all fields present, to record the maximum possible
+   stack usage.
+2. Callbacks can do anything. The code for the callbacks must be carefully
+   checked if they are used with untrusted data.
+3. If using stream input, a maximum size should be set in *pb_istream_t* to
+   stop a denial of service attack from using an infinite message.
+4. If using network sockets as streams, a timeout should be set to stop
+   denial of service attacks.
+5. If using *malloc()* support, some method of limiting memory use should be
+   employed. This can be done by defining custom *pb_realloc()* function.
+   Nanopb will properly detect and handle failed memory allocations.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/cmake_simple/CMakeLists.txt
@@ -0,0 +1,16 @@
+cmake_minimum_required(VERSION 2.8)
+project(NANOPB_CMAKE_SIMPLE C)
+
+set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/../../extra)
+find_package(Nanopb REQUIRED)
+include_directories(${NANOPB_INCLUDE_DIRS})
+
+nanopb_generate_cpp(PROTO_SRCS PROTO_HDRS simple.proto)
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+#add_custom_target(generate_proto_sources DEPENDS ${PROTO_SRCS} ${PROTO_HDRS})
+set_source_files_properties(${PROTO_SRCS} ${PROTO_HDRS}
+    PROPERTIES GENERATED TRUE)
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Werror -g -O0")
+
+add_executable(simple simple.c ${PROTO_SRCS} ${PROTO_HDRS})
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/cmake_simple/README.txt
@@ -0,0 +1,18 @@
+Nanopb example "simple" using CMake
+=======================
+
+This example is the same as the simple nanopb example but built using CMake.
+
+Example usage
+-------------
+
+On Linux, create a build directory and then call cmake:
+
+    nanopb/examples/cmake_simple$ mkdir build
+    nanopb/examples/cmake_simple$ cd build/
+    nanopb/examples/cmake_simple/build$ cmake ..
+    nanopb/examples/cmake_simple/build$ make
+
+After that, you can run it with the command: ./simple
+
+On other platforms supported by CMake, refer to CMake instructions.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/cmake_simple/simple.c
@@ -0,0 +1,71 @@
+#include <stdio.h>
+#include <pb_encode.h>
+#include <pb_decode.h>
+#include "simple.pb.h"
+
+int main()
+{
+    /* This is the buffer where we will store our message. */
+    uint8_t buffer[128];
+    size_t message_length;
+    bool status;
+    
+    /* Encode our message */
+    {
+        /* Allocate space on the stack to store the message data.
+         *
+         * Nanopb generates simple struct definitions for all the messages.
+         * - check out the contents of simple.pb.h!
+         * It is a good idea to always initialize your structures
+         * so that you do not have garbage data from RAM in there.
+         */
+        SimpleMessage message = SimpleMessage_init_zero;
+        
+        /* Create a stream that will write to our buffer. */
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        /* Fill in the lucky number */
+        message.lucky_number = 13;
+        
+        /* Now we are ready to encode the message! */
+        status = pb_encode(&stream, SimpleMessage_fields, &message);
+        message_length = stream.bytes_written;
+        
+        /* Then just check for any errors.. */
+        if (!status)
+        {
+            printf("Encoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1;
+        }
+    }
+    
+    /* Now we could transmit the message over network, store it in a file or
+     * wrap it to a pigeon's leg.
+     */
+
+    /* But because we are lazy, we will just decode it immediately. */
+    
+    {
+        /* Allocate space for the decoded message. */
+        SimpleMessage message = SimpleMessage_init_zero;
+        
+        /* Create a stream that reads from the buffer. */
+        pb_istream_t stream = pb_istream_from_buffer(buffer, message_length);
+        
+        /* Now we are ready to decode the message. */
+        status = pb_decode(&stream, SimpleMessage_fields, &message);
+        
+        /* Check for errors... */
+        if (!status)
+        {
+            printf("Decoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1;
+        }
+        
+        /* Print the data contained in the message. */
+        printf("Your lucky number was %d!\n", message.lucky_number);
+    }
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/cmake_simple/simple.proto
@@ -0,0 +1,9 @@
+// A very simple protocol definition, consisting of only
+// one message.
+
+syntax = "proto2";
+
+message SimpleMessage {
+    required int32 lucky_number = 1;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/Makefile
@@ -0,0 +1,17 @@
+# Include the nanopb provided Makefile rules
+include ../../extra/nanopb.mk
+
+# Compiler flags to enable all warnings & debug info
+CFLAGS = -ansi -Wall -Werror -g -O0
+CFLAGS += -I$(NANOPB_DIR)
+
+all: server client
+
+.SUFFIXES:
+
+clean:
+	rm -f server client fileproto.pb.c fileproto.pb.h
+
+%: %.c common.c fileproto.pb.c
+	$(CC) $(CFLAGS) -o $@ $^ $(NANOPB_CORE)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/README.txt
@@ -0,0 +1,60 @@
+Nanopb example "network_server"
+===============================
+
+This example demonstrates the use of nanopb to communicate over network
+connections. It consists of a server that sends file listings, and of
+a client that requests the file list from the server.
+
+Example usage
+-------------
+
+user@host:~/nanopb/examples/network_server$ make        # Build the example
+protoc -ofileproto.pb fileproto.proto
+python ../../generator/nanopb_generator.py fileproto.pb
+Writing to fileproto.pb.h and fileproto.pb.c
+cc -ansi -Wall -Werror -I .. -g -O0 -I../.. -o server server.c
+    ../../pb_decode.c ../../pb_encode.c fileproto.pb.c common.c
+cc -ansi -Wall -Werror -I .. -g -O0 -I../.. -o client client.c
+    ../../pb_decode.c ../../pb_encode.c fileproto.pb.c common.c
+
+user@host:~/nanopb/examples/network_server$ ./server &  # Start the server on background
+[1] 24462
+
+petteri@oddish:~/nanopb/examples/network_server$ ./client /bin  # Request the server to list /bin
+Got connection.
+Listing directory: /bin
+1327119    bzdiff
+1327126    bzless
+1327147    ps
+1327178    ntfsmove
+1327271    mv
+1327187    mount
+1327259    false
+1327266    tempfile
+1327285    zfgrep
+1327165    gzexe
+1327204    nc.openbsd
+1327260    uname
+
+
+Details of implementation
+-------------------------
+fileproto.proto contains the portable Google Protocol Buffers protocol definition.
+It could be used as-is to implement a server or a client in any other language, for
+example Python or Java.
+
+fileproto.options contains the nanopb-specific options for the protocol file. This
+sets the amount of space allocated for file names when decoding messages.
+
+common.c/h contains functions that allow nanopb to read and write directly from
+network socket. This way there is no need to allocate a separate buffer to store
+the message.
+
+server.c contains the code to open a listening socket, to respond to clients and
+to list directory contents.
+
+client.c contains the code to connect to a server, to send a request and to print
+the response message.
+
+The code is implemented using the POSIX socket api, but it should be easy enough
+to port into any other socket api, such as lwip.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/client.c
@@ -0,0 +1,142 @@
+/* This is a simple TCP client that connects to port 1234 and prints a list
+ * of files in a given directory.
+ *
+ * It directly deserializes and serializes messages from network, minimizing
+ * memory use.
+ * 
+ * For flexibility, this example is implemented using posix api.
+ * In a real embedded system you would typically use some other kind of
+ * a communication and filesystem layer.
+ */
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <pb_encode.h>
+#include <pb_decode.h>
+
+#include "fileproto.pb.h"
+#include "common.h"
+
+/* This callback function will be called once for each filename received
+ * from the server. The filenames will be printed out immediately, so that
+ * no memory has to be allocated for them.
+ */
+bool printfile_callback(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    FileInfo fileinfo = {};
+    
+    if (!pb_decode(stream, FileInfo_fields, &fileinfo))
+        return false;
+    
+    printf("%-10lld %s\n", (long long)fileinfo.inode, fileinfo.name);
+    
+    return true;
+}
+
+/* This function sends a request to socket 'fd' to list the files in
+ * directory given in 'path'. The results received from server will
+ * be printed to stdout.
+ */
+bool listdir(int fd, char *path)
+{
+    /* Construct and send the request to server */
+    {
+        ListFilesRequest request = {};
+        pb_ostream_t output = pb_ostream_from_socket(fd);
+        uint8_t zero = 0;
+        
+        /* In our protocol, path is optional. If it is not given,
+         * the server will list the root directory. */
+        if (path == NULL)
+        {
+            request.has_path = false;
+        }
+        else
+        {
+            request.has_path = true;
+            if (strlen(path) + 1 > sizeof(request.path))
+            {
+                fprintf(stderr, "Too long path.\n");
+                return false;
+            }
+            
+            strcpy(request.path, path);
+        }
+        
+        /* Encode the request. It is written to the socket immediately
+         * through our custom stream. */
+        if (!pb_encode(&output, ListFilesRequest_fields, &request))
+        {
+            fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&output));
+            return false;
+        }
+        
+        /* We signal the end of request with a 0 tag. */
+        pb_write(&output, &zero, 1);
+    }
+    
+    /* Read back the response from server */
+    {
+        ListFilesResponse response = {};
+        pb_istream_t input = pb_istream_from_socket(fd);
+        
+        /* Give a pointer to our callback function, which will handle the
+         * filenames as they arrive. */
+        response.file.funcs.decode = &printfile_callback;
+        
+        if (!pb_decode(&input, ListFilesResponse_fields, &response))
+        {
+            fprintf(stderr, "Decode failed: %s\n", PB_GET_ERROR(&input));
+            return false;
+        }
+        
+        /* If the message from server decodes properly, but directory was
+         * not found on server side, we get path_error == true. */
+        if (response.path_error)
+        {
+            fprintf(stderr, "Server reported error.\n");
+            return false;
+        }
+    }
+    
+    return true;
+}
+
+int main(int argc, char **argv)
+{
+    int sockfd;
+    struct sockaddr_in servaddr;
+    char *path = NULL;
+    
+    if (argc > 1)
+        path = argv[1];
+    
+    sockfd = socket(AF_INET, SOCK_STREAM, 0);
+    
+    /* Connect to server running on localhost:1234 */
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family = AF_INET;
+    servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    servaddr.sin_port = htons(1234);
+    
+    if (connect(sockfd, (struct sockaddr *)&servaddr, sizeof(servaddr)) != 0)
+    {
+        perror("connect");
+        return 1;
+    }
+    
+    /* Send the directory listing request */
+    if (!listdir(sockfd, path))
+        return 2;
+    
+    /* Close connection */
+    close(sockfd);
+    
+    return 0;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/common.c
@@ -0,0 +1,40 @@
+/* Simple binding of nanopb streams to TCP sockets.
+ */
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <pb_encode.h>
+#include <pb_decode.h>
+
+#include "common.h"
+
+static bool write_callback(pb_ostream_t *stream, const uint8_t *buf, size_t count)
+{
+    int fd = (intptr_t)stream->state;
+    return send(fd, buf, count, 0) == count;
+}
+
+static bool read_callback(pb_istream_t *stream, uint8_t *buf, size_t count)
+{
+    int fd = (intptr_t)stream->state;
+    int result;
+    
+    result = recv(fd, buf, count, MSG_WAITALL);
+    
+    if (result == 0)
+        stream->bytes_left = 0; /* EOF */
+    
+    return result == count;
+}
+
+pb_ostream_t pb_ostream_from_socket(int fd)
+{
+    pb_ostream_t stream = {&write_callback, (void*)(intptr_t)fd, SIZE_MAX, 0};
+    return stream;
+}
+
+pb_istream_t pb_istream_from_socket(int fd)
+{
+    pb_istream_t stream = {&read_callback, (void*)(intptr_t)fd, SIZE_MAX};
+    return stream;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/common.h
@@ -0,0 +1,9 @@
+#ifndef _PB_EXAMPLE_COMMON_H_
+#define _PB_EXAMPLE_COMMON_H_
+
+#include <pb.h>
+
+pb_ostream_t pb_ostream_from_socket(int fd);
+pb_istream_t pb_istream_from_socket(int fd);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/fileproto.options
@@ -0,0 +1,13 @@
+# This file defines the nanopb-specific options for the messages defined
+# in fileproto.proto.
+#
+# If you come from high-level programming background, the hardcoded
+# maximum lengths may disgust you. However, if your microcontroller only
+# has a few kB of ram to begin with, setting reasonable limits for
+# filenames is ok.
+#
+# On the other hand, using the callback interface, it is not necessary
+# to set a limit on the number of files in the response.
+
+ListFilesRequest.path 	max_size:128
+FileInfo.name 		max_size:128
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/fileproto.proto
@@ -0,0 +1,20 @@
+// This defines protocol for a simple server that lists files.
+//
+// See also the nanopb-specific options in fileproto.options.
+
+syntax = "proto2";
+
+message ListFilesRequest {
+    optional string path = 1 [default = "/"];
+}
+
+message FileInfo {
+    required uint64 inode = 1;
+    required string name = 2;
+}
+
+message ListFilesResponse {
+    optional bool path_error = 1 [default = false];
+    repeated FileInfo file = 2;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/network_server/server.c
@@ -0,0 +1,158 @@
+/* This is a simple TCP server that listens on port 1234 and provides lists
+ * of files to clients, using a protocol defined in file_server.proto.
+ *
+ * It directly deserializes and serializes messages from network, minimizing
+ * memory use.
+ * 
+ * For flexibility, this example is implemented using posix api.
+ * In a real embedded system you would typically use some other kind of
+ * a communication and filesystem layer.
+ */
+
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <pb_encode.h>
+#include <pb_decode.h>
+
+#include "fileproto.pb.h"
+#include "common.h"
+
+/* This callback function will be called once during the encoding.
+ * It will write out any number of FileInfo entries, without consuming unnecessary memory.
+ * This is accomplished by fetching the filenames one at a time and encoding them
+ * immediately.
+ */
+bool listdir_callback(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    DIR *dir = (DIR*) *arg;
+    struct dirent *file;
+    FileInfo fileinfo = {};
+    
+    while ((file = readdir(dir)) != NULL)
+    {
+        fileinfo.inode = file->d_ino;
+        strncpy(fileinfo.name, file->d_name, sizeof(fileinfo.name));
+        fileinfo.name[sizeof(fileinfo.name) - 1] = '\0';
+        
+        /* This encodes the header for the field, based on the constant info
+         * from pb_field_t. */
+        if (!pb_encode_tag_for_field(stream, field))
+            return false;
+        
+        /* This encodes the data for the field, based on our FileInfo structure. */
+        if (!pb_encode_submessage(stream, FileInfo_fields, &fileinfo))
+            return false;
+    }
+    
+    return true;
+}
+
+/* Handle one arriving client connection.
+ * Clients are expected to send a ListFilesRequest, terminated by a '0'.
+ * Server will respond with a ListFilesResponse message.
+ */
+void handle_connection(int connfd)
+{
+    DIR *directory = NULL;
+    
+    /* Decode the message from the client and open the requested directory. */
+    {
+        ListFilesRequest request = {};
+        pb_istream_t input = pb_istream_from_socket(connfd);
+        
+        if (!pb_decode(&input, ListFilesRequest_fields, &request))
+        {
+            printf("Decode failed: %s\n", PB_GET_ERROR(&input));
+            return;
+        }
+        
+        directory = opendir(request.path);
+        printf("Listing directory: %s\n", request.path);
+    }
+    
+    /* List the files in the directory and transmit the response to client */
+    {
+        ListFilesResponse response = {};
+        pb_ostream_t output = pb_ostream_from_socket(connfd);
+        
+        if (directory == NULL)
+        {
+            perror("opendir");
+            
+            /* Directory was not found, transmit error status */
+            response.has_path_error = true;
+            response.path_error = true;
+            response.file.funcs.encode = NULL;
+        }
+        else
+        {
+            /* Directory was found, transmit filenames */
+            response.has_path_error = false;
+            response.file.funcs.encode = &listdir_callback;
+            response.file.arg = directory;
+        }
+        
+        if (!pb_encode(&output, ListFilesResponse_fields, &response))
+        {
+            printf("Encoding failed: %s\n", PB_GET_ERROR(&output));
+        }
+    }
+    
+    if (directory != NULL)
+        closedir(directory);
+}
+
+int main(int argc, char **argv)
+{
+    int listenfd, connfd;
+    struct sockaddr_in servaddr;
+    int reuse = 1;
+    
+    /* Listen on localhost:1234 for TCP connections */
+    listenfd = socket(AF_INET, SOCK_STREAM, 0);
+    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(reuse));
+    
+    memset(&servaddr, 0, sizeof(servaddr));
+    servaddr.sin_family = AF_INET;
+    servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+    servaddr.sin_port = htons(1234);
+    if (bind(listenfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) != 0)
+    {
+        perror("bind");
+        return 1;
+    }
+    
+    if (listen(listenfd, 5) != 0)
+    {
+        perror("listen");
+        return 1;
+    }
+    
+    for(;;)
+    {
+        /* Wait for a client */
+        connfd = accept(listenfd, NULL, NULL);
+        
+        if (connfd < 0)
+        {
+            perror("accept");
+            return 1;
+        }
+        
+        printf("Got connection.\n");
+        
+        handle_connection(connfd);
+        
+        printf("Closing connection.\n");
+        
+        close(connfd);
+    }
+    
+    return 0;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/simple/Makefile
@@ -0,0 +1,22 @@
+# Include the nanopb provided Makefile rules
+include ../../extra/nanopb.mk
+
+# Compiler flags to enable all warnings & debug info
+CFLAGS = -Wall -Werror -g -O0
+CFLAGS += -I$(NANOPB_DIR)
+
+# C source code files that are required
+CSRC  = simple.c                   # The main program
+CSRC += simple.pb.c                # The compiled protocol definition
+CSRC += $(NANOPB_DIR)/pb_encode.c  # The nanopb encoder
+CSRC += $(NANOPB_DIR)/pb_decode.c  # The nanopb decoder
+CSRC += $(NANOPB_DIR)/pb_common.c  # The nanopb common parts
+
+# Build rule for the main program
+simple: $(CSRC)
+	$(CC) $(CFLAGS) -osimple $(CSRC)
+
+# Build rule for the protocol
+simple.pb.c: simple.proto
+	$(PROTOC) $(PROTOC_OPTS) --nanopb_out=. simple.proto
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/simple/README.txt
@@ -0,0 +1,29 @@
+Nanopb example "simple"
+=======================
+
+This example demonstrates the very basic use of nanopb. It encodes and
+decodes a simple message.
+
+The code uses four different API functions:
+
+  * pb_ostream_from_buffer() to declare the output buffer that is to be used
+  * pb_encode() to encode a message
+  * pb_istream_from_buffer() to declare the input buffer that is to be used
+  * pb_decode() to decode a message
+
+Example usage
+-------------
+
+On Linux, simply type "make" to build the example. After that, you can
+run it with the command: ./simple
+
+On other platforms, you first have to compile the protocol definition using
+the following command::
+
+  ../../generator-bin/protoc --nanopb_out=. simple.proto
+
+After that, add the following four files to your project and compile:
+
+  simple.c  simple.pb.c  pb_encode.c  pb_decode.c
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/simple/simple.c
@@ -0,0 +1,71 @@
+#include <stdio.h>
+#include <pb_encode.h>
+#include <pb_decode.h>
+#include "simple.pb.h"
+
+int main()
+{
+    /* This is the buffer where we will store our message. */
+    uint8_t buffer[128];
+    size_t message_length;
+    bool status;
+    
+    /* Encode our message */
+    {
+        /* Allocate space on the stack to store the message data.
+         *
+         * Nanopb generates simple struct definitions for all the messages.
+         * - check out the contents of simple.pb.h!
+         * It is a good idea to always initialize your structures
+         * so that you do not have garbage data from RAM in there.
+         */
+        SimpleMessage message = SimpleMessage_init_zero;
+        
+        /* Create a stream that will write to our buffer. */
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        /* Fill in the lucky number */
+        message.lucky_number = 13;
+        
+        /* Now we are ready to encode the message! */
+        status = pb_encode(&stream, SimpleMessage_fields, &message);
+        message_length = stream.bytes_written;
+        
+        /* Then just check for any errors.. */
+        if (!status)
+        {
+            printf("Encoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1;
+        }
+    }
+    
+    /* Now we could transmit the message over network, store it in a file or
+     * wrap it to a pigeon's leg.
+     */
+
+    /* But because we are lazy, we will just decode it immediately. */
+    
+    {
+        /* Allocate space for the decoded message. */
+        SimpleMessage message = SimpleMessage_init_zero;
+        
+        /* Create a stream that reads from the buffer. */
+        pb_istream_t stream = pb_istream_from_buffer(buffer, message_length);
+        
+        /* Now we are ready to decode the message. */
+        status = pb_decode(&stream, SimpleMessage_fields, &message);
+        
+        /* Check for errors... */
+        if (!status)
+        {
+            printf("Decoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1;
+        }
+        
+        /* Print the data contained in the message. */
+        printf("Your lucky number was %d!\n", message.lucky_number);
+    }
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/simple/simple.proto
@@ -0,0 +1,9 @@
+// A very simple protocol definition, consisting of only
+// one message.
+
+syntax = "proto2";
+
+message SimpleMessage {
+    required int32 lucky_number = 1;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/Makefile
@@ -0,0 +1,24 @@
+# Include the nanopb provided Makefile rules
+include ../../extra/nanopb.mk
+
+# Compiler flags to enable all warnings & debug info
+CFLAGS = -Wall -Werror -g -O0
+CFLAGS += -I$(NANOPB_DIR)
+
+all: run_tests
+
+.SUFFIXES:
+
+clean:
+	rm -f test_conversions encode_double decode_double doubleproto.pb.c doubleproto.pb.h
+
+test_conversions: test_conversions.c double_conversion.c
+	$(CC) $(CFLAGS) -o $@ $^
+
+%: %.c double_conversion.c doubleproto.pb.c
+	$(CC) $(CFLAGS) -o $@ $^ $(NANOPB_CORE)
+
+run_tests: test_conversions encode_double decode_double
+	./test_conversions
+	./encode_double | ./decode_double
+    
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/README.txt
@@ -0,0 +1,25 @@
+Nanopb example "using_double_on_avr"
+====================================
+
+Some processors/compilers, such as AVR-GCC, do not support the double
+datatype. Instead, they have sizeof(double) == 4. Because protocol
+binary format uses the double encoding directly, this causes trouble
+if the protocol in .proto requires double fields.
+
+This directory contains a solution to this problem. It uses uint64_t
+to store the raw wire values, because its size is correct on all
+platforms. The file double_conversion.c provides functions that
+convert these values to/from floats, without relying on compiler
+support.
+
+To use this method, you need to make some modifications to your code:
+
+1) Change all 'double' fields into 'fixed64' in the .proto.
+
+2) Whenever writing to a 'double' field, use float_to_double().
+
+3) Whenever reading a 'double' field, use double_to_float().
+
+The conversion routines are as accurate as the float datatype can
+be. Furthermore, they should handle all special values (NaN, inf, denormalized
+numbers) correctly. There are testcases in test_conversions.c.
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/decode_double.c
@@ -0,0 +1,33 @@
+/* Decodes a double value into a float variable.
+ * Used to read double values with AVR code, which doesn't support double directly.
+ */
+
+#include <stdio.h>
+#include <pb_decode.h>
+#include "double_conversion.h"
+#include "doubleproto.pb.h"
+
+int main()
+{
+    uint8_t buffer[32];
+    size_t count = fread(buffer, 1, sizeof(buffer), stdin);
+    pb_istream_t stream = pb_istream_from_buffer(buffer, count);
+    
+    AVRDoubleMessage message;
+    pb_decode(&stream, AVRDoubleMessage_fields, &message);
+    
+    float v1 = double_to_float(message.field1);
+    float v2 = double_to_float(message.field2);
+
+    printf("Values: %f %f\n", v1, v2);
+    
+    if (v1 == 1234.5678f &&
+        v2 == 0.00001f)
+    {
+        return 0;
+    }
+    else
+    {
+        return 1;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/double_conversion.c
@@ -0,0 +1,123 @@
+/* Conversion routines for platforms that do not support 'double' directly. */
+
+#include "double_conversion.h"
+#include <math.h>
+
+typedef union {
+    float f;
+    uint32_t i;
+} conversion_t;
+
+/* Note: IEE 754 standard specifies float formats as follows:
+ * Single precision: sign,  8-bit exp, 23-bit frac.
+ * Double precision: sign, 11-bit exp, 52-bit frac.
+ */
+
+uint64_t float_to_double(float value)
+{
+    conversion_t in;
+    in.f = value;
+    uint8_t sign;
+    int16_t exponent;
+    uint64_t mantissa;
+    
+    /* Decompose input value */
+    sign = (in.i >> 31) & 1;
+    exponent = ((in.i >> 23) & 0xFF) - 127;
+    mantissa = in.i & 0x7FFFFF;
+    
+    if (exponent == 128)
+    {
+        /* Special value (NaN etc.) */
+        exponent = 1024;
+    }
+    else if (exponent == -127)
+    {
+        if (!mantissa)
+        {
+            /* Zero */
+            exponent = -1023;
+        }
+        else
+        {
+            /* Denormalized */
+            mantissa <<= 1;
+            while (!(mantissa & 0x800000))
+            {
+                mantissa <<= 1;
+                exponent--;
+            }
+            mantissa &= 0x7FFFFF;
+        }
+    }
+    
+    /* Combine fields */
+    mantissa <<= 29;
+    mantissa |= (uint64_t)(exponent + 1023) << 52;
+    mantissa |= (uint64_t)sign << 63;
+    
+    return mantissa;
+}
+
+float double_to_float(uint64_t value)
+{
+    uint8_t sign;
+    int16_t exponent;
+    uint32_t mantissa;
+    conversion_t out;
+
+    /* Decompose input value */
+    sign = (value >> 63) & 1;
+    exponent = ((value >> 52) & 0x7FF) - 1023;
+    mantissa = (value >> 28) & 0xFFFFFF; /* Highest 24 bits */
+ 
+    /* Figure if value is in range representable by floats. */
+    if (exponent == 1024)
+    {
+        /* Special value */
+        exponent = 128;
+    }
+    else if (exponent > 127)
+    {
+        /* Too large */        
+        if (sign)
+            return -INFINITY;
+        else
+            return INFINITY;
+    }
+    else if (exponent < -150)
+    {
+        /* Too small */
+        if (sign)
+            return -0.0f;
+        else
+            return 0.0f;
+    }
+    else if (exponent < -126)
+    {
+        /* Denormalized */
+        mantissa |= 0x1000000;
+        mantissa >>= (-126 - exponent);
+        exponent = -127;
+    }
+ 
+    /* Round off mantissa */
+    mantissa = (mantissa + 1) >> 1;
+    
+    /* Check if mantissa went over 2.0 */
+    if (mantissa & 0x800000)
+    {
+        exponent += 1;
+        mantissa &= 0x7FFFFF;
+        mantissa >>= 1;
+    }
+    
+    /* Combine fields */
+    out.i = mantissa;
+    out.i |= (uint32_t)(exponent + 127) << 23;
+    out.i |= (uint32_t)sign << 31;
+    
+    return out.f;
+}
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/double_conversion.h
@@ -0,0 +1,26 @@
+/* AVR-GCC does not have real double datatype. Instead its double
+ * is equal to float, i.e. 32 bit value. If you need to communicate
+ * with other systems that use double in their .proto files, you
+ * need to do some conversion.
+ *
+ * These functions use bitwise operations to mangle floats into doubles
+ * and then store them in uint64_t datatype.
+ */
+
+#ifndef DOUBLE_CONVERSION
+#define DOUBLE_CONVERSION
+
+#include <stdint.h>
+
+/* Convert native 4-byte float into a 8-byte double. */
+extern uint64_t float_to_double(float value);
+
+/* Convert 8-byte double into native 4-byte float.
+ * Values are rounded to nearest, 0.5 away from zero.
+ * Overflowing values are converted to Inf or -Inf.
+ */
+extern float double_to_float(uint64_t value);
+
+
+#endif
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/doubleproto.proto
@@ -0,0 +1,15 @@
+// A message containing doubles, as used by other applications.
+syntax = "proto2";
+
+message DoubleMessage {
+    required double field1 = 1;
+    required double field2 = 2;
+}
+
+// A message containing doubles, but redefined using uint64_t.
+// For use in AVR code.
+message AVRDoubleMessage {
+    required fixed64 field1 = 1;
+    required fixed64 field2 = 2;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/encode_double.c
@@ -0,0 +1,25 @@
+/* Encodes a float value into a double on the wire.
+ * Used to emit doubles from AVR code, which doesn't support double directly.
+ */
+
+#include <stdio.h>
+#include <pb_encode.h>
+#include "double_conversion.h"
+#include "doubleproto.pb.h"
+
+int main()
+{
+    AVRDoubleMessage message = {
+        float_to_double(1234.5678f),
+        float_to_double(0.00001f)
+    };
+    
+    uint8_t buffer[32];
+    pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+    
+    pb_encode(&stream, AVRDoubleMessage_fields, &message);
+    fwrite(buffer, 1, stream.bytes_written, stdout);
+
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_double_on_avr/test_conversions.c
@@ -0,0 +1,56 @@
+#include "double_conversion.h"
+#include <math.h>
+#include <stdio.h>
+
+static const double testvalues[] = {
+           0.0,        -0.0,         0.1,         -0.1,
+          M_PI,       -M_PI,  123456.789,  -123456.789,
+      INFINITY,   -INFINITY,         NAN, INFINITY - INFINITY,
+          1e38,       -1e38,        1e39,        -1e39,
+         1e-38,      -1e-38,       1e-39,       -1e-39,
+   3.14159e-37,-3.14159e-37, 3.14159e-43, -3.14159e-43,
+         1e-60,      -1e-60,       1e-45,       -1e-45,
+    0.99999999999999, -0.99999999999999, 127.999999999999, -127.999999999999
+};
+
+#define TESTVALUES_COUNT (sizeof(testvalues)/sizeof(testvalues[0]))
+
+int main()
+{
+    int status = 0;
+    int i;
+    for (i = 0; i < TESTVALUES_COUNT; i++)
+    {
+        double orig = testvalues[i];
+        float expected_float = (float)orig;
+        double expected_double = (double)expected_float;
+        
+        float got_float = double_to_float(*(uint64_t*)&orig);
+        uint64_t got_double = float_to_double(got_float);
+        
+        uint32_t e1 = *(uint32_t*)&expected_float;
+        uint32_t g1 = *(uint32_t*)&got_float;
+        uint64_t e2 = *(uint64_t*)&expected_double;
+        uint64_t g2 = got_double;
+        
+        if (g1 != e1)
+        {
+            printf("%3d double_to_float fail: %08x != %08x\n", i, g1, e1);
+            status = 1;
+        }
+        
+        if (g2 != e2)
+        {
+            printf("%3d float_to_double fail: %016llx != %016llx\n", i,
+                (unsigned long long)g2,
+                (unsigned long long)e2);
+            status = 1;
+        }
+    }
+
+    return status;
+}
+
+    
+    
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_union_messages/Makefile
@@ -0,0 +1,20 @@
+# Include the nanopb provided Makefile rules
+include ../../extra/nanopb.mk
+
+# Compiler flags to enable all warnings & debug info
+CFLAGS = -ansi -Wall -Werror -g -O0
+CFLAGS += -I$(NANOPB_DIR)
+
+all: encode decode
+	./encode 1 | ./decode
+	./encode 2 | ./decode
+	./encode 3 | ./decode
+
+.SUFFIXES:
+
+clean:
+	rm -f encode unionproto.pb.h unionproto.pb.c
+
+%: %.c unionproto.pb.c
+	$(CC) $(CFLAGS) -o $@ $^ $(NANOPB_CORE)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_union_messages/README.txt
@@ -0,0 +1,52 @@
+Nanopb example "using_union_messages"
+=====================================
+
+Union messages is a common technique in Google Protocol Buffers used to
+represent a group of messages, only one of which is passed at a time.
+It is described in Google's documentation:
+https://developers.google.com/protocol-buffers/docs/techniques#union
+
+This directory contains an example on how to encode and decode union messages
+with minimal memory usage. Usually, nanopb would allocate space to store
+all of the possible messages at the same time, even though at most one of
+them will be used at a time.
+
+By using some of the lower level nanopb APIs, we can manually generate the
+top level message, so that we only need to allocate the one submessage that
+we actually want. Similarly when decoding, we can manually read the tag of
+the top level message, and only then allocate the memory for the submessage
+after we already know its type.
+
+
+Example usage
+-------------
+
+Type `make` to run the example. It will build it and run commands like
+following:
+
+./encode 1 | ./decode
+Got MsgType1: 42
+./encode 2 | ./decode
+Got MsgType2: true
+./encode 3 | ./decode
+Got MsgType3: 3 1415
+
+This simply demonstrates that the "decode" program has correctly identified
+the type of the received message, and managed to decode it.
+
+
+Details of implementation
+-------------------------
+
+unionproto.proto contains the protocol used in the example. It consists of
+three messages: MsgType1, MsgType2 and MsgType3, which are collected together
+into UnionMessage.
+
+encode.c takes one command line argument, which should be a number 1-3. It
+then fills in and encodes the corresponding message, and writes it to stdout.
+
+decode.c reads a UnionMessage from stdin. Then it calls the function
+decode_unionmessage_type() to determine the type of the message. After that,
+the corresponding message is decoded and the contents of it printed to the
+screen.
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_union_messages/decode.c
@@ -0,0 +1,96 @@
+/* This program reads a message from stdin, detects its type and decodes it.
+ */
+ 
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <pb_decode.h>
+#include "unionproto.pb.h"
+
+/* This function reads manually the first tag from the stream and finds the
+ * corresponding message type. It doesn't yet decode the actual message.
+ *
+ * Returns a pointer to the MsgType_fields array, as an identifier for the
+ * message type. Returns null if the tag is of unknown type or an error occurs.
+ */
+const pb_field_t* decode_unionmessage_type(pb_istream_t *stream)
+{
+    pb_wire_type_t wire_type;
+    uint32_t tag;
+    bool eof;
+
+    while (pb_decode_tag(stream, &wire_type, &tag, &eof))
+    {
+        if (wire_type == PB_WT_STRING)
+        {
+            const pb_field_t *field;
+            for (field = UnionMessage_fields; field->tag != 0; field++)
+            {
+                if (field->tag == tag && (field->type & PB_LTYPE_SUBMESSAGE))
+                {
+                    /* Found our field. */
+                    return field->ptr;
+                }
+            }
+        }
+        
+        /* Wasn't our field.. */
+        pb_skip_field(stream, wire_type);
+    }
+    
+    return NULL;
+}
+
+bool decode_unionmessage_contents(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    pb_istream_t substream;
+    bool status;
+    if (!pb_make_string_substream(stream, &substream))
+        return false;
+    
+    status = pb_decode(&substream, fields, dest_struct);
+    pb_close_string_substream(stream, &substream);
+    return status;
+}
+
+int main()
+{
+    /* Read the data into buffer */
+    uint8_t buffer[512];
+    size_t count = fread(buffer, 1, sizeof(buffer), stdin);
+    pb_istream_t stream = pb_istream_from_buffer(buffer, count);
+    
+    const pb_field_t *type = decode_unionmessage_type(&stream);
+    bool status = false;
+    
+    if (type == MsgType1_fields)
+    {
+        MsgType1 msg = {};
+        status = decode_unionmessage_contents(&stream, MsgType1_fields, &msg);
+        printf("Got MsgType1: %d\n", msg.value);
+    }
+    else if (type == MsgType2_fields)
+    {
+        MsgType2 msg = {};
+        status = decode_unionmessage_contents(&stream, MsgType2_fields, &msg);
+        printf("Got MsgType2: %s\n", msg.value ? "true" : "false");
+    }
+    else if (type == MsgType3_fields)
+    {
+        MsgType3 msg = {};
+        status = decode_unionmessage_contents(&stream, MsgType3_fields, &msg);
+        printf("Got MsgType3: %d %d\n", msg.value1, msg.value2);    
+    }
+    
+    if (!status)
+    {
+        printf("Decode failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    }
+    
+    return 0;
+}
+
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_union_messages/encode.c
@@ -0,0 +1,85 @@
+/* This program takes a command line argument and encodes a message in
+ * one of MsgType1, MsgType2 or MsgType3.
+ */
+ 
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include <pb_encode.h>
+#include "unionproto.pb.h"
+
+/* This function is the core of the union encoding process. It handles
+ * the top-level pb_field_t array manually, in order to encode a correct
+ * field tag before the message. The pointer to MsgType_fields array is
+ * used as an unique identifier for the message type.
+ */
+bool encode_unionmessage(pb_ostream_t *stream, const pb_field_t messagetype[], const void *message)
+{
+    const pb_field_t *field;
+    for (field = UnionMessage_fields; field->tag != 0; field++)
+    {
+        if (field->ptr == messagetype)
+        {
+            /* This is our field, encode the message using it. */
+            if (!pb_encode_tag_for_field(stream, field))
+                return false;
+            
+            return pb_encode_submessage(stream, messagetype, message);
+        }
+    }
+    
+    /* Didn't find the field for messagetype */
+    return false;
+}
+
+int main(int argc, char **argv)
+{
+    if (argc != 2)
+    {
+        fprintf(stderr, "Usage: %s (1|2|3)\n", argv[0]);
+        return 1;
+    }
+    
+    uint8_t buffer[512];
+    pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+    
+    bool status = false;
+    int msgtype = atoi(argv[1]);
+    if (msgtype == 1)
+    {
+        /* Send message of type 1 */
+        MsgType1 msg = {42};
+        status = encode_unionmessage(&stream, MsgType1_fields, &msg);
+    }
+    else if (msgtype == 2)
+    {
+        /* Send message of type 2 */
+        MsgType2 msg = {true};
+        status = encode_unionmessage(&stream, MsgType2_fields, &msg);
+    }
+    else if (msgtype == 3)
+    {
+        /* Send message of type 3 */
+        MsgType3 msg = {3, 1415};
+        status = encode_unionmessage(&stream, MsgType3_fields, &msg);
+    }
+    else
+    {
+        fprintf(stderr, "Unknown message type: %d\n", msgtype);
+        return 2;
+    }
+    
+    if (!status)
+    {
+        fprintf(stderr, "Encoding failed!\n");
+        return 3;
+    }
+    else
+    {
+        fwrite(buffer, 1, stream.bytes_written, stdout);
+        return 0; /* Success */
+    }
+}
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/examples/using_union_messages/unionproto.proto
@@ -0,0 +1,32 @@
+// This is an example of how to handle 'union' style messages
+// with nanopb, without allocating memory for all the message types.
+//
+// There is no official type in Protocol Buffers for describing unions,
+// but they are commonly implemented by filling out exactly one of
+// several optional fields.
+
+syntax = "proto2";
+
+message MsgType1
+{
+    required int32 value = 1;
+}
+
+message MsgType2
+{
+    required bool value = 1;
+}
+
+message MsgType3
+{
+    required int32 value1 = 1;
+    required int32 value2 = 2;
+}
+
+message UnionMessage
+{
+    optional MsgType1 msg1 = 1;
+    optional MsgType2 msg2 = 2;
+    optional MsgType3 msg3 = 3;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/extra/FindNanopb.cmake
@@ -0,0 +1,274 @@
+# This is an example script for use with CMake projects for locating and configuring
+# the nanopb library.
+#
+# The following variables can be set and are optional:
+#
+#
+#   PROTOBUF_SRC_ROOT_FOLDER - When compiling with MSVC, if this cache variable is set
+#                              the protobuf-default VS project build locations
+#                              (vsprojects/Debug & vsprojects/Release) will be searched
+#                              for libraries and binaries.
+#
+#   NANOPB_IMPORT_DIRS       - List of additional directories to be searched for
+#                              imported .proto files.
+#
+#   NANOPB_GENERATE_CPP_APPEND_PATH - By default -I will be passed to protoc
+#                                     for each directory where a proto file is referenced.
+#                                     Set to FALSE if you want to disable this behaviour.
+#
+# Defines the following variables:
+#
+#   NANOPB_FOUND - Found the nanopb library (source&header files, generator tool, protoc compiler tool)
+#   NANOPB_INCLUDE_DIRS - Include directories for Google Protocol Buffers
+#
+# The following cache variables are also available to set or use:
+#   PROTOBUF_PROTOC_EXECUTABLE - The protoc compiler
+#   NANOPB_GENERATOR_SOURCE_DIR - The nanopb generator source
+#
+#  ====================================================================
+#
+# NANOPB_GENERATE_CPP (public function)
+#   SRCS = Variable to define with autogenerated
+#          source files
+#   HDRS = Variable to define with autogenerated
+#          header files
+#   ARGN = proto files
+#
+#  ====================================================================
+#  Example:
+#
+#   set(NANOPB_SRC_ROOT_FOLDER "/path/to/nanopb")
+#   set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${NANOPB_SRC_ROOT_FOLDER}/cmake)
+#   find_package( Nanopb REQUIRED )
+#   include_directories(${NANOPB_INCLUDE_DIRS})
+#
+#   NANOPB_GENERATE_CPP(PROTO_SRCS PROTO_HDRS foo.proto)
+#
+#   include_directories(${CMAKE_CURRENT_BINARY_DIR})
+#   add_executable(bar bar.cc ${PROTO_SRCS} ${PROTO_HDRS})
+#
+#  ====================================================================
+
+#=============================================================================
+# Copyright 2009 Kitware, Inc.
+# Copyright 2009-2011 Philip Lowman <philip@yhbt.com>
+# Copyright 2008 Esben Mose Hansen, Ange Optimization ApS
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions
+# are met:
+#
+# * Redistributions of source code must retain the above copyright
+#   notice, this list of conditions and the following disclaimer.
+#
+# * Redistributions in binary form must reproduce the above copyright
+#   notice, this list of conditions and the following disclaimer in the
+#   documentation and/or other materials provided with the distribution.
+#
+# * Neither the names of Kitware, Inc., the Insight Software Consortium,
+#   nor the names of their contributors may be used to endorse or promote
+#   products derived from this software without specific prior written
+#   permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#=============================================================================
+#
+# Changes
+# 2013.01.31 - Pavlo Ilin - used Modules/FindProtobuf.cmake from cmake 2.8.10 to
+#                           write FindNanopb.cmake
+#
+#=============================================================================
+
+
+function(NANOPB_GENERATE_CPP SRCS HDRS)
+  if(NOT ARGN)
+    return()
+  endif()
+
+  if(NANOPB_GENERATE_CPP_APPEND_PATH)
+    # Create an include path for each file specified
+    foreach(FIL ${ARGN})
+      get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
+      get_filename_component(ABS_PATH ${ABS_FIL} PATH)
+
+      list(FIND _nanobp_include_path ${ABS_PATH} _contains_already)
+      if(${_contains_already} EQUAL -1)
+          list(APPEND _nanobp_include_path -I ${ABS_PATH})
+      endif()
+    endforeach()
+  else()
+    set(_nanobp_include_path -I ${CMAKE_CURRENT_SOURCE_DIR})
+  endif()
+
+  if(DEFINED NANOPB_IMPORT_DIRS)
+    foreach(DIR ${NANOPB_IMPORT_DIRS})
+      get_filename_component(ABS_PATH ${DIR} ABSOLUTE)
+      list(FIND _nanobp_include_path ${ABS_PATH} _contains_already)
+      if(${_contains_already} EQUAL -1)
+          list(APPEND _nanobp_include_path -I ${ABS_PATH})
+      endif()
+    endforeach()
+  endif()
+
+  set(${SRCS})
+  set(${HDRS})
+
+  set(GENERATOR_PATH ${CMAKE_BINARY_DIR}/nanopb/generator)
+
+  set(NANOPB_GENERATOR_EXECUTABLE ${GENERATOR_PATH}/nanopb_generator.py)
+
+  set(GENERATOR_CORE_DIR ${GENERATOR_PATH}/proto)
+  set(GENERATOR_CORE_SRC
+      ${GENERATOR_CORE_DIR}/nanopb.proto
+      ${GENERATOR_CORE_DIR}/plugin.proto)
+
+  # Treat the source diretory as immutable.
+  #
+  # Copy the generator directory to the build directory before
+  # compiling python and proto files.  Fixes issues when using the
+  # same build directory with different python/protobuf versions
+  # as the binary build directory is discarded across builds.
+  #
+  add_custom_command(
+      OUTPUT ${NANOPB_GENERATOR_EXECUTABLE} ${GENERATOR_CORE_SRC}
+      COMMAND ${CMAKE_COMMAND} -E copy_directory
+      ARGS ${NANOPB_GENERATOR_SOURCE_DIR} ${GENERATOR_PATH}
+      VERBATIM)
+
+  set(GENERATOR_CORE_PYTHON_SRC)
+  foreach(FIL ${GENERATOR_CORE_SRC})
+      get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
+      get_filename_component(FIL_WE ${FIL} NAME_WE)
+
+      set(output "${GENERATOR_CORE_DIR}/${FIL_WE}_pb2.py")
+      set(GENERATOR_CORE_PYTHON_SRC ${GENERATOR_CORE_PYTHON_SRC} ${output})
+      add_custom_command(
+        OUTPUT ${output}
+        COMMAND ${PROTOBUF_PROTOC_EXECUTABLE}
+        ARGS -I${GENERATOR_PATH}/proto
+          --python_out=${GENERATOR_CORE_DIR} ${ABS_FIL}
+        DEPENDS ${ABS_FIL}
+        VERBATIM)
+  endforeach()
+
+  foreach(FIL ${ARGN})
+    get_filename_component(ABS_FIL ${FIL} ABSOLUTE)
+    get_filename_component(FIL_WE ${FIL} NAME_WE)
+    get_filename_component(FIL_DIR ${FIL} PATH)
+    set(NANOPB_OPTIONS_FILE ${FIL_DIR}/${FIL_WE}.options)
+    set(NANOPB_OPTIONS)
+    if(EXISTS ${NANOPB_OPTIONS_FILE})
+        set(NANOPB_OPTIONS -f ${NANOPB_OPTIONS_FILE})
+    endif()
+
+    list(APPEND ${SRCS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.c")
+    list(APPEND ${HDRS} "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.h")
+
+    add_custom_command(
+      OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb"
+      COMMAND  ${PROTOBUF_PROTOC_EXECUTABLE}
+      ARGS -I${GENERATOR_PATH} -I${GENERATOR_CORE_DIR}
+        -I${CMAKE_CURRENT_BINARY_DIR} ${_nanobp_include_path}
+        -o${FIL_WE}.pb ${ABS_FIL}
+      DEPENDS ${ABS_FIL} ${GENERATOR_CORE_PYTHON_SRC}
+      COMMENT "Running C++ protocol buffer compiler on ${FIL}"
+      VERBATIM )
+
+    add_custom_command(
+      OUTPUT "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.c"
+             "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb.h"
+      COMMAND ${PYTHON_EXECUTABLE}
+      ARGS ${NANOPB_GENERATOR_EXECUTABLE} ${FIL_WE}.pb ${NANOPB_OPTIONS}
+      DEPENDS "${CMAKE_CURRENT_BINARY_DIR}/${FIL_WE}.pb"
+      COMMENT "Running nanopb generator on ${FIL_WE}.pb"
+      VERBATIM )
+  endforeach()
+
+  set_source_files_properties(${${SRCS}} ${${HDRS}} PROPERTIES GENERATED TRUE)
+  set(${SRCS} ${${SRCS}} ${NANOPB_SRCS} PARENT_SCOPE)
+  set(${HDRS} ${${HDRS}} ${NANOPB_HDRS} PARENT_SCOPE)
+
+endfunction()
+
+
+
+#
+# Main.
+#
+
+# By default have NANOPB_GENERATE_CPP macro pass -I to protoc
+# for each directory where a proto file is referenced.
+if(NOT DEFINED NANOPB_GENERATE_CPP_APPEND_PATH)
+  set(NANOPB_GENERATE_CPP_APPEND_PATH TRUE)
+endif()
+
+# Make a really good guess regarding location of NANOPB_SRC_ROOT_FOLDER
+if(NOT DEFINED NANOPB_SRC_ROOT_FOLDER)
+  get_filename_component(NANOPB_SRC_ROOT_FOLDER
+                         ${CMAKE_CURRENT_LIST_DIR}/.. ABSOLUTE)
+endif()
+
+# Find the include directory
+find_path(NANOPB_INCLUDE_DIRS
+    pb.h
+    PATHS ${NANOPB_SRC_ROOT_FOLDER}
+)
+mark_as_advanced(NANOPB_INCLUDE_DIRS)
+
+# Find nanopb source files
+set(NANOPB_SRCS)
+set(NANOPB_HDRS)
+list(APPEND _nanopb_srcs pb_decode.c pb_encode.c pb_common.c)
+list(APPEND _nanopb_hdrs pb_decode.h pb_encode.h pb_common.h pb.h)
+
+foreach(FIL ${_nanopb_srcs})
+  find_file(${FIL}__nano_pb_file NAMES ${FIL} PATHS ${NANOPB_SRC_ROOT_FOLDER} ${NANOPB_INCLUDE_DIRS})
+  list(APPEND NANOPB_SRCS "${${FIL}__nano_pb_file}")
+  mark_as_advanced(${FIL}__nano_pb_file)
+endforeach()
+
+foreach(FIL ${_nanopb_hdrs})
+  find_file(${FIL}__nano_pb_file NAMES ${FIL} PATHS ${NANOPB_INCLUDE_DIRS})
+  mark_as_advanced(${FIL}__nano_pb_file)
+  list(APPEND NANOPB_HDRS "${${FIL}__nano_pb_file}")
+endforeach()
+
+# Find the protoc Executable
+find_program(PROTOBUF_PROTOC_EXECUTABLE
+    NAMES protoc
+    DOC "The Google Protocol Buffers Compiler"
+    PATHS
+    ${PROTOBUF_SRC_ROOT_FOLDER}/vsprojects/Release
+    ${PROTOBUF_SRC_ROOT_FOLDER}/vsprojects/Debug
+)
+mark_as_advanced(PROTOBUF_PROTOC_EXECUTABLE)
+
+# Find nanopb generator source dir
+find_path(NANOPB_GENERATOR_SOURCE_DIR
+    NAMES nanopb_generator.py
+    DOC "nanopb generator source"
+    PATHS
+    ${NANOPB_SRC_ROOT_FOLDER}/generator
+)
+mark_as_advanced(NANOPB_GENERATOR_SOURCE_DIR)
+
+find_package(PythonInterp REQUIRED)
+
+include(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(NANOPB DEFAULT_MSG
+  NANOPB_INCLUDE_DIRS
+  NANOPB_SRCS NANOPB_HDRS
+  NANOPB_GENERATOR_SOURCE_DIR
+  PROTOBUF_PROTOC_EXECUTABLE
+  )
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/extra/nanopb.mk
@@ -0,0 +1,37 @@
+# This is an include file for Makefiles. It provides rules for building
+# .pb.c and .pb.h files out of .proto, as well the path to nanopb core.
+
+# Path to the nanopb root directory
+NANOPB_DIR := $(abspath $(dir $(lastword $(MAKEFILE_LIST)))../)
+
+# Files for the nanopb core
+NANOPB_CORE = $(NANOPB_DIR)/pb_encode.c $(NANOPB_DIR)/pb_decode.c $(NANOPB_DIR)/pb_common.c
+
+# Check if we are running on Windows
+ifdef windir
+WINDOWS = 1
+endif
+ifdef WINDIR
+WINDOWS = 1
+endif
+
+# Check whether to use binary version of nanopb_generator or the
+# system-supplied python interpreter.
+ifneq "$(wildcard $(NANOPB_DIR)/generator-bin)" ""
+	# Binary package
+	PROTOC = $(NANOPB_DIR)/generator-bin/protoc
+	PROTOC_OPTS = 
+else
+	# Source only or git checkout
+	PROTOC = protoc
+	ifdef WINDOWS
+		PROTOC_OPTS = --plugin=protoc-gen-nanopb=$(NANOPB_DIR)/generator/protoc-gen-nanopb.bat
+	else
+		PROTOC_OPTS = --plugin=protoc-gen-nanopb=$(NANOPB_DIR)/generator/protoc-gen-nanopb
+	endif
+endif
+
+# Rule for building .pb.c and .pb.h
+%.pb.c %.pb.h: %.proto $(wildcard %.options)
+	$(PROTOC) $(PROTOC_OPTS) --nanopb_out=. $<
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/extra/pb_syshdr.h
@@ -0,0 +1,112 @@
+/* This is an example of a header file for platforms/compilers that do
+ * not come with stdint.h/stddef.h/stdbool.h/string.h. To use it, define
+ * PB_SYSTEM_HEADER as "pb_syshdr.h", including the quotes, and add the
+ * extra folder to your include path.
+ *
+ * It is very likely that you will need to customize this file to suit
+ * your platform. For any compiler that supports C99, this file should
+ * not be necessary.
+ */
+
+#ifndef _PB_SYSHDR_H_
+#define _PB_SYSHDR_H_
+
+/* stdint.h subset */
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#else
+/* You will need to modify these to match the word size of your platform. */
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+typedef signed short int16_t;
+typedef unsigned short uint16_t;
+typedef signed int int32_t;
+typedef unsigned int uint32_t;
+typedef signed long long int64_t;
+typedef unsigned long long uint64_t;
+
+/* These are ok for most platforms, unless uint8_t is actually not available,
+ * in which case you should give the smallest available type. */
+typedef int8_t int_least8_t;
+typedef uint8_t uint_least8_t;
+typedef uint8_t uint_fast8_t;
+typedef int16_t int_least16_t;
+typedef uint16_t uint_least16_t;
+#endif
+
+/* stddef.h subset */
+#ifdef HAVE_STDDEF_H
+#include <stddef.h>
+#else
+
+typedef uint32_t size_t;
+#define offsetof(st, m) ((size_t)(&((st *)0)->m))
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#endif
+
+/* stdbool.h subset */
+#ifdef HAVE_STDBOOL_H
+#include <stdbool.h>
+#else
+
+#ifndef __cplusplus
+typedef int bool;
+#define false 0
+#define true 1
+#endif
+
+#endif
+
+/* stdlib.h subset */
+#ifdef PB_ENABLE_MALLOC
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#else
+void *realloc(void *ptr, size_t size);
+void free(void *ptr);
+#endif
+#endif
+
+/* string.h subset */
+#ifdef HAVE_STRING_H
+#include <string.h>
+#else
+
+/* Implementations are from the Public Domain C Library (PDCLib). */
+static size_t strlen( const char * s )
+{
+    size_t rc = 0;
+    while ( s[rc] )
+    {
+        ++rc;
+    }
+    return rc;
+}
+
+static void * memcpy( void *s1, const void *s2, size_t n )
+{
+    char * dest = (char *) s1;
+    const char * src = (const char *) s2;
+    while ( n-- )
+    {
+        *dest++ = *src++;
+    }
+    return s1;
+}
+
+static void * memset( void * s, int c, size_t n )
+{
+    unsigned char * p = (unsigned char *) s;
+    while ( n-- )
+    {
+        *p++ = (unsigned char) c;
+    }
+    return s;
+}
+#endif
+
+#endif
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/nanopb_generator.py
@@ -0,0 +1,1576 @@
+#!/usr/bin/env python
+
+from __future__ import unicode_literals
+
+'''Generate header file for nanopb from a ProtoBuf FileDescriptorSet.'''
+nanopb_version = "nanopb-0.3.6"
+
+import sys
+import re
+from functools import reduce
+
+try:
+    # Add some dummy imports to keep packaging tools happy.
+    import google, distutils.util # bbfreeze seems to need these
+    import pkg_resources # pyinstaller / protobuf 2.5 seem to need these
+except:
+    # Don't care, we will error out later if it is actually important.
+    pass
+
+try:
+    import google.protobuf.text_format as text_format
+    import google.protobuf.descriptor_pb2 as descriptor
+except:
+    sys.stderr.write('''
+         *************************************************************
+         *** Could not import the Google protobuf Python libraries ***
+         *** Try installing package 'python-protobuf' or similar.  ***
+         *************************************************************
+    ''' + '\n')
+    raise
+
+try:
+    import proto.nanopb_pb2 as nanopb_pb2
+    import proto.plugin_pb2 as plugin_pb2
+except:
+    sys.stderr.write('''
+         ********************************************************************
+         *** Failed to import the protocol definitions for generator.     ***
+         *** You have to run 'make' in the nanopb/generator/proto folder. ***
+         ********************************************************************
+    ''' + '\n')
+    raise
+
+# ---------------------------------------------------------------------------
+#                     Generation of single fields
+# ---------------------------------------------------------------------------
+
+import time
+import os.path
+
+# Values are tuple (c type, pb type, encoded size, int_size_allowed)
+FieldD = descriptor.FieldDescriptorProto
+datatypes = {
+    FieldD.TYPE_BOOL:       ('bool',     'BOOL',        1,  False),
+    FieldD.TYPE_DOUBLE:     ('double',   'DOUBLE',      8,  False),
+    FieldD.TYPE_FIXED32:    ('uint32_t', 'FIXED32',     4,  False),
+    FieldD.TYPE_FIXED64:    ('uint64_t', 'FIXED64',     8,  False),
+    FieldD.TYPE_FLOAT:      ('float',    'FLOAT',       4,  False),
+    FieldD.TYPE_INT32:      ('int32_t',  'INT32',      10,  True),
+    FieldD.TYPE_INT64:      ('int64_t',  'INT64',      10,  True),
+    FieldD.TYPE_SFIXED32:   ('int32_t',  'SFIXED32',    4,  False),
+    FieldD.TYPE_SFIXED64:   ('int64_t',  'SFIXED64',    8,  False),
+    FieldD.TYPE_SINT32:     ('int32_t',  'SINT32',      5,  True),
+    FieldD.TYPE_SINT64:     ('int64_t',  'SINT64',     10,  True),
+    FieldD.TYPE_UINT32:     ('uint32_t', 'UINT32',      5,  True),
+    FieldD.TYPE_UINT64:     ('uint64_t', 'UINT64',     10,  True)
+}
+
+# Integer size overrides (from .proto settings)
+intsizes = {
+    nanopb_pb2.IS_8:     'int8_t',
+    nanopb_pb2.IS_16:    'int16_t',
+    nanopb_pb2.IS_32:    'int32_t',
+    nanopb_pb2.IS_64:    'int64_t',
+}
+
+# String types (for python 2 / python 3 compatibility)
+try:
+    strtypes = (unicode, str)
+except NameError:
+    strtypes = (str, )
+
+class Names:
+    '''Keeps a set of nested names and formats them to C identifier.'''
+    def __init__(self, parts = ()):
+        if isinstance(parts, Names):
+            parts = parts.parts
+        self.parts = tuple(parts)
+
+    def __str__(self):
+        return '_'.join(self.parts)
+
+    def __add__(self, other):
+        if isinstance(other, strtypes):
+            return Names(self.parts + (other,))
+        elif isinstance(other, tuple):
+            return Names(self.parts + other)
+        else:
+            raise ValueError("Name parts should be of type str")
+
+    def __eq__(self, other):
+        return isinstance(other, Names) and self.parts == other.parts
+
+def names_from_type_name(type_name):
+    '''Parse Names() from FieldDescriptorProto type_name'''
+    if type_name[0] != '.':
+        raise NotImplementedError("Lookup of non-absolute type names is not supported")
+    return Names(type_name[1:].split('.'))
+
+def varint_max_size(max_value):
+    '''Returns the maximum number of bytes a varint can take when encoded.'''
+    if max_value < 0:
+        max_value = 2**64 - max_value
+    for i in range(1, 11):
+        if (max_value >> (i * 7)) == 0:
+            return i
+    raise ValueError("Value too large for varint: " + str(max_value))
+
+assert varint_max_size(-1) == 10
+assert varint_max_size(0) == 1
+assert varint_max_size(127) == 1
+assert varint_max_size(128) == 2
+
+class EncodedSize:
+    '''Class used to represent the encoded size of a field or a message.
+    Consists of a combination of symbolic sizes and integer sizes.'''
+    def __init__(self, value = 0, symbols = []):
+        if isinstance(value, EncodedSize):
+            self.value = value.value
+            self.symbols = value.symbols
+        elif isinstance(value, strtypes + (Names,)):
+            self.symbols = [str(value)]
+            self.value = 0
+        else:
+            self.value = value
+            self.symbols = symbols
+
+    def __add__(self, other):
+        if isinstance(other, int):
+            return EncodedSize(self.value + other, self.symbols)
+        elif isinstance(other, strtypes + (Names,)):
+            return EncodedSize(self.value, self.symbols + [str(other)])
+        elif isinstance(other, EncodedSize):
+            return EncodedSize(self.value + other.value, self.symbols + other.symbols)
+        else:
+            raise ValueError("Cannot add size: " + repr(other))
+
+    def __mul__(self, other):
+        if isinstance(other, int):
+            return EncodedSize(self.value * other, [str(other) + '*' + s for s in self.symbols])
+        else:
+            raise ValueError("Cannot multiply size: " + repr(other))
+
+    def __str__(self):
+        if not self.symbols:
+            return str(self.value)
+        else:
+            return '(' + str(self.value) + ' + ' + ' + '.join(self.symbols) + ')'
+
+    def upperlimit(self):
+        if not self.symbols:
+            return self.value
+        else:
+            return 2**32 - 1
+
+class Enum:
+    def __init__(self, names, desc, enum_options):
+        '''desc is EnumDescriptorProto'''
+
+        self.options = enum_options
+        self.names = names + desc.name
+
+        if enum_options.long_names:
+            self.values = [(self.names + x.name, x.number) for x in desc.value]
+        else:
+            self.values = [(names + x.name, x.number) for x in desc.value]
+
+        self.value_longnames = [self.names + x.name for x in desc.value]
+        self.packed = enum_options.packed_enum
+
+    def has_negative(self):
+        for n, v in self.values:
+            if v < 0:
+                return True
+        return False
+
+    def encoded_size(self):
+        return max([varint_max_size(v) for n,v in self.values])
+
+    def __str__(self):
+        result = 'typedef enum _%s {\n' % self.names
+        result += ',\n'.join(["    %s = %d" % x for x in self.values])
+        result += '\n}'
+
+        if self.packed:
+            result += ' pb_packed'
+
+        result += ' %s;' % self.names
+
+        result += '\n#define _%s_MIN %s' % (self.names, self.values[0][0])
+        result += '\n#define _%s_MAX %s' % (self.names, self.values[-1][0])
+        result += '\n#define _%s_ARRAYSIZE ((%s)(%s+1))' % (self.names, self.names, self.values[-1][0])
+
+        if not self.options.long_names:
+            # Define the long names always so that enum value references
+            # from other files work properly.
+            for i, x in enumerate(self.values):
+                result += '\n#define %s %s' % (self.value_longnames[i], x[0])
+
+        return result
+
+class FieldMaxSize:
+    def __init__(self, worst = 0, checks = [], field_name = 'undefined'):
+        if isinstance(worst, list):
+            self.worst = max(i for i in worst if i is not None)
+        else:
+            self.worst = worst
+
+        self.worst_field = field_name
+        self.checks = list(checks)
+
+    def extend(self, extend, field_name = None):
+        self.worst = max(self.worst, extend.worst)
+
+        if self.worst == extend.worst:
+            self.worst_field = extend.worst_field
+
+        self.checks.extend(extend.checks)
+
+class Field:
+    def __init__(self, struct_name, desc, field_options):
+        '''desc is FieldDescriptorProto'''
+        self.tag = desc.number
+        self.struct_name = struct_name
+        self.union_name = None
+        self.name = desc.name
+        self.default = None
+        self.max_size = None
+        self.max_count = None
+        self.array_decl = ""
+        self.enc_size = None
+        self.ctype = None
+
+        # Parse field options
+        if field_options.HasField("max_size"):
+            self.max_size = field_options.max_size
+
+        if field_options.HasField("max_count"):
+            self.max_count = field_options.max_count
+
+        if desc.HasField('default_value'):
+            self.default = desc.default_value
+
+        # Check field rules, i.e. required/optional/repeated.
+        can_be_static = True
+        if desc.label == FieldD.LABEL_REQUIRED:
+            self.rules = 'REQUIRED'
+        elif desc.label == FieldD.LABEL_OPTIONAL:
+            self.rules = 'OPTIONAL'
+        elif desc.label == FieldD.LABEL_REPEATED:
+            self.rules = 'REPEATED'
+            if self.max_count is None:
+                can_be_static = False
+            else:
+                self.array_decl = '[%d]' % self.max_count
+        else:
+            raise NotImplementedError(desc.label)
+
+        # Check if the field can be implemented with static allocation
+        # i.e. whether the data size is known.
+        if desc.type == FieldD.TYPE_STRING and self.max_size is None:
+            can_be_static = False
+
+        if desc.type == FieldD.TYPE_BYTES and self.max_size is None:
+            can_be_static = False
+
+        # Decide how the field data will be allocated
+        if field_options.type == nanopb_pb2.FT_DEFAULT:
+            if can_be_static:
+                field_options.type = nanopb_pb2.FT_STATIC
+            else:
+                field_options.type = nanopb_pb2.FT_CALLBACK
+
+        if field_options.type == nanopb_pb2.FT_STATIC and not can_be_static:
+            raise Exception("Field %s is defined as static, but max_size or "
+                            "max_count is not given." % self.name)
+
+        if field_options.type == nanopb_pb2.FT_STATIC:
+            self.allocation = 'STATIC'
+        elif field_options.type == nanopb_pb2.FT_POINTER:
+            self.allocation = 'POINTER'
+        elif field_options.type == nanopb_pb2.FT_CALLBACK:
+            self.allocation = 'CALLBACK'
+        else:
+            raise NotImplementedError(field_options.type)
+
+        # Decide the C data type to use in the struct.
+        if desc.type in datatypes:
+            self.ctype, self.pbtype, self.enc_size, isa = datatypes[desc.type]
+
+            # Override the field size if user wants to use smaller integers
+            if isa and field_options.int_size != nanopb_pb2.IS_DEFAULT:
+                self.ctype = intsizes[field_options.int_size]
+                if desc.type == FieldD.TYPE_UINT32 or desc.type == FieldD.TYPE_UINT64:
+                    self.ctype = 'u' + self.ctype;
+        elif desc.type == FieldD.TYPE_ENUM:
+            self.pbtype = 'ENUM'
+            self.ctype = names_from_type_name(desc.type_name)
+            if self.default is not None:
+                self.default = self.ctype + self.default
+            self.enc_size = None # Needs to be filled in when enum values are known
+        elif desc.type == FieldD.TYPE_STRING:
+            self.pbtype = 'STRING'
+            self.ctype = 'char'
+            if self.allocation == 'STATIC':
+                self.ctype = 'char'
+                self.array_decl += '[%d]' % self.max_size
+                self.enc_size = varint_max_size(self.max_size) + self.max_size
+        elif desc.type == FieldD.TYPE_BYTES:
+            self.pbtype = 'BYTES'
+            if self.allocation == 'STATIC':
+                self.ctype = self.struct_name + self.name + 't'
+                self.enc_size = varint_max_size(self.max_size) + self.max_size
+            elif self.allocation == 'POINTER':
+                self.ctype = 'pb_bytes_array_t'
+        elif desc.type == FieldD.TYPE_MESSAGE:
+            self.pbtype = 'MESSAGE'
+            self.ctype = self.submsgname = names_from_type_name(desc.type_name)
+            self.enc_size = None # Needs to be filled in after the message type is available
+        else:
+            raise NotImplementedError(desc.type)
+
+    def __lt__(self, other):
+        return self.tag < other.tag
+
+    def __str__(self):
+        result = ''
+        if self.allocation == 'POINTER':
+            if self.rules == 'REPEATED':
+                result += '    pb_size_t ' + self.name + '_count;\n'
+
+            if self.pbtype == 'MESSAGE':
+                # Use struct definition, so recursive submessages are possible
+                result += '    struct _%s *%s;' % (self.ctype, self.name)
+            elif self.rules == 'REPEATED' and self.pbtype in ['STRING', 'BYTES']:
+                # String/bytes arrays need to be defined as pointers to pointers
+                result += '    %s **%s;' % (self.ctype, self.name)
+            else:
+                result += '    %s *%s;' % (self.ctype, self.name)
+        elif self.allocation == 'CALLBACK':
+            result += '    pb_callback_t %s;' % self.name
+        else:
+            if self.rules == 'OPTIONAL' and self.allocation == 'STATIC':
+                result += '    bool has_' + self.name + ';\n'
+            elif self.rules == 'REPEATED' and self.allocation == 'STATIC':
+                result += '    pb_size_t ' + self.name + '_count;\n'
+            result += '    %s %s%s;' % (self.ctype, self.name, self.array_decl)
+        return result
+
+    def types(self):
+        '''Return definitions for any special types this field might need.'''
+        if self.pbtype == 'BYTES' and self.allocation == 'STATIC':
+            result = 'typedef PB_BYTES_ARRAY_T(%d) %s;\n' % (self.max_size, self.ctype)
+        else:
+            result = ''
+        return result
+
+    def get_dependencies(self):
+        '''Get list of type names used by this field.'''
+        if self.allocation == 'STATIC':
+            return [str(self.ctype)]
+        else:
+            return []
+
+    def get_initializer(self, null_init, inner_init_only = False):
+        '''Return literal expression for this field's default value.
+        null_init: If True, initialize to a 0 value instead of default from .proto
+        inner_init_only: If True, exclude initialization for any count/has fields
+        '''
+
+        inner_init = None
+        if self.pbtype == 'MESSAGE':
+            if null_init:
+                inner_init = '%s_init_zero' % self.ctype
+            else:
+                inner_init = '%s_init_default' % self.ctype
+        elif self.default is None or null_init:
+            if self.pbtype == 'STRING':
+                inner_init = '""'
+            elif self.pbtype == 'BYTES':
+                inner_init = '{0, {0}}'
+            elif self.pbtype in ('ENUM', 'UENUM'):
+                inner_init = '(%s)0' % self.ctype
+            else:
+                inner_init = '0'
+        else:
+            if self.pbtype == 'STRING':
+                inner_init = self.default.replace('"', '\\"')
+                inner_init = '"' + inner_init + '"'
+            elif self.pbtype == 'BYTES':
+                data = ['0x%02x' % ord(c) for c in self.default]
+                if len(data) == 0:
+                    inner_init = '{0, {0}}'
+                else:
+                    inner_init = '{%d, {%s}}' % (len(data), ','.join(data))
+            elif self.pbtype in ['FIXED32', 'UINT32']:
+                inner_init = str(self.default) + 'u'
+            elif self.pbtype in ['FIXED64', 'UINT64']:
+                inner_init = str(self.default) + 'ull'
+            elif self.pbtype in ['SFIXED64', 'INT64']:
+                inner_init = str(self.default) + 'll'
+            else:
+                inner_init = str(self.default)
+
+        if inner_init_only:
+            return inner_init
+
+        outer_init = None
+        if self.allocation == 'STATIC':
+            if self.rules == 'REPEATED':
+                outer_init = '0, {'
+                outer_init += ', '.join([inner_init] * self.max_count)
+                outer_init += '}'
+            elif self.rules == 'OPTIONAL':
+                outer_init = 'false, ' + inner_init
+            else:
+                outer_init = inner_init
+        elif self.allocation == 'POINTER':
+            if self.rules == 'REPEATED':
+                outer_init = '0, NULL'
+            else:
+                outer_init = 'NULL'
+        elif self.allocation == 'CALLBACK':
+            if self.pbtype == 'EXTENSION':
+                outer_init = 'NULL'
+            else:
+                outer_init = '{{NULL}, NULL}'
+
+        return outer_init
+
+    def default_decl(self, declaration_only = False):
+        '''Return definition for this field's default value.'''
+        if self.default is None:
+            return None
+
+        ctype = self.ctype
+        default = self.get_initializer(False, True)
+        array_decl = ''
+
+        if self.pbtype == 'STRING':
+            if self.allocation != 'STATIC':
+                return None # Not implemented
+            array_decl = '[%d]' % self.max_size
+        elif self.pbtype == 'BYTES':
+            if self.allocation != 'STATIC':
+                return None # Not implemented
+
+        if declaration_only:
+            return 'extern const %s %s_default%s;' % (ctype, self.struct_name + self.name, array_decl)
+        else:
+            return 'const %s %s_default%s = %s;' % (ctype, self.struct_name + self.name, array_decl, default)
+
+    def tags(self):
+        '''Return the #define for the tag number of this field.'''
+        identifier = '%s_%s_tag' % (self.struct_name, self.name)
+        return '#define %-40s %d\n' % (identifier, self.tag)
+
+    def pb_field_t(self, prev_field_name):
+        '''Return the pb_field_t initializer to use in the constant array.
+        prev_field_name is the name of the previous field or None.
+        '''
+
+        if self.rules == 'ONEOF':
+            if self.anonymous:
+                result = '    PB_ANONYMOUS_ONEOF_FIELD(%s, ' % self.union_name
+            else:
+                result = '    PB_ONEOF_FIELD(%s, ' % self.union_name
+        else:
+            result = '    PB_FIELD('
+
+        result += '%3d, ' % self.tag
+        result += '%-8s, ' % self.pbtype
+        result += '%s, ' % self.rules
+        result += '%-8s, ' % self.allocation
+        result += '%s, ' % ("FIRST" if not prev_field_name else "OTHER")
+        result += '%s, ' % self.struct_name
+        result += '%s, ' % self.name
+        result += '%s, ' % (prev_field_name or self.name)
+
+        if self.pbtype == 'MESSAGE':
+            result += '&%s_fields)' % self.submsgname
+        elif self.default is None:
+            result += '0)'
+        elif self.pbtype in ['BYTES', 'STRING'] and self.allocation != 'STATIC':
+            result += '0)' # Arbitrary size default values not implemented
+        elif self.rules == 'OPTEXT':
+            result += '0)' # Default value for extensions is not implemented
+        else:
+            result += '&%s_default)' % (self.struct_name + self.name)
+
+        return result
+
+    def get_last_field_name(self):
+        return self.name
+
+    def largest_field_value(self):
+        '''Determine if this field needs 16bit or 32bit pb_field_t structure to compile properly.
+        Returns numeric value or a C-expression for assert.'''
+        check = []
+        if self.pbtype == 'MESSAGE':
+            if self.rules == 'REPEATED' and self.allocation == 'STATIC':
+                check.append('pb_membersize(%s, %s[0])' % (self.struct_name, self.name))
+            elif self.rules == 'ONEOF':
+                if self.anonymous:
+                    check.append('pb_membersize(%s, %s)' % (self.struct_name, self.name))
+                else:
+                    check.append('pb_membersize(%s, %s.%s)' % (self.struct_name, self.union_name, self.name))
+            else:
+                check.append('pb_membersize(%s, %s)' % (self.struct_name, self.name))
+
+        return FieldMaxSize([self.tag, self.max_size, self.max_count],
+                            check,
+                            ('%s.%s' % (self.struct_name, self.name)))
+
+    def encoded_size(self, dependencies):
+        '''Return the maximum size that this field can take when encoded,
+        including the field tag. If the size cannot be determined, returns
+        None.'''
+
+        if self.allocation != 'STATIC':
+            return None
+
+        if self.pbtype == 'MESSAGE':
+            encsize = None
+            if str(self.submsgname) in dependencies:
+                submsg = dependencies[str(self.submsgname)]
+                encsize = submsg.encoded_size(dependencies)
+                if encsize is not None:
+                    # Include submessage length prefix
+                    encsize += varint_max_size(encsize.upperlimit())
+
+            if encsize is None:
+                # Submessage or its size cannot be found.
+                # This can occur if submessage is defined in different
+                # file, and it or its .options could not be found.
+                # Instead of direct numeric value, reference the size that
+                # has been #defined in the other file.
+                encsize = EncodedSize(self.submsgname + 'size')
+
+                # We will have to make a conservative assumption on the length
+                # prefix size, though.
+                encsize += 5
+
+        elif self.pbtype in ['ENUM', 'UENUM']:
+            if str(self.ctype) in dependencies:
+                enumtype = dependencies[str(self.ctype)]
+                encsize = enumtype.encoded_size()
+            else:
+                # Conservative assumption
+                encsize = 10
+
+        elif self.enc_size is None:
+            raise RuntimeError("Could not determine encoded size for %s.%s"
+                               % (self.struct_name, self.name))
+        else:
+            encsize = EncodedSize(self.enc_size)
+
+        encsize += varint_max_size(self.tag << 3) # Tag + wire type
+
+        if self.rules == 'REPEATED':
+            # Decoders must be always able to handle unpacked arrays.
+            # Therefore we have to reserve space for it, even though
+            # we emit packed arrays ourselves.
+            encsize *= self.max_count
+
+        return encsize
+
+
+class ExtensionRange(Field):
+    def __init__(self, struct_name, range_start, field_options):
+        '''Implements a special pb_extension_t* field in an extensible message
+        structure. The range_start signifies the index at which the extensions
+        start. Not necessarily all tags above this are extensions, it is merely
+        a speed optimization.
+        '''
+        self.tag = range_start
+        self.struct_name = struct_name
+        self.name = 'extensions'
+        self.pbtype = 'EXTENSION'
+        self.rules = 'OPTIONAL'
+        self.allocation = 'CALLBACK'
+        self.ctype = 'pb_extension_t'
+        self.array_decl = ''
+        self.default = None
+        self.max_size = 0
+        self.max_count = 0
+
+    def __str__(self):
+        return '    pb_extension_t *extensions;'
+
+    def types(self):
+        return ''
+
+    def tags(self):
+        return ''
+
+    def encoded_size(self, dependencies):
+        # We exclude extensions from the count, because they cannot be known
+        # until runtime. Other option would be to return None here, but this
+        # way the value remains useful if extensions are not used.
+        return EncodedSize(0)
+
+class ExtensionField(Field):
+    def __init__(self, struct_name, desc, field_options):
+        self.fullname = struct_name + desc.name
+        self.extendee_name = names_from_type_name(desc.extendee)
+        Field.__init__(self, self.fullname + 'struct', desc, field_options)
+
+        if self.rules != 'OPTIONAL':
+            self.skip = True
+        else:
+            self.skip = False
+            self.rules = 'OPTEXT'
+
+    def tags(self):
+        '''Return the #define for the tag number of this field.'''
+        identifier = '%s_tag' % self.fullname
+        return '#define %-40s %d\n' % (identifier, self.tag)
+
+    def extension_decl(self):
+        '''Declaration of the extension type in the .pb.h file'''
+        if self.skip:
+            msg = '/* Extension field %s was skipped because only "optional"\n' % self.fullname
+            msg +='   type of extension fields is currently supported. */\n'
+            return msg
+
+        return ('extern const pb_extension_type_t %s; /* field type: %s */\n' %
+            (self.fullname, str(self).strip()))
+
+    def extension_def(self):
+        '''Definition of the extension type in the .pb.c file'''
+
+        if self.skip:
+            return ''
+
+        result  = 'typedef struct {\n'
+        result += str(self)
+        result += '\n} %s;\n\n' % self.struct_name
+        result += ('static const pb_field_t %s_field = \n  %s;\n\n' %
+                    (self.fullname, self.pb_field_t(None)))
+        result += 'const pb_extension_type_t %s = {\n' % self.fullname
+        result += '    NULL,\n'
+        result += '    NULL,\n'
+        result += '    &%s_field\n' % self.fullname
+        result += '};\n'
+        return result
+
+
+# ---------------------------------------------------------------------------
+#                   Generation of oneofs (unions)
+# ---------------------------------------------------------------------------
+
+class OneOf(Field):
+    def __init__(self, struct_name, oneof_desc):
+        self.struct_name = struct_name
+        self.name = oneof_desc.name
+        self.ctype = 'union'
+        self.pbtype = 'oneof'
+        self.fields = []
+        self.allocation = 'ONEOF'
+        self.default = None
+        self.rules = 'ONEOF'
+        self.anonymous = False
+
+    def add_field(self, field):
+        if field.allocation == 'CALLBACK':
+            raise Exception("Callback fields inside of oneof are not supported"
+                            + " (field %s)" % field.name)
+
+        field.union_name = self.name
+        field.rules = 'ONEOF'
+        field.anonymous = self.anonymous
+        self.fields.append(field)
+        self.fields.sort(key = lambda f: f.tag)
+
+        # Sort by the lowest tag number inside union
+        self.tag = min([f.tag for f in self.fields])
+
+    def __str__(self):
+        result = ''
+        if self.fields:
+            result += '    pb_size_t which_' + self.name + ";\n"
+            result += '    union {\n'
+            for f in self.fields:
+                result += '    ' + str(f).replace('\n', '\n    ') + '\n'
+            if self.anonymous:
+                result += '    };'
+            else:
+                result += '    } ' + self.name + ';'
+        return result
+
+    def types(self):
+        return ''.join([f.types() for f in self.fields])
+
+    def get_dependencies(self):
+        deps = []
+        for f in self.fields:
+            deps += f.get_dependencies()
+        return deps
+
+    def get_initializer(self, null_init):
+        return '0, {' + self.fields[0].get_initializer(null_init) + '}'
+
+    def default_decl(self, declaration_only = False):
+        return None
+
+    def tags(self):
+        return ''.join([f.tags() for f in self.fields])
+
+    def pb_field_t(self, prev_field_name):
+        result = ',\n'.join([f.pb_field_t(prev_field_name) for f in self.fields])
+        return result
+
+    def get_last_field_name(self):
+        if self.anonymous:
+            return self.fields[-1].name
+        else:
+            return self.name + '.' + self.fields[-1].name
+
+    def largest_field_value(self):
+        largest = FieldMaxSize()
+        for f in self.fields:
+            largest.extend(f.largest_field_value())
+        return largest
+
+    def encoded_size(self, dependencies):
+        '''Returns the size of the largest oneof field.'''
+        largest = EncodedSize(0)
+        for f in self.fields:
+            size = EncodedSize(f.encoded_size(dependencies))
+            if size.value is None:
+                return None
+            elif size.symbols:
+                return None # Cannot resolve maximum of symbols
+            elif size.value > largest.value:
+                largest = size
+
+        return largest
+
+# ---------------------------------------------------------------------------
+#                   Generation of messages (structures)
+# ---------------------------------------------------------------------------
+
+
+class Message:
+    def __init__(self, names, desc, message_options):
+        self.name = names
+        self.fields = []
+        self.oneofs = {}
+        no_unions = []
+
+        if message_options.msgid:
+            self.msgid = message_options.msgid
+
+        if hasattr(desc, 'oneof_decl'):
+            for i, f in enumerate(desc.oneof_decl):
+                oneof_options = get_nanopb_suboptions(desc, message_options, self.name + f.name)
+                if oneof_options.no_unions:
+                    no_unions.append(i) # No union, but add fields normally
+                elif oneof_options.type == nanopb_pb2.FT_IGNORE:
+                    pass # No union and skip fields also
+                else:
+                    oneof = OneOf(self.name, f)
+                    if oneof_options.anonymous_oneof:
+                        oneof.anonymous = True
+                    self.oneofs[i] = oneof
+                    self.fields.append(oneof)
+
+        for f in desc.field:
+            field_options = get_nanopb_suboptions(f, message_options, self.name + f.name)
+            if field_options.type == nanopb_pb2.FT_IGNORE:
+                continue
+
+            field = Field(self.name, f, field_options)
+            if (hasattr(f, 'oneof_index') and
+                f.HasField('oneof_index') and
+                f.oneof_index not in no_unions):
+                if f.oneof_index in self.oneofs:
+                    self.oneofs[f.oneof_index].add_field(field)
+            else:
+                self.fields.append(field)
+
+        if len(desc.extension_range) > 0:
+            field_options = get_nanopb_suboptions(desc, message_options, self.name + 'extensions')
+            range_start = min([r.start for r in desc.extension_range])
+            if field_options.type != nanopb_pb2.FT_IGNORE:
+                self.fields.append(ExtensionRange(self.name, range_start, field_options))
+
+        self.packed = message_options.packed_struct
+        self.ordered_fields = self.fields[:]
+        self.ordered_fields.sort()
+
+    def get_dependencies(self):
+        '''Get list of type names that this structure refers to.'''
+        deps = []
+        for f in self.fields:
+            deps += f.get_dependencies()
+        return deps
+
+    def __str__(self):
+        result = 'typedef struct _%s {\n' % self.name
+
+        if not self.ordered_fields:
+            # Empty structs are not allowed in C standard.
+            # Therefore add a dummy field if an empty message occurs.
+            result += '    char dummy_field;'
+
+        result += '\n'.join([str(f) for f in self.ordered_fields])
+        result += '\n/* @@protoc_insertion_point(struct:%s) */' % self.name
+        result += '\n}'
+
+        if self.packed:
+            result += ' pb_packed'
+
+        result += ' %s;' % self.name
+
+        if self.packed:
+            result = 'PB_PACKED_STRUCT_START\n' + result
+            result += '\nPB_PACKED_STRUCT_END'
+
+        return result
+
+    def types(self):
+        return ''.join([f.types() for f in self.fields])
+
+    def get_initializer(self, null_init):
+        if not self.ordered_fields:
+            return '{0}'
+
+        parts = []
+        for field in self.ordered_fields:
+            parts.append(field.get_initializer(null_init))
+        return '{' + ', '.join(parts) + '}'
+
+    def default_decl(self, declaration_only = False):
+        result = ""
+        for field in self.fields:
+            default = field.default_decl(declaration_only)
+            if default is not None:
+                result += default + '\n'
+        return result
+
+    def count_required_fields(self):
+        '''Returns number of required fields inside this message'''
+        count = 0
+        for f in self.fields:
+            if not isinstance(f, OneOf):
+                if f.rules == 'REQUIRED':
+                    count += 1
+        return count
+
+    def count_all_fields(self):
+        count = 0
+        for f in self.fields:
+            if isinstance(f, OneOf):
+                count += len(f.fields)
+            else:
+                count += 1
+        return count
+
+    def fields_declaration(self):
+        result = 'extern const pb_field_t %s_fields[%d];' % (self.name, self.count_all_fields() + 1)
+        return result
+
+    def fields_definition(self):
+        result = 'const pb_field_t %s_fields[%d] = {\n' % (self.name, self.count_all_fields() + 1)
+
+        prev = None
+        for field in self.ordered_fields:
+            result += field.pb_field_t(prev)
+            result += ',\n'
+            prev = field.get_last_field_name()
+
+        result += '    PB_LAST_FIELD\n};'
+        return result
+
+    def encoded_size(self, dependencies):
+        '''Return the maximum size that this message can take when encoded.
+        If the size cannot be determined, returns None.
+        '''
+        size = EncodedSize(0)
+        for field in self.fields:
+            fsize = field.encoded_size(dependencies)
+            if fsize is None:
+                return None
+            size += fsize
+
+        return size
+
+
+# ---------------------------------------------------------------------------
+#                    Processing of entire .proto files
+# ---------------------------------------------------------------------------
+
+def iterate_messages(desc, names = Names()):
+    '''Recursively find all messages. For each, yield name, DescriptorProto.'''
+    if hasattr(desc, 'message_type'):
+        submsgs = desc.message_type
+    else:
+        submsgs = desc.nested_type
+
+    for submsg in submsgs:
+        sub_names = names + submsg.name
+        yield sub_names, submsg
+
+        for x in iterate_messages(submsg, sub_names):
+            yield x
+
+def iterate_extensions(desc, names = Names()):
+    '''Recursively find all extensions.
+    For each, yield name, FieldDescriptorProto.
+    '''
+    for extension in desc.extension:
+        yield names, extension
+
+    for subname, subdesc in iterate_messages(desc, names):
+        for extension in subdesc.extension:
+            yield subname, extension
+
+def toposort2(data):
+    '''Topological sort.
+    From http://code.activestate.com/recipes/577413-topological-sort/
+    This function is under the MIT license.
+    '''
+    for k, v in list(data.items()):
+        v.discard(k) # Ignore self dependencies
+    extra_items_in_deps = reduce(set.union, list(data.values()), set()) - set(data.keys())
+    data.update(dict([(item, set()) for item in extra_items_in_deps]))
+    while True:
+        ordered = set(item for item,dep in list(data.items()) if not dep)
+        if not ordered:
+            break
+        for item in sorted(ordered):
+            yield item
+        data = dict([(item, (dep - ordered)) for item,dep in list(data.items())
+                if item not in ordered])
+    assert not data, "A cyclic dependency exists amongst %r" % data
+
+def sort_dependencies(messages):
+    '''Sort a list of Messages based on dependencies.'''
+    dependencies = {}
+    message_by_name = {}
+    for message in messages:
+        dependencies[str(message.name)] = set(message.get_dependencies())
+        message_by_name[str(message.name)] = message
+
+    for msgname in toposort2(dependencies):
+        if msgname in message_by_name:
+            yield message_by_name[msgname]
+
+def make_identifier(headername):
+    '''Make #ifndef identifier that contains uppercase A-Z and digits 0-9'''
+    result = ""
+    for c in headername.upper():
+        if c.isalnum():
+            result += c
+        else:
+            result += '_'
+    return result
+
+class ProtoFile:
+    def __init__(self, fdesc, file_options):
+        '''Takes a FileDescriptorProto and parses it.'''
+        self.fdesc = fdesc
+        self.file_options = file_options
+        self.dependencies = {}
+        self.parse()
+
+        # Some of types used in this file probably come from the file itself.
+        # Thus it has implicit dependency on itself.
+        self.add_dependency(self)
+
+    def parse(self):
+        self.enums = []
+        self.messages = []
+        self.extensions = []
+
+        if self.fdesc.package:
+            base_name = Names(self.fdesc.package.split('.'))
+        else:
+            base_name = Names()
+
+        for enum in self.fdesc.enum_type:
+            enum_options = get_nanopb_suboptions(enum, self.file_options, base_name + enum.name)
+            self.enums.append(Enum(base_name, enum, enum_options))
+
+        for names, message in iterate_messages(self.fdesc, base_name):
+            message_options = get_nanopb_suboptions(message, self.file_options, names)
+
+            if message_options.skip_message:
+                continue
+
+            self.messages.append(Message(names, message, message_options))
+            for enum in message.enum_type:
+                enum_options = get_nanopb_suboptions(enum, message_options, names + enum.name)
+                self.enums.append(Enum(names, enum, enum_options))
+
+        for names, extension in iterate_extensions(self.fdesc, base_name):
+            field_options = get_nanopb_suboptions(extension, self.file_options, names + extension.name)
+            if field_options.type != nanopb_pb2.FT_IGNORE:
+                self.extensions.append(ExtensionField(names, extension, field_options))
+
+    def add_dependency(self, other):
+        for enum in other.enums:
+            self.dependencies[str(enum.names)] = enum
+
+        for msg in other.messages:
+            self.dependencies[str(msg.name)] = msg
+
+        # Fix field default values where enum short names are used.
+        for enum in other.enums:
+            if not enum.options.long_names:
+                for message in self.messages:
+                    for field in message.fields:
+                        if field.default in enum.value_longnames:
+                            idx = enum.value_longnames.index(field.default)
+                            field.default = enum.values[idx][0]
+
+        # Fix field data types where enums have negative values.
+        for enum in other.enums:
+            if not enum.has_negative():
+                for message in self.messages:
+                    for field in message.fields:
+                        if field.pbtype == 'ENUM' and field.ctype == enum.names:
+                            field.pbtype = 'UENUM'
+
+    def generate_header(self, includes, headername, options):
+        '''Generate content for a header file.
+        Generates strings, which should be concatenated and stored to file.
+        '''
+
+        yield '/* Automatically generated nanopb header */\n'
+        if options.notimestamp:
+            yield '/* Generated by %s */\n\n' % (nanopb_version)
+        else:
+            yield '/* Generated by %s at %s. */\n\n' % (nanopb_version, time.asctime())
+
+        symbol = make_identifier(headername)
+        yield '#ifndef PB_%s_INCLUDED\n' % symbol
+        yield '#define PB_%s_INCLUDED\n' % symbol
+        try:
+            yield options.libformat % ('pb.h')
+        except TypeError:
+            # no %s specified - use whatever was passed in as options.libformat
+            yield options.libformat
+        yield '\n'
+
+        for incfile in includes:
+            noext = os.path.splitext(incfile)[0]
+            yield options.genformat % (noext + options.extension + '.h')
+            yield '\n'
+
+        yield '/* @@protoc_insertion_point(includes) */\n'
+
+        yield '#if PB_PROTO_HEADER_VERSION != 30\n'
+        yield '#error Regenerate this file with the current version of nanopb generator.\n'
+        yield '#endif\n'
+        yield '\n'
+
+        yield '#ifdef __cplusplus\n'
+        yield 'extern "C" {\n'
+        yield '#endif\n\n'
+
+        if self.enums:
+            yield '/* Enum definitions */\n'
+            for enum in self.enums:
+                yield str(enum) + '\n\n'
+
+        if self.messages:
+            yield '/* Struct definitions */\n'
+            for msg in sort_dependencies(self.messages):
+                yield msg.types()
+                yield str(msg) + '\n\n'
+
+        if self.extensions:
+            yield '/* Extensions */\n'
+            for extension in self.extensions:
+                yield extension.extension_decl()
+            yield '\n'
+
+        if self.messages:
+            yield '/* Default values for struct fields */\n'
+            for msg in self.messages:
+                yield msg.default_decl(True)
+            yield '\n'
+
+            yield '/* Initializer values for message structs */\n'
+            for msg in self.messages:
+                identifier = '%s_init_default' % msg.name
+                yield '#define %-40s %s\n' % (identifier, msg.get_initializer(False))
+            for msg in self.messages:
+                identifier = '%s_init_zero' % msg.name
+                yield '#define %-40s %s\n' % (identifier, msg.get_initializer(True))
+            yield '\n'
+
+            yield '/* Field tags (for use in manual encoding/decoding) */\n'
+            for msg in sort_dependencies(self.messages):
+                for field in msg.fields:
+                    yield field.tags()
+            for extension in self.extensions:
+                yield extension.tags()
+            yield '\n'
+
+            yield '/* Struct field encoding specification for nanopb */\n'
+            for msg in self.messages:
+                yield msg.fields_declaration() + '\n'
+            yield '\n'
+
+            yield '/* Maximum encoded size of messages (where known) */\n'
+            for msg in self.messages:
+                msize = msg.encoded_size(self.dependencies)
+                identifier = '%s_size' % msg.name
+                if msize is not None:
+                    yield '#define %-40s %s\n' % (identifier, msize)
+                else:
+                    yield '/* %s depends on runtime parameters */\n' % identifier
+            yield '\n'
+
+            yield '/* Message IDs (where set with "msgid" option) */\n'
+
+            yield '#ifdef PB_MSGID\n'
+            for msg in self.messages:
+                if hasattr(msg,'msgid'):
+                    yield '#define PB_MSG_%d %s\n' % (msg.msgid, msg.name)
+            yield '\n'
+
+            symbol = make_identifier(headername.split('.')[0])
+            yield '#define %s_MESSAGES \\\n' % symbol
+
+            for msg in self.messages:
+                m = "-1"
+                msize = msg.encoded_size(self.dependencies)
+                if msize is not None:
+                    m = msize
+                if hasattr(msg,'msgid'):
+                    yield '\tPB_MSG(%d,%s,%s) \\\n' % (msg.msgid, m, msg.name)
+            yield '\n'
+
+            for msg in self.messages:
+                if hasattr(msg,'msgid'):
+                    yield '#define %s_msgid %d\n' % (msg.name, msg.msgid)
+            yield '\n'
+
+            yield '#endif\n\n'
+
+        yield '#ifdef __cplusplus\n'
+        yield '} /* extern "C" */\n'
+        yield '#endif\n'
+
+        # End of header
+        yield '/* @@protoc_insertion_point(eof) */\n'
+        yield '\n#endif\n'
+
+    def generate_source(self, headername, options):
+        '''Generate content for a source file.'''
+
+        yield '/* Automatically generated nanopb constant definitions */\n'
+        if options.notimestamp:
+            yield '/* Generated by %s */\n\n' % (nanopb_version)
+        else:
+            yield '/* Generated by %s at %s. */\n\n' % (nanopb_version, time.asctime())
+        yield options.genformat % (headername)
+        yield '\n'
+        yield '/* @@protoc_insertion_point(includes) */\n'
+
+        yield '#if PB_PROTO_HEADER_VERSION != 30\n'
+        yield '#error Regenerate this file with the current version of nanopb generator.\n'
+        yield '#endif\n'
+        yield '\n'
+
+        for msg in self.messages:
+            yield msg.default_decl(False)
+
+        yield '\n\n'
+
+        for msg in self.messages:
+            yield msg.fields_definition() + '\n\n'
+
+        for ext in self.extensions:
+            yield ext.extension_def() + '\n'
+
+        # Add checks for numeric limits
+        if self.messages:
+            largest_msg = max(self.messages, key = lambda m: m.count_required_fields())
+            largest_count = largest_msg.count_required_fields()
+            if largest_count > 64:
+                yield '\n/* Check that missing required fields will be properly detected */\n'
+                yield '#if PB_MAX_REQUIRED_FIELDS < %d\n' % largest_count
+                yield '#error Properly detecting missing required fields in %s requires \\\n' % largest_msg.name
+                yield '       setting PB_MAX_REQUIRED_FIELDS to %d or more.\n' % largest_count
+                yield '#endif\n'
+
+        max_field = FieldMaxSize()
+        checks_msgnames = []
+        for msg in self.messages:
+            checks_msgnames.append(msg.name)
+            for field in msg.fields:
+                max_field.extend(field.largest_field_value())
+
+        worst = max_field.worst
+        worst_field = max_field.worst_field
+        checks = max_field.checks
+
+        if worst > 255 or checks:
+            yield '\n/* Check that field information fits in pb_field_t */\n'
+
+            if worst > 65535 or checks:
+                yield '#if !defined(PB_FIELD_32BIT)\n'
+                if worst > 65535:
+                    yield '#error Field descriptor for %s is too large. Define PB_FIELD_32BIT to fix this.\n' % worst_field
+                else:
+                    assertion = ' && '.join(str(c) + ' < 65536' for c in checks)
+                    msgs = '_'.join(str(n) for n in checks_msgnames)
+                    yield '/* If you get an error here, it means that you need to define PB_FIELD_32BIT\n'
+                    yield ' * compile-time option. You can do that in pb.h or on compiler command line.\n'
+                    yield ' * \n'
+                    yield ' * The reason you need to do this is that some of your messages contain tag\n'
+                    yield ' * numbers or field sizes that are larger than what can fit in 8 or 16 bit\n'
+                    yield ' * field descriptors.\n'
+                    yield ' */\n'
+                    yield 'PB_STATIC_ASSERT((%s), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_%s)\n'%(assertion,msgs)
+                yield '#endif\n\n'
+
+            if worst < 65536:
+                yield '#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)\n'
+                if worst > 255:
+                    yield '#error Field descriptor for %s is too large. Define PB_FIELD_16BIT to fix this.\n' % worst_field
+                else:
+                    assertion = ' && '.join(str(c) + ' < 256' for c in checks)
+                    msgs = '_'.join(str(n) for n in checks_msgnames)
+                    yield '/* If you get an error here, it means that you need to define PB_FIELD_16BIT\n'
+                    yield ' * compile-time option. You can do that in pb.h or on compiler command line.\n'
+                    yield ' * \n'
+                    yield ' * The reason you need to do this is that some of your messages contain tag\n'
+                    yield ' * numbers or field sizes that are larger than what can fit in the default\n'
+                    yield ' * 8 bit descriptors.\n'
+                    yield ' */\n'
+                    yield 'PB_STATIC_ASSERT((%s), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_%s)\n'%(assertion,msgs)
+                yield '#endif\n\n'
+
+        # Add check for sizeof(double)
+        has_double = False
+        for msg in self.messages:
+            for field in msg.fields:
+                if field.ctype == 'double':
+                    has_double = True
+
+        if has_double:
+            yield '\n'
+            yield '/* On some platforms (such as AVR), double is really float.\n'
+            yield ' * These are not directly supported by nanopb, but see example_avr_double.\n'
+            yield ' * To get rid of this error, remove any double fields from your .proto.\n'
+            yield ' */\n'
+            yield 'PB_STATIC_ASSERT(sizeof(double) == 8, DOUBLE_MUST_BE_8_BYTES)\n'
+
+        yield '\n'
+        yield '/* @@protoc_insertion_point(eof) */\n'
+
+# ---------------------------------------------------------------------------
+#                    Options parsing for the .proto files
+# ---------------------------------------------------------------------------
+
+from fnmatch import fnmatch
+
+def read_options_file(infile):
+    '''Parse a separate options file to list:
+        [(namemask, options), ...]
+    '''
+    results = []
+    data = infile.read()
+    data = re.sub('/\*.*?\*/', '', data, flags = re.MULTILINE)
+    data = re.sub('//.*?$', '', data, flags = re.MULTILINE)
+    data = re.sub('#.*?$', '', data, flags = re.MULTILINE)
+    for i, line in enumerate(data.split('\n')):
+        line = line.strip()
+        if not line:
+            continue
+
+        parts = line.split(None, 1)
+
+        if len(parts) < 2:
+            sys.stderr.write("%s:%d: " % (infile.name, i + 1) +
+                             "Option lines should have space between field name and options. " +
+                             "Skipping line: '%s'\n" % line)
+            continue
+
+        opts = nanopb_pb2.NanoPBOptions()
+
+        try:
+            text_format.Merge(parts[1], opts)
+        except Exception as e:
+            sys.stderr.write("%s:%d: " % (infile.name, i + 1) +
+                             "Unparseable option line: '%s'. " % line +
+                             "Error: %s\n" % str(e))
+            continue
+        results.append((parts[0], opts))
+
+    return results
+
+class Globals:
+    '''Ugly global variables, should find a good way to pass these.'''
+    verbose_options = False
+    separate_options = []
+    matched_namemasks = set()
+
+def get_nanopb_suboptions(subdesc, options, name):
+    '''Get copy of options, and merge information from subdesc.'''
+    new_options = nanopb_pb2.NanoPBOptions()
+    new_options.CopyFrom(options)
+
+    # Handle options defined in a separate file
+    dotname = '.'.join(name.parts)
+    for namemask, options in Globals.separate_options:
+        if fnmatch(dotname, namemask):
+            Globals.matched_namemasks.add(namemask)
+            new_options.MergeFrom(options)
+
+    # Handle options defined in .proto
+    if isinstance(subdesc.options, descriptor.FieldOptions):
+        ext_type = nanopb_pb2.nanopb
+    elif isinstance(subdesc.options, descriptor.FileOptions):
+        ext_type = nanopb_pb2.nanopb_fileopt
+    elif isinstance(subdesc.options, descriptor.MessageOptions):
+        ext_type = nanopb_pb2.nanopb_msgopt
+    elif isinstance(subdesc.options, descriptor.EnumOptions):
+        ext_type = nanopb_pb2.nanopb_enumopt
+    else:
+        raise Exception("Unknown options type")
+
+    if subdesc.options.HasExtension(ext_type):
+        ext = subdesc.options.Extensions[ext_type]
+        new_options.MergeFrom(ext)
+
+    if Globals.verbose_options:
+        sys.stderr.write("Options for " + dotname + ": ")
+        sys.stderr.write(text_format.MessageToString(new_options) + "\n")
+
+    return new_options
+
+
+# ---------------------------------------------------------------------------
+#                         Command line interface
+# ---------------------------------------------------------------------------
+
+import sys
+import os.path
+from optparse import OptionParser
+
+optparser = OptionParser(
+    usage = "Usage: nanopb_generator.py [options] file.pb ...",
+    epilog = "Compile file.pb from file.proto by: 'protoc -ofile.pb file.proto'. " +
+             "Output will be written to file.pb.h and file.pb.c.")
+optparser.add_option("-x", dest="exclude", metavar="FILE", action="append", default=[],
+    help="Exclude file from generated #include list.")
+optparser.add_option("-e", "--extension", dest="extension", metavar="EXTENSION", default=".pb",
+    help="Set extension to use instead of '.pb' for generated files. [default: %default]")
+optparser.add_option("-f", "--options-file", dest="options_file", metavar="FILE", default="%s.options",
+    help="Set name of a separate generator options file.")
+optparser.add_option("-I", "--options-path", dest="options_path", metavar="DIR",
+    action="append", default = [],
+    help="Search for .options files additionally in this path")
+optparser.add_option("-D", "--output-dir", dest="output_dir",
+                     metavar="OUTPUTDIR", default=None,
+                     help="Output directory of .pb.h and .pb.c files")
+optparser.add_option("-Q", "--generated-include-format", dest="genformat",
+    metavar="FORMAT", default='#include "%s"\n',
+    help="Set format string to use for including other .pb.h files. [default: %default]")
+optparser.add_option("-L", "--library-include-format", dest="libformat",
+    metavar="FORMAT", default='#include <%s>\n',
+    help="Set format string to use for including the nanopb pb.h header. [default: %default]")
+optparser.add_option("-T", "--no-timestamp", dest="notimestamp", action="store_true", default=False,
+    help="Don't add timestamp to .pb.h and .pb.c preambles")
+optparser.add_option("-q", "--quiet", dest="quiet", action="store_true", default=False,
+    help="Don't print anything except errors.")
+optparser.add_option("-v", "--verbose", dest="verbose", action="store_true", default=False,
+    help="Print more information.")
+optparser.add_option("-s", dest="settings", metavar="OPTION:VALUE", action="append", default=[],
+    help="Set generator option (max_size, max_count etc.).")
+
+def parse_file(filename, fdesc, options):
+    '''Parse a single file. Returns a ProtoFile instance.'''
+    toplevel_options = nanopb_pb2.NanoPBOptions()
+    for s in options.settings:
+        text_format.Merge(s, toplevel_options)
+
+    if not fdesc:
+        data = open(filename, 'rb').read()
+        fdesc = descriptor.FileDescriptorSet.FromString(data).file[0]
+
+    # Check if there is a separate .options file
+    had_abspath = False
+    try:
+        optfilename = options.options_file % os.path.splitext(filename)[0]
+    except TypeError:
+        # No %s specified, use the filename as-is
+        optfilename = options.options_file
+        had_abspath = True
+
+    paths = ['.'] + options.options_path
+    for p in paths:
+        if os.path.isfile(os.path.join(p, optfilename)):
+            optfilename = os.path.join(p, optfilename)
+            if options.verbose:
+                sys.stderr.write('Reading options from ' + optfilename + '\n')
+            Globals.separate_options = read_options_file(open(optfilename, "rU"))
+            break
+    else:
+        # If we are given a full filename and it does not exist, give an error.
+        # However, don't give error when we automatically look for .options file
+        # with the same name as .proto.
+        if options.verbose or had_abspath:
+            sys.stderr.write('Options file not found: ' + optfilename + '\n')
+        Globals.separate_options = []
+
+    Globals.matched_namemasks = set()
+
+    # Parse the file
+    file_options = get_nanopb_suboptions(fdesc, toplevel_options, Names([filename]))
+    f = ProtoFile(fdesc, file_options)
+    f.optfilename = optfilename
+
+    return f
+
+def process_file(filename, fdesc, options, other_files = {}):
+    '''Process a single file.
+    filename: The full path to the .proto or .pb source file, as string.
+    fdesc: The loaded FileDescriptorSet, or None to read from the input file.
+    options: Command line options as they come from OptionsParser.
+
+    Returns a dict:
+        {'headername': Name of header file,
+         'headerdata': Data for the .h header file,
+         'sourcename': Name of the source code file,
+         'sourcedata': Data for the .c source code file
+        }
+    '''
+    f = parse_file(filename, fdesc, options)
+
+    # Provide dependencies if available
+    for dep in f.fdesc.dependency:
+        if dep in other_files:
+            f.add_dependency(other_files[dep])
+
+    # Decide the file names
+    noext = os.path.splitext(filename)[0]
+    headername = noext + options.extension + '.h'
+    sourcename = noext + options.extension + '.c'
+    headerbasename = os.path.basename(headername)
+
+    # List of .proto files that should not be included in the C header file
+    # even if they are mentioned in the source .proto.
+    excludes = ['nanopb.proto', 'google/protobuf/descriptor.proto'] + options.exclude
+    includes = [d for d in f.fdesc.dependency if d not in excludes]
+
+    headerdata = ''.join(f.generate_header(includes, headerbasename, options))
+    sourcedata = ''.join(f.generate_source(headerbasename, options))
+
+    # Check if there were any lines in .options that did not match a member
+    unmatched = [n for n,o in Globals.separate_options if n not in Globals.matched_namemasks]
+    if unmatched and not options.quiet:
+        sys.stderr.write("Following patterns in " + f.optfilename + " did not match any fields: "
+                         + ', '.join(unmatched) + "\n")
+        if not Globals.verbose_options:
+            sys.stderr.write("Use  protoc --nanopb-out=-v:.   to see a list of the field names.\n")
+
+    return {'headername': headername, 'headerdata': headerdata,
+            'sourcename': sourcename, 'sourcedata': sourcedata}
+
+def main_cli():
+    '''Main function when invoked directly from the command line.'''
+
+    options, filenames = optparser.parse_args()
+
+    if not filenames:
+        optparser.print_help()
+        sys.exit(1)
+
+    if options.quiet:
+        options.verbose = False
+
+    if options.output_dir and not os.path.exists(options.output_dir):
+        optparser.print_help()
+        sys.stderr.write("\noutput_dir does not exist: %s\n" % options.output_dir)
+        sys.exit(1)
+
+
+    Globals.verbose_options = options.verbose
+    for filename in filenames:
+        results = process_file(filename, None, options)
+
+        base_dir = options.output_dir or ''
+        to_write = [
+            (os.path.join(base_dir, results['headername']), results['headerdata']),
+            (os.path.join(base_dir, results['sourcename']), results['sourcedata']),
+        ]
+
+        if not options.quiet:
+            paths = " and ".join([x[0] for x in to_write])
+            sys.stderr.write("Writing to %s\n" % paths)
+
+        for path, data in to_write:
+            with open(path, 'w') as f:
+                f.write(data)
+
+def main_plugin():
+    '''Main function when invoked as a protoc plugin.'''
+
+    import io, sys
+    if sys.platform == "win32":
+        import os, msvcrt
+        # Set stdin and stdout to binary mode
+        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
+        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
+
+    data = io.open(sys.stdin.fileno(), "rb").read()
+
+    request = plugin_pb2.CodeGeneratorRequest.FromString(data)
+
+    try:
+        # Versions of Python prior to 2.7.3 do not support unicode
+        # input to shlex.split(). Try to convert to str if possible.
+        params = str(request.parameter)
+    except UnicodeEncodeError:
+        params = request.parameter
+
+    import shlex
+    args = shlex.split(params)
+    options, dummy = optparser.parse_args(args)
+
+    Globals.verbose_options = options.verbose
+
+    response = plugin_pb2.CodeGeneratorResponse()
+
+    # Google's protoc does not currently indicate the full path of proto files.
+    # Instead always add the main file path to the search dirs, that works for
+    # the common case.
+    import os.path
+    options.options_path.append(os.path.dirname(request.file_to_generate[0]))
+
+    # Process any include files first, in order to have them
+    # available as dependencies
+    other_files = {}
+    for fdesc in request.proto_file:
+        other_files[fdesc.name] = parse_file(fdesc.name, fdesc, options)
+
+    for filename in request.file_to_generate:
+        for fdesc in request.proto_file:
+            if fdesc.name == filename:
+                results = process_file(filename, fdesc, options, other_files)
+
+                f = response.file.add()
+                f.name = results['headername']
+                f.content = results['headerdata']
+
+                f = response.file.add()
+                f.name = results['sourcename']
+                f.content = results['sourcedata']
+
+    io.open(sys.stdout.fileno(), "wb").write(response.SerializeToString())
+
+if __name__ == '__main__':
+    # Check if we are running as a plugin under protoc
+    if 'protoc-gen-' in sys.argv[0] or '--protoc-plugin' in sys.argv:
+        main_plugin()
+    else:
+        main_cli()
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/proto/Makefile
@@ -0,0 +1,4 @@
+all: nanopb_pb2.py plugin_pb2.py
+
+%_pb2.py: %.proto
+	protoc --python_out=. $<
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/proto/google/protobuf/descriptor.proto
@@ -0,0 +1,714 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//  Based on original Protocol Buffers design by
+//  Sanjay Ghemawat, Jeff Dean, and others.
+//
+// The messages in this file describe the definitions found in .proto files.
+// A valid .proto file can be translated directly to a FileDescriptorProto
+// without any other information (e.g. without reading its imports).
+
+
+syntax = "proto2";
+
+package google.protobuf;
+option java_package = "com.google.protobuf";
+option java_outer_classname = "DescriptorProtos";
+
+// descriptor.proto must be optimized for speed because reflection-based
+// algorithms don't work during bootstrapping.
+option optimize_for = SPEED;
+
+// The protocol compiler can output a FileDescriptorSet containing the .proto
+// files it parses.
+message FileDescriptorSet {
+  repeated FileDescriptorProto file = 1;
+}
+
+// Describes a complete .proto file.
+message FileDescriptorProto {
+  optional string name = 1;       // file name, relative to root of source tree
+  optional string package = 2;    // e.g. "foo", "foo.bar", etc.
+
+  // Names of files imported by this file.
+  repeated string dependency = 3;
+  // Indexes of the public imported files in the dependency list above.
+  repeated int32 public_dependency = 10;
+  // Indexes of the weak imported files in the dependency list.
+  // For Google-internal migration only. Do not use.
+  repeated int32 weak_dependency = 11;
+
+  // All top-level definitions in this file.
+  repeated DescriptorProto message_type = 4;
+  repeated EnumDescriptorProto enum_type = 5;
+  repeated ServiceDescriptorProto service = 6;
+  repeated FieldDescriptorProto extension = 7;
+
+  optional FileOptions options = 8;
+
+  // This field contains optional information about the original source code.
+  // You may safely remove this entire field without harming runtime
+  // functionality of the descriptors -- the information is needed only by
+  // development tools.
+  optional SourceCodeInfo source_code_info = 9;
+
+  // The syntax of the proto file.
+  // The supported values are "proto2" and "proto3".
+  optional string syntax = 12;
+}
+
+// Describes a message type.
+message DescriptorProto {
+  optional string name = 1;
+
+  repeated FieldDescriptorProto field = 2;
+  repeated FieldDescriptorProto extension = 6;
+
+  repeated DescriptorProto nested_type = 3;
+  repeated EnumDescriptorProto enum_type = 4;
+
+  message ExtensionRange {
+    optional int32 start = 1;
+    optional int32 end = 2;
+  }
+  repeated ExtensionRange extension_range = 5;
+
+  repeated OneofDescriptorProto oneof_decl = 8;
+
+  optional MessageOptions options = 7;
+}
+
+// Describes a field within a message.
+message FieldDescriptorProto {
+  enum Type {
+    // 0 is reserved for errors.
+    // Order is weird for historical reasons.
+    TYPE_DOUBLE         = 1;
+    TYPE_FLOAT          = 2;
+    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if
+    // negative values are likely.
+    TYPE_INT64          = 3;
+    TYPE_UINT64         = 4;
+    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if
+    // negative values are likely.
+    TYPE_INT32          = 5;
+    TYPE_FIXED64        = 6;
+    TYPE_FIXED32        = 7;
+    TYPE_BOOL           = 8;
+    TYPE_STRING         = 9;
+    TYPE_GROUP          = 10;  // Tag-delimited aggregate.
+    TYPE_MESSAGE        = 11;  // Length-delimited aggregate.
+
+    // New in version 2.
+    TYPE_BYTES          = 12;
+    TYPE_UINT32         = 13;
+    TYPE_ENUM           = 14;
+    TYPE_SFIXED32       = 15;
+    TYPE_SFIXED64       = 16;
+    TYPE_SINT32         = 17;  // Uses ZigZag encoding.
+    TYPE_SINT64         = 18;  // Uses ZigZag encoding.
+  };
+
+  enum Label {
+    // 0 is reserved for errors
+    LABEL_OPTIONAL      = 1;
+    LABEL_REQUIRED      = 2;
+    LABEL_REPEATED      = 3;
+    // TODO(sanjay): Should we add LABEL_MAP?
+  };
+
+  optional string name = 1;
+  optional int32 number = 3;
+  optional Label label = 4;
+
+  // If type_name is set, this need not be set.  If both this and type_name
+  // are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
+  optional Type type = 5;
+
+  // For message and enum types, this is the name of the type.  If the name
+  // starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
+  // rules are used to find the type (i.e. first the nested types within this
+  // message are searched, then within the parent, on up to the root
+  // namespace).
+  optional string type_name = 6;
+
+  // For extensions, this is the name of the type being extended.  It is
+  // resolved in the same manner as type_name.
+  optional string extendee = 2;
+
+  // For numeric types, contains the original text representation of the value.
+  // For booleans, "true" or "false".
+  // For strings, contains the default text contents (not escaped in any way).
+  // For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
+  // TODO(kenton):  Base-64 encode?
+  optional string default_value = 7;
+
+  // If set, gives the index of a oneof in the containing type's oneof_decl
+  // list.  This field is a member of that oneof.  Extensions of a oneof should
+  // not set this since the oneof to which they belong will be inferred based
+  // on the extension range containing the extension's field number.
+  optional int32 oneof_index = 9;
+
+  optional FieldOptions options = 8;
+}
+
+// Describes a oneof.
+message OneofDescriptorProto {
+  optional string name = 1;
+}
+
+// Describes an enum type.
+message EnumDescriptorProto {
+  optional string name = 1;
+
+  repeated EnumValueDescriptorProto value = 2;
+
+  optional EnumOptions options = 3;
+}
+
+// Describes a value within an enum.
+message EnumValueDescriptorProto {
+  optional string name = 1;
+  optional int32 number = 2;
+
+  optional EnumValueOptions options = 3;
+}
+
+// Describes a service.
+message ServiceDescriptorProto {
+  optional string name = 1;
+  repeated MethodDescriptorProto method = 2;
+
+  optional ServiceOptions options = 3;
+}
+
+// Describes a method of a service.
+message MethodDescriptorProto {
+  optional string name = 1;
+
+  // Input and output type names.  These are resolved in the same way as
+  // FieldDescriptorProto.type_name, but must refer to a message type.
+  optional string input_type = 2;
+  optional string output_type = 3;
+
+  optional MethodOptions options = 4;
+
+  // Identifies if client streams multiple client messages
+  optional bool client_streaming = 5 [default=false];
+  // Identifies if server streams multiple server messages
+  optional bool server_streaming = 6 [default=false];
+}
+
+
+// ===================================================================
+// Options
+
+// Each of the definitions above may have "options" attached.  These are
+// just annotations which may cause code to be generated slightly differently
+// or may contain hints for code that manipulates protocol messages.
+//
+// Clients may define custom options as extensions of the *Options messages.
+// These extensions may not yet be known at parsing time, so the parser cannot
+// store the values in them.  Instead it stores them in a field in the *Options
+// message called uninterpreted_option. This field must have the same name
+// across all *Options messages. We then use this field to populate the
+// extensions when we build a descriptor, at which point all protos have been
+// parsed and so all extensions are known.
+//
+// Extension numbers for custom options may be chosen as follows:
+// * For options which will only be used within a single application or
+//   organization, or for experimental options, use field numbers 50000
+//   through 99999.  It is up to you to ensure that you do not use the
+//   same number for multiple options.
+// * For options which will be published and used publicly by multiple
+//   independent entities, e-mail protobuf-global-extension-registry@google.com
+//   to reserve extension numbers. Simply provide your project name (e.g.
+//   Object-C plugin) and your porject website (if available) -- there's no need
+//   to explain how you intend to use them. Usually you only need one extension
+//   number. You can declare multiple options with only one extension number by
+//   putting them in a sub-message. See the Custom Options section of the docs
+//   for examples:
+//   https://developers.google.com/protocol-buffers/docs/proto#options
+//   If this turns out to be popular, a web service will be set up
+//   to automatically assign option numbers.
+
+
+message FileOptions {
+
+  // Sets the Java package where classes generated from this .proto will be
+  // placed.  By default, the proto package is used, but this is often
+  // inappropriate because proto packages do not normally start with backwards
+  // domain names.
+  optional string java_package = 1;
+
+
+  // If set, all the classes from the .proto file are wrapped in a single
+  // outer class with the given name.  This applies to both Proto1
+  // (equivalent to the old "--one_java_file" option) and Proto2 (where
+  // a .proto always translates to a single class, but you may want to
+  // explicitly choose the class name).
+  optional string java_outer_classname = 8;
+
+  // If set true, then the Java code generator will generate a separate .java
+  // file for each top-level message, enum, and service defined in the .proto
+  // file.  Thus, these types will *not* be nested inside the outer class
+  // named by java_outer_classname.  However, the outer class will still be
+  // generated to contain the file's getDescriptor() method as well as any
+  // top-level extensions defined in the file.
+  optional bool java_multiple_files = 10 [default=false];
+
+  // If set true, then the Java code generator will generate equals() and
+  // hashCode() methods for all messages defined in the .proto file.
+  // - In the full runtime, this is purely a speed optimization, as the
+  // AbstractMessage base class includes reflection-based implementations of
+  // these methods.
+  //- In the lite runtime, setting this option changes the semantics of
+  // equals() and hashCode() to more closely match those of the full runtime;
+  // the generated methods compute their results based on field values rather
+  // than object identity. (Implementations should not assume that hashcodes
+  // will be consistent across runtimes or versions of the protocol compiler.)
+  optional bool java_generate_equals_and_hash = 20 [default=false];
+
+  // If set true, then the Java2 code generator will generate code that
+  // throws an exception whenever an attempt is made to assign a non-UTF-8
+  // byte sequence to a string field.
+  // Message reflection will do the same.
+  // However, an extension field still accepts non-UTF-8 byte sequences.
+  // This option has no effect on when used with the lite runtime.
+  optional bool java_string_check_utf8 = 27 [default=false];
+
+
+  // Generated classes can be optimized for speed or code size.
+  enum OptimizeMode {
+    SPEED = 1;        // Generate complete code for parsing, serialization,
+                      // etc.
+    CODE_SIZE = 2;    // Use ReflectionOps to implement these methods.
+    LITE_RUNTIME = 3; // Generate code using MessageLite and the lite runtime.
+  }
+  optional OptimizeMode optimize_for = 9 [default=SPEED];
+
+  // Sets the Go package where structs generated from this .proto will be
+  // placed. If omitted, the Go package will be derived from the following:
+  //   - The basename of the package import path, if provided.
+  //   - Otherwise, the package statement in the .proto file, if present.
+  //   - Otherwise, the basename of the .proto file, without extension.
+  optional string go_package = 11;
+
+
+
+  // Should generic services be generated in each language?  "Generic" services
+  // are not specific to any particular RPC system.  They are generated by the
+  // main code generators in each language (without additional plugins).
+  // Generic services were the only kind of service generation supported by
+  // early versions of google.protobuf.
+  //
+  // Generic services are now considered deprecated in favor of using plugins
+  // that generate code specific to your particular RPC system.  Therefore,
+  // these default to false.  Old code which depends on generic services should
+  // explicitly set them to true.
+  optional bool cc_generic_services = 16 [default=false];
+  optional bool java_generic_services = 17 [default=false];
+  optional bool py_generic_services = 18 [default=false];
+
+  // Is this file deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for everything in the file, or it will be completely ignored; in the very
+  // least, this is a formalization for deprecating files.
+  optional bool deprecated = 23 [default=false];
+
+
+  // Enables the use of arenas for the proto messages in this file. This applies
+  // only to generated classes for C++.
+  optional bool cc_enable_arenas = 31 [default=false];
+
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+message MessageOptions {
+  // Set true to use the old proto1 MessageSet wire format for extensions.
+  // This is provided for backwards-compatibility with the MessageSet wire
+  // format.  You should not use this for any other reason:  It's less
+  // efficient, has fewer features, and is more complicated.
+  //
+  // The message must be defined exactly as follows:
+  //   message Foo {
+  //     option message_set_wire_format = true;
+  //     extensions 4 to max;
+  //   }
+  // Note that the message cannot have any defined fields; MessageSets only
+  // have extensions.
+  //
+  // All extensions of your type must be singular messages; e.g. they cannot
+  // be int32s, enums, or repeated messages.
+  //
+  // Because this is an option, the above two restrictions are not enforced by
+  // the protocol compiler.
+  optional bool message_set_wire_format = 1 [default=false];
+
+  // Disables the generation of the standard "descriptor()" accessor, which can
+  // conflict with a field of the same name.  This is meant to make migration
+  // from proto1 easier; new code should avoid fields named "descriptor".
+  optional bool no_standard_descriptor_accessor = 2 [default=false];
+
+  // Is this message deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for the message, or it will be completely ignored; in the very least,
+  // this is a formalization for deprecating messages.
+  optional bool deprecated = 3 [default=false];
+
+  // Whether the message is an automatically generated map entry type for the
+  // maps field.
+  //
+  // For maps fields:
+  //     map<KeyType, ValueType> map_field = 1;
+  // The parsed descriptor looks like:
+  //     message MapFieldEntry {
+  //         option map_entry = true;
+  //         optional KeyType key = 1;
+  //         optional ValueType value = 2;
+  //     }
+  //     repeated MapFieldEntry map_field = 1;
+  //
+  // Implementations may choose not to generate the map_entry=true message, but
+  // use a native map in the target language to hold the keys and values.
+  // The reflection APIs in such implementions still need to work as
+  // if the field is a repeated message field.
+  //
+  // NOTE: Do not set the option in .proto files. Always use the maps syntax
+  // instead. The option should only be implicitly set by the proto compiler
+  // parser.
+  optional bool map_entry = 7;
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+message FieldOptions {
+  // The ctype option instructs the C++ code generator to use a different
+  // representation of the field than it normally would.  See the specific
+  // options below.  This option is not yet implemented in the open source
+  // release -- sorry, we'll try to include it in a future version!
+  optional CType ctype = 1 [default = STRING];
+  enum CType {
+    // Default mode.
+    STRING = 0;
+
+    CORD = 1;
+
+    STRING_PIECE = 2;
+  }
+  // The packed option can be enabled for repeated primitive fields to enable
+  // a more efficient representation on the wire. Rather than repeatedly
+  // writing the tag and type for each element, the entire array is encoded as
+  // a single length-delimited blob.
+  optional bool packed = 2;
+
+
+
+  // Should this field be parsed lazily?  Lazy applies only to message-type
+  // fields.  It means that when the outer message is initially parsed, the
+  // inner message's contents will not be parsed but instead stored in encoded
+  // form.  The inner message will actually be parsed when it is first accessed.
+  //
+  // This is only a hint.  Implementations are free to choose whether to use
+  // eager or lazy parsing regardless of the value of this option.  However,
+  // setting this option true suggests that the protocol author believes that
+  // using lazy parsing on this field is worth the additional bookkeeping
+  // overhead typically needed to implement it.
+  //
+  // This option does not affect the public interface of any generated code;
+  // all method signatures remain the same.  Furthermore, thread-safety of the
+  // interface is not affected by this option; const methods remain safe to
+  // call from multiple threads concurrently, while non-const methods continue
+  // to require exclusive access.
+  //
+  //
+  // Note that implementations may choose not to check required fields within
+  // a lazy sub-message.  That is, calling IsInitialized() on the outher message
+  // may return true even if the inner message has missing required fields.
+  // This is necessary because otherwise the inner message would have to be
+  // parsed in order to perform the check, defeating the purpose of lazy
+  // parsing.  An implementation which chooses not to check required fields
+  // must be consistent about it.  That is, for any particular sub-message, the
+  // implementation must either *always* check its required fields, or *never*
+  // check its required fields, regardless of whether or not the message has
+  // been parsed.
+  optional bool lazy = 5 [default=false];
+
+  // Is this field deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for accessors, or it will be completely ignored; in the very least, this
+  // is a formalization for deprecating fields.
+  optional bool deprecated = 3 [default=false];
+
+  // For Google-internal migration only. Do not use.
+  optional bool weak = 10 [default=false];
+
+
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+message EnumOptions {
+
+  // Set this option to true to allow mapping different tag names to the same
+  // value.
+  optional bool allow_alias = 2;
+
+  // Is this enum deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for the enum, or it will be completely ignored; in the very least, this
+  // is a formalization for deprecating enums.
+  optional bool deprecated = 3 [default=false];
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+message EnumValueOptions {
+  // Is this enum value deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for the enum value, or it will be completely ignored; in the very least,
+  // this is a formalization for deprecating enum values.
+  optional bool deprecated = 1 [default=false];
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+message ServiceOptions {
+
+  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+  //   framework.  We apologize for hoarding these numbers to ourselves, but
+  //   we were already using them long before we decided to release Protocol
+  //   Buffers.
+
+  // Is this service deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for the service, or it will be completely ignored; in the very least,
+  // this is a formalization for deprecating services.
+  optional bool deprecated = 33 [default=false];
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+message MethodOptions {
+
+  // Note:  Field numbers 1 through 32 are reserved for Google's internal RPC
+  //   framework.  We apologize for hoarding these numbers to ourselves, but
+  //   we were already using them long before we decided to release Protocol
+  //   Buffers.
+
+  // Is this method deprecated?
+  // Depending on the target platform, this can emit Deprecated annotations
+  // for the method, or it will be completely ignored; in the very least,
+  // this is a formalization for deprecating methods.
+  optional bool deprecated = 33 [default=false];
+
+  // The parser stores options it doesn't recognize here. See above.
+  repeated UninterpretedOption uninterpreted_option = 999;
+
+  // Clients can define custom options in extensions of this message. See above.
+  extensions 1000 to max;
+}
+
+
+// A message representing a option the parser does not recognize. This only
+// appears in options protos created by the compiler::Parser class.
+// DescriptorPool resolves these when building Descriptor objects. Therefore,
+// options protos in descriptor objects (e.g. returned by Descriptor::options(),
+// or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
+// in them.
+message UninterpretedOption {
+  // The name of the uninterpreted option.  Each string represents a segment in
+  // a dot-separated name.  is_extension is true iff a segment represents an
+  // extension (denoted with parentheses in options specs in .proto files).
+  // E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
+  // "foo.(bar.baz).qux".
+  message NamePart {
+    required string name_part = 1;
+    required bool is_extension = 2;
+  }
+  repeated NamePart name = 2;
+
+  // The value of the uninterpreted option, in whatever type the tokenizer
+  // identified it as during parsing. Exactly one of these should be set.
+  optional string identifier_value = 3;
+  optional uint64 positive_int_value = 4;
+  optional int64 negative_int_value = 5;
+  optional double double_value = 6;
+  optional bytes string_value = 7;
+  optional string aggregate_value = 8;
+}
+
+// ===================================================================
+// Optional source code info
+
+// Encapsulates information about the original source file from which a
+// FileDescriptorProto was generated.
+message SourceCodeInfo {
+  // A Location identifies a piece of source code in a .proto file which
+  // corresponds to a particular definition.  This information is intended
+  // to be useful to IDEs, code indexers, documentation generators, and similar
+  // tools.
+  //
+  // For example, say we have a file like:
+  //   message Foo {
+  //     optional string foo = 1;
+  //   }
+  // Let's look at just the field definition:
+  //   optional string foo = 1;
+  //   ^       ^^     ^^  ^  ^^^
+  //   a       bc     de  f  ghi
+  // We have the following locations:
+  //   span   path               represents
+  //   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.
+  //   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).
+  //   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).
+  //   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).
+  //   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).
+  //
+  // Notes:
+  // - A location may refer to a repeated field itself (i.e. not to any
+  //   particular index within it).  This is used whenever a set of elements are
+  //   logically enclosed in a single code segment.  For example, an entire
+  //   extend block (possibly containing multiple extension definitions) will
+  //   have an outer location whose path refers to the "extensions" repeated
+  //   field without an index.
+  // - Multiple locations may have the same path.  This happens when a single
+  //   logical declaration is spread out across multiple places.  The most
+  //   obvious example is the "extend" block again -- there may be multiple
+  //   extend blocks in the same scope, each of which will have the same path.
+  // - A location's span is not always a subset of its parent's span.  For
+  //   example, the "extendee" of an extension declaration appears at the
+  //   beginning of the "extend" block and is shared by all extensions within
+  //   the block.
+  // - Just because a location's span is a subset of some other location's span
+  //   does not mean that it is a descendent.  For example, a "group" defines
+  //   both a type and a field in a single declaration.  Thus, the locations
+  //   corresponding to the type and field and their components will overlap.
+  // - Code which tries to interpret locations should probably be designed to
+  //   ignore those that it doesn't understand, as more types of locations could
+  //   be recorded in the future.
+  repeated Location location = 1;
+  message Location {
+    // Identifies which part of the FileDescriptorProto was defined at this
+    // location.
+    //
+    // Each element is a field number or an index.  They form a path from
+    // the root FileDescriptorProto to the place where the definition.  For
+    // example, this path:
+    //   [ 4, 3, 2, 7, 1 ]
+    // refers to:
+    //   file.message_type(3)  // 4, 3
+    //       .field(7)         // 2, 7
+    //       .name()           // 1
+    // This is because FileDescriptorProto.message_type has field number 4:
+    //   repeated DescriptorProto message_type = 4;
+    // and DescriptorProto.field has field number 2:
+    //   repeated FieldDescriptorProto field = 2;
+    // and FieldDescriptorProto.name has field number 1:
+    //   optional string name = 1;
+    //
+    // Thus, the above path gives the location of a field name.  If we removed
+    // the last element:
+    //   [ 4, 3, 2, 7 ]
+    // this path refers to the whole field declaration (from the beginning
+    // of the label to the terminating semicolon).
+    repeated int32 path = 1 [packed=true];
+
+    // Always has exactly three or four elements: start line, start column,
+    // end line (optional, otherwise assumed same as start line), end column.
+    // These are packed into a single field for efficiency.  Note that line
+    // and column numbers are zero-based -- typically you will want to add
+    // 1 to each before displaying to a user.
+    repeated int32 span = 2 [packed=true];
+
+    // If this SourceCodeInfo represents a complete declaration, these are any
+    // comments appearing before and after the declaration which appear to be
+    // attached to the declaration.
+    //
+    // A series of line comments appearing on consecutive lines, with no other
+    // tokens appearing on those lines, will be treated as a single comment.
+    //
+    // Only the comment content is provided; comment markers (e.g. //) are
+    // stripped out.  For block comments, leading whitespace and an asterisk
+    // will be stripped from the beginning of each line other than the first.
+    // Newlines are included in the output.
+    //
+    // Examples:
+    //
+    //   optional int32 foo = 1;  // Comment attached to foo.
+    //   // Comment attached to bar.
+    //   optional int32 bar = 2;
+    //
+    //   optional string baz = 3;
+    //   // Comment attached to baz.
+    //   // Another line attached to baz.
+    //
+    //   // Comment attached to qux.
+    //   //
+    //   // Another line attached to qux.
+    //   optional double qux = 4;
+    //
+    //   optional string corge = 5;
+    //   /* Block comment attached
+    //    * to corge.  Leading asterisks
+    //    * will be removed. */
+    //   /* Block comment attached to
+    //    * grault. */
+    //   optional int32 grault = 6;
+    optional string leading_comments = 3;
+    optional string trailing_comments = 4;
+  }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/proto/nanopb.proto
@@ -0,0 +1,97 @@
+// Custom options for defining:
+// - Maximum size of string/bytes
+// - Maximum number of elements in array
+//
+// These are used by nanopb to generate statically allocable structures
+// for memory-limited environments.
+
+syntax = "proto2";
+import "google/protobuf/descriptor.proto";
+
+option java_package = "fi.kapsi.koti.jpa.nanopb";
+
+enum FieldType {
+    FT_DEFAULT = 0; // Automatically decide field type, generate static field if possible.
+    FT_CALLBACK = 1; // Always generate a callback field.
+    FT_POINTER = 4; // Always generate a dynamically allocated field.
+    FT_STATIC = 2; // Generate a static field or raise an exception if not possible.
+    FT_IGNORE = 3; // Ignore the field completely.
+}
+
+enum IntSize {
+    IS_DEFAULT = 0; // Default, 32/64bit based on type in .proto
+    IS_8 = 8;
+    IS_16 = 16;
+    IS_32 = 32;
+    IS_64 = 64;
+}
+
+// This is the inner options message, which basically defines options for
+// a field. When it is used in message or file scope, it applies to all
+// fields.
+message NanoPBOptions {
+  // Allocated size for 'bytes' and 'string' fields.
+  optional int32 max_size = 1;
+  
+  // Allocated number of entries in arrays ('repeated' fields)
+  optional int32 max_count = 2;
+  
+  // Size of integer fields. Can save some memory if you don't need
+  // full 32 bits for the value.
+  optional IntSize int_size = 7 [default = IS_DEFAULT];
+
+  // Force type of field (callback or static allocation)
+  optional FieldType type = 3 [default = FT_DEFAULT];
+  
+  // Use long names for enums, i.e. EnumName_EnumValue.
+  optional bool long_names = 4 [default = true];
+  
+  // Add 'packed' attribute to generated structs.
+  // Note: this cannot be used on CPUs that break on unaligned
+  // accesses to variables.
+  optional bool packed_struct = 5 [default = false];
+  
+  // Add 'packed' attribute to generated enums.
+  optional bool packed_enum = 10 [default = false];
+  
+  // Skip this message
+  optional bool skip_message = 6 [default = false];
+
+  // Generate oneof fields as normal optional fields instead of union.
+  optional bool no_unions = 8 [default = false];
+
+  // integer type tag for a message
+  optional uint32 msgid = 9;
+
+  // decode oneof as anonymous union
+  optional bool anonymous_oneof = 11 [default = false];
+}
+
+// Extensions to protoc 'Descriptor' type in order to define options
+// inside a .proto file.
+//
+// Protocol Buffers extension number registry
+// --------------------------------
+// Project:  Nanopb
+// Contact:  Petteri Aimonen <jpa@kapsi.fi>
+// Web site: http://kapsi.fi/~jpa/nanopb
+// Extensions: 1010 (all types)
+// --------------------------------
+
+extend google.protobuf.FileOptions {
+    optional NanoPBOptions nanopb_fileopt = 1010;
+}
+
+extend google.protobuf.MessageOptions {
+    optional NanoPBOptions nanopb_msgopt = 1010;
+}
+
+extend google.protobuf.EnumOptions {
+    optional NanoPBOptions nanopb_enumopt = 1010;
+}
+
+extend google.protobuf.FieldOptions {
+    optional NanoPBOptions nanopb = 1010;
+}
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/proto/plugin.proto
@@ -0,0 +1,148 @@
+// Protocol Buffers - Google's data interchange format
+// Copyright 2008 Google Inc.  All rights reserved.
+// https://developers.google.com/protocol-buffers/
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Author: kenton@google.com (Kenton Varda)
+//
+// WARNING:  The plugin interface is currently EXPERIMENTAL and is subject to
+//   change.
+//
+// protoc (aka the Protocol Compiler) can be extended via plugins.  A plugin is
+// just a program that reads a CodeGeneratorRequest from stdin and writes a
+// CodeGeneratorResponse to stdout.
+//
+// Plugins written using C++ can use google/protobuf/compiler/plugin.h instead
+// of dealing with the raw protocol defined here.
+//
+// A plugin executable needs only to be placed somewhere in the path.  The
+// plugin should be named "protoc-gen-$NAME", and will then be used when the
+// flag "--${NAME}_out" is passed to protoc.
+
+syntax = "proto2";
+package google.protobuf.compiler;
+option java_package = "com.google.protobuf.compiler";
+option java_outer_classname = "PluginProtos";
+
+import "google/protobuf/descriptor.proto";
+
+// An encoded CodeGeneratorRequest is written to the plugin's stdin.
+message CodeGeneratorRequest {
+  // The .proto files that were explicitly listed on the command-line.  The
+  // code generator should generate code only for these files.  Each file's
+  // descriptor will be included in proto_file, below.
+  repeated string file_to_generate = 1;
+
+  // The generator parameter passed on the command-line.
+  optional string parameter = 2;
+
+  // FileDescriptorProtos for all files in files_to_generate and everything
+  // they import.  The files will appear in topological order, so each file
+  // appears before any file that imports it.
+  //
+  // protoc guarantees that all proto_files will be written after
+  // the fields above, even though this is not technically guaranteed by the
+  // protobuf wire format.  This theoretically could allow a plugin to stream
+  // in the FileDescriptorProtos and handle them one by one rather than read
+  // the entire set into memory at once.  However, as of this writing, this
+  // is not similarly optimized on protoc's end -- it will store all fields in
+  // memory at once before sending them to the plugin.
+  repeated FileDescriptorProto proto_file = 15;
+}
+
+// The plugin writes an encoded CodeGeneratorResponse to stdout.
+message CodeGeneratorResponse {
+  // Error message.  If non-empty, code generation failed.  The plugin process
+  // should exit with status code zero even if it reports an error in this way.
+  //
+  // This should be used to indicate errors in .proto files which prevent the
+  // code generator from generating correct code.  Errors which indicate a
+  // problem in protoc itself -- such as the input CodeGeneratorRequest being
+  // unparseable -- should be reported by writing a message to stderr and
+  // exiting with a non-zero status code.
+  optional string error = 1;
+
+  // Represents a single generated file.
+  message File {
+    // The file name, relative to the output directory.  The name must not
+    // contain "." or ".." components and must be relative, not be absolute (so,
+    // the file cannot lie outside the output directory).  "/" must be used as
+    // the path separator, not "\".
+    //
+    // If the name is omitted, the content will be appended to the previous
+    // file.  This allows the generator to break large files into small chunks,
+    // and allows the generated text to be streamed back to protoc so that large
+    // files need not reside completely in memory at one time.  Note that as of
+    // this writing protoc does not optimize for this -- it will read the entire
+    // CodeGeneratorResponse before writing files to disk.
+    optional string name = 1;
+
+    // If non-empty, indicates that the named file should already exist, and the
+    // content here is to be inserted into that file at a defined insertion
+    // point.  This feature allows a code generator to extend the output
+    // produced by another code generator.  The original generator may provide
+    // insertion points by placing special annotations in the file that look
+    // like:
+    //   @@protoc_insertion_point(NAME)
+    // The annotation can have arbitrary text before and after it on the line,
+    // which allows it to be placed in a comment.  NAME should be replaced with
+    // an identifier naming the point -- this is what other generators will use
+    // as the insertion_point.  Code inserted at this point will be placed
+    // immediately above the line containing the insertion point (thus multiple
+    // insertions to the same point will come out in the order they were added).
+    // The double-@ is intended to make it unlikely that the generated code
+    // could contain things that look like insertion points by accident.
+    //
+    // For example, the C++ code generator places the following line in the
+    // .pb.h files that it generates:
+    //   // @@protoc_insertion_point(namespace_scope)
+    // This line appears within the scope of the file's package namespace, but
+    // outside of any particular class.  Another plugin can then specify the
+    // insertion_point "namespace_scope" to generate additional classes or
+    // other declarations that should be placed in this scope.
+    //
+    // Note that if the line containing the insertion point begins with
+    // whitespace, the same whitespace will be added to every line of the
+    // inserted text.  This is useful for languages like Python, where
+    // indentation matters.  In these languages, the insertion point comment
+    // should be indented the same amount as any inserted code will need to be
+    // in order to work correctly in that context.
+    //
+    // The code generator that generates the initial file and the one which
+    // inserts into it must both run as part of a single invocation of protoc.
+    // Code generators are executed in the order in which they appear on the
+    // command line.
+    //
+    // If |insertion_point| is present, |name| must also be present.
+    optional string insertion_point = 2;
+
+    // The file contents.
+    optional string content = 15;
+  }
+  repeated File file = 15;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/protoc-gen-nanopb
@@ -0,0 +1,13 @@
+#!/bin/sh
+
+# This file is used to invoke nanopb_generator.py as a plugin
+# to protoc on Linux and other *nix-style systems.
+# Use it like this:
+# protoc --plugin=nanopb=..../protoc-gen-nanopb --nanopb_out=dir foo.proto
+#
+# Note that if you use the binary package of nanopb, the protoc
+# path is already set up properly and there is no need to give
+# --plugin= on the command line.
+
+MYPATH=$(dirname "$0")
+exec "$MYPATH/nanopb_generator.py" --protoc-plugin
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/generator/protoc-gen-nanopb.bat
@@ -0,0 +1,12 @@
+@echo off
+:: This file is used to invoke nanopb_generator.py as a plugin
+:: to protoc on Windows.
+:: Use it like this:
+:: protoc --plugin=nanopb=..../protoc-gen-nanopb.bat --nanopb_out=dir foo.proto
+::
+:: Note that if you use the binary package of nanopb, the protoc
+:: path is already set up properly and there is no need to give
+:: --plugin= on the command line.
+
+set mydir=%~dp0
+python "%mydir%\nanopb_generator.py" --protoc-plugin
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/library.json
@@ -0,0 +1,22 @@
+{
+  "name": "Nanopb",
+  "keywords": "protocol buffers, protobuf, google",
+  "description": "Nanopb is a plain-C implementation of Google's Protocol Buffers data format. It is targeted at 32 bit microcontrollers, but is also fit for other embedded systems with tight (2-10 kB ROM, <1 kB RAM) memory constraints.",
+  "repository": {
+    "type": "git",
+    "url": "https://github.com/nanopb/nanopb.git"
+  },
+  "authors": [{
+    "name": "Petteri Aimonen",
+    "email": "jpa@nanopb.mail.kapsi.fi",
+    "url": "http://koti.kapsi.fi/jpa/nanopb/"
+  }],
+  "include": [
+    "*.c",
+    "*.cpp",
+    "*.h"
+  ],
+  "examples": "examples/*/*.c",
+  "frameworks": "*",
+  "platforms": "*"
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb.h
@@ -0,0 +1,556 @@
+/* Common parts of the nanopb library. Most of these are quite low-level
+ * stuff. For the high-level interface, see pb_encode.h and pb_decode.h.
+ */
+
+#ifndef PB_H_INCLUDED
+#define PB_H_INCLUDED
+
+/*****************************************************************
+ * Nanopb compilation time options. You can change these here by *
+ * uncommenting the lines, or on the compiler command line.      *
+ *****************************************************************/
+
+/* Enable support for dynamically allocated fields */
+/* #define PB_ENABLE_MALLOC 1 */
+
+/* Define this if your CPU / compiler combination does not support
+ * unaligned memory access to packed structures. */
+/* #define PB_NO_PACKED_STRUCTS 1 */
+
+/* Increase the number of required fields that are tracked.
+ * A compiler warning will tell if you need this. */
+/* #define PB_MAX_REQUIRED_FIELDS 256 */
+
+/* Add support for tag numbers > 255 and fields larger than 255 bytes. */
+/* #define PB_FIELD_16BIT 1 */
+
+/* Add support for tag numbers > 65536 and fields larger than 65536 bytes. */
+/* #define PB_FIELD_32BIT 1 */
+
+/* Disable support for error messages in order to save some code space. */
+/* #define PB_NO_ERRMSG 1 */
+
+/* Disable support for custom streams (support only memory buffers). */
+/* #define PB_BUFFER_ONLY 1 */
+
+/* Switch back to the old-style callback function signature.
+ * This was the default until nanopb-0.2.1. */
+/* #define PB_OLD_CALLBACK_STYLE */
+
+
+/******************************************************************
+ * You usually don't need to change anything below this line.     *
+ * Feel free to look around and use the defined macros, though.   *
+ ******************************************************************/
+
+
+/* Version of the nanopb library. Just in case you want to check it in
+ * your own program. */
+#define NANOPB_VERSION nanopb-0.3.6
+
+/* Include all the system headers needed by nanopb. You will need the
+ * definitions of the following:
+ * - strlen, memcpy, memset functions
+ * - [u]int_least8_t, uint_fast8_t, [u]int_least16_t, [u]int32_t, [u]int64_t
+ * - size_t
+ * - bool
+ *
+ * If you don't have the standard header files, you can instead provide
+ * a custom header that defines or includes all this. In that case,
+ * define PB_SYSTEM_HEADER to the path of this file.
+ */
+#ifdef PB_SYSTEM_HEADER
+#include PB_SYSTEM_HEADER
+#else
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <string.h>
+
+#ifdef PB_ENABLE_MALLOC
+#include <stdlib.h>
+#endif
+#endif
+
+/* Macro for defining packed structures (compiler dependent).
+ * This just reduces memory requirements, but is not required.
+ */
+#if defined(PB_NO_PACKED_STRUCTS)
+    /* Disable struct packing */
+#   define PB_PACKED_STRUCT_START
+#   define PB_PACKED_STRUCT_END
+#   define pb_packed
+#elif defined(__GNUC__) || defined(__clang__)
+    /* For GCC and clang */
+#   define PB_PACKED_STRUCT_START
+#   define PB_PACKED_STRUCT_END
+#   define pb_packed __attribute__((packed))
+#elif defined(__ICCARM__) || defined(__CC_ARM)
+    /* For IAR ARM and Keil MDK-ARM compilers */
+#   define PB_PACKED_STRUCT_START _Pragma("pack(push, 1)")
+#   define PB_PACKED_STRUCT_END _Pragma("pack(pop)")
+#   define pb_packed
+#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
+    /* For Microsoft Visual C++ */
+#   define PB_PACKED_STRUCT_START __pragma(pack(push, 1))
+#   define PB_PACKED_STRUCT_END __pragma(pack(pop))
+#   define pb_packed
+#else
+    /* Unknown compiler */
+#   define PB_PACKED_STRUCT_START
+#   define PB_PACKED_STRUCT_END
+#   define pb_packed
+#endif
+
+/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
+#ifndef PB_UNUSED
+#define PB_UNUSED(x) (void)(x)
+#endif
+
+/* Compile-time assertion, used for checking compatible compilation options.
+ * If this does not work properly on your compiler, use
+ * #define PB_NO_STATIC_ASSERT to disable it.
+ *
+ * But before doing that, check carefully the error message / place where it
+ * comes from to see if the error has a real cause. Unfortunately the error
+ * message is not always very clear to read, but you can see the reason better
+ * in the place where the PB_STATIC_ASSERT macro was called.
+ */
+#ifndef PB_NO_STATIC_ASSERT
+#ifndef PB_STATIC_ASSERT
+#define PB_STATIC_ASSERT(COND,MSG) typedef char PB_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
+#define PB_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
+#define PB_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) pb_static_assertion_##MSG##LINE##COUNTER
+#endif
+#else
+#define PB_STATIC_ASSERT(COND,MSG)
+#endif
+
+/* Number of required fields to keep track of. */
+#ifndef PB_MAX_REQUIRED_FIELDS
+#define PB_MAX_REQUIRED_FIELDS 64
+#endif
+
+#if PB_MAX_REQUIRED_FIELDS < 64
+#error You should not lower PB_MAX_REQUIRED_FIELDS from the default value (64).
+#endif
+
+/* List of possible field types. These are used in the autogenerated code.
+ * Least-significant 4 bits tell the scalar type
+ * Most-significant 4 bits specify repeated/required/packed etc.
+ */
+
+typedef uint_least8_t pb_type_t;
+
+/**** Field data types ****/
+
+/* Numeric types */
+#define PB_LTYPE_VARINT  0x00 /* int32, int64, enum, bool */
+#define PB_LTYPE_UVARINT 0x01 /* uint32, uint64 */
+#define PB_LTYPE_SVARINT 0x02 /* sint32, sint64 */
+#define PB_LTYPE_FIXED32 0x03 /* fixed32, sfixed32, float */
+#define PB_LTYPE_FIXED64 0x04 /* fixed64, sfixed64, double */
+
+/* Marker for last packable field type. */
+#define PB_LTYPE_LAST_PACKABLE 0x04
+
+/* Byte array with pre-allocated buffer.
+ * data_size is the length of the allocated PB_BYTES_ARRAY structure. */
+#define PB_LTYPE_BYTES 0x05
+
+/* String with pre-allocated buffer.
+ * data_size is the maximum length. */
+#define PB_LTYPE_STRING 0x06
+
+/* Submessage
+ * submsg_fields is pointer to field descriptions */
+#define PB_LTYPE_SUBMESSAGE 0x07
+
+/* Extension pseudo-field
+ * The field contains a pointer to pb_extension_t */
+#define PB_LTYPE_EXTENSION 0x08
+
+/* Number of declared LTYPES */
+#define PB_LTYPES_COUNT 9
+#define PB_LTYPE_MASK 0x0F
+
+/**** Field repetition rules ****/
+
+#define PB_HTYPE_REQUIRED 0x00
+#define PB_HTYPE_OPTIONAL 0x10
+#define PB_HTYPE_REPEATED 0x20
+#define PB_HTYPE_ONEOF    0x30
+#define PB_HTYPE_MASK     0x30
+
+/**** Field allocation types ****/
+ 
+#define PB_ATYPE_STATIC   0x00
+#define PB_ATYPE_POINTER  0x80
+#define PB_ATYPE_CALLBACK 0x40
+#define PB_ATYPE_MASK     0xC0
+
+#define PB_ATYPE(x) ((x) & PB_ATYPE_MASK)
+#define PB_HTYPE(x) ((x) & PB_HTYPE_MASK)
+#define PB_LTYPE(x) ((x) & PB_LTYPE_MASK)
+
+/* Data type used for storing sizes of struct fields
+ * and array counts.
+ */
+#if defined(PB_FIELD_32BIT)
+    typedef uint32_t pb_size_t;
+    typedef int32_t pb_ssize_t;
+#elif defined(PB_FIELD_16BIT)
+    typedef uint_least16_t pb_size_t;
+    typedef int_least16_t pb_ssize_t;
+#else
+    typedef uint_least8_t pb_size_t;
+    typedef int_least8_t pb_ssize_t;
+#endif
+#define PB_SIZE_MAX ((pb_size_t)-1)
+
+/* Data type for storing encoded data and other byte streams.
+ * This typedef exists to support platforms where uint8_t does not exist.
+ * You can regard it as equivalent on uint8_t on other platforms.
+ */
+typedef uint_least8_t pb_byte_t;
+
+/* This structure is used in auto-generated constants
+ * to specify struct fields.
+ * You can change field sizes if you need structures
+ * larger than 256 bytes or field tags larger than 256.
+ * The compiler should complain if your .proto has such
+ * structures. Fix that by defining PB_FIELD_16BIT or
+ * PB_FIELD_32BIT.
+ */
+PB_PACKED_STRUCT_START
+typedef struct pb_field_s pb_field_t;
+struct pb_field_s {
+    pb_size_t tag;
+    pb_type_t type;
+    pb_size_t data_offset; /* Offset of field data, relative to previous field. */
+    pb_ssize_t size_offset; /* Offset of array size or has-boolean, relative to data */
+    pb_size_t data_size; /* Data size in bytes for a single item */
+    pb_size_t array_size; /* Maximum number of entries in array */
+    
+    /* Field definitions for submessage
+     * OR default value for all other non-array, non-callback types
+     * If null, then field will zeroed. */
+    const void *ptr;
+} pb_packed;
+PB_PACKED_STRUCT_END
+
+/* Make sure that the standard integer types are of the expected sizes.
+ * Otherwise fixed32/fixed64 fields can break.
+ *
+ * If you get errors here, it probably means that your stdint.h is not
+ * correct for your platform.
+ */
+PB_STATIC_ASSERT(sizeof(int64_t) == 2 * sizeof(int32_t), INT64_T_WRONG_SIZE)
+PB_STATIC_ASSERT(sizeof(uint64_t) == 2 * sizeof(uint32_t), UINT64_T_WRONG_SIZE)
+
+/* This structure is used for 'bytes' arrays.
+ * It has the number of bytes in the beginning, and after that an array.
+ * Note that actual structs used will have a different length of bytes array.
+ */
+#define PB_BYTES_ARRAY_T(n) struct { pb_size_t size; pb_byte_t bytes[n]; }
+#define PB_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(pb_bytes_array_t, bytes))
+
+struct pb_bytes_array_s {
+    pb_size_t size;
+    pb_byte_t bytes[1];
+};
+typedef struct pb_bytes_array_s pb_bytes_array_t;
+
+/* This structure is used for giving the callback function.
+ * It is stored in the message structure and filled in by the method that
+ * calls pb_decode.
+ *
+ * The decoding callback will be given a limited-length stream
+ * If the wire type was string, the length is the length of the string.
+ * If the wire type was a varint/fixed32/fixed64, the length is the length
+ * of the actual value.
+ * The function may be called multiple times (especially for repeated types,
+ * but also otherwise if the message happens to contain the field multiple
+ * times.)
+ *
+ * The encoding callback will receive the actual output stream.
+ * It should write all the data in one call, including the field tag and
+ * wire type. It can write multiple fields.
+ *
+ * The callback can be null if you want to skip a field.
+ */
+typedef struct pb_istream_s pb_istream_t;
+typedef struct pb_ostream_s pb_ostream_t;
+typedef struct pb_callback_s pb_callback_t;
+struct pb_callback_s {
+#ifdef PB_OLD_CALLBACK_STYLE
+    /* Deprecated since nanopb-0.2.1 */
+    union {
+        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void *arg);
+        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, const void *arg);
+    } funcs;
+#else
+    /* New function signature, which allows modifying arg contents in callback. */
+    union {
+        bool (*decode)(pb_istream_t *stream, const pb_field_t *field, void **arg);
+        bool (*encode)(pb_ostream_t *stream, const pb_field_t *field, void * const *arg);
+    } funcs;
+#endif    
+    
+    /* Free arg for use by callback */
+    void *arg;
+};
+
+/* Wire types. Library user needs these only in encoder callbacks. */
+typedef enum {
+    PB_WT_VARINT = 0,
+    PB_WT_64BIT  = 1,
+    PB_WT_STRING = 2,
+    PB_WT_32BIT  = 5
+} pb_wire_type_t;
+
+/* Structure for defining the handling of unknown/extension fields.
+ * Usually the pb_extension_type_t structure is automatically generated,
+ * while the pb_extension_t structure is created by the user. However,
+ * if you want to catch all unknown fields, you can also create a custom
+ * pb_extension_type_t with your own callback.
+ */
+typedef struct pb_extension_type_s pb_extension_type_t;
+typedef struct pb_extension_s pb_extension_t;
+struct pb_extension_type_s {
+    /* Called for each unknown field in the message.
+     * If you handle the field, read off all of its data and return true.
+     * If you do not handle the field, do not read anything and return true.
+     * If you run into an error, return false.
+     * Set to NULL for default handler.
+     */
+    bool (*decode)(pb_istream_t *stream, pb_extension_t *extension,
+                   uint32_t tag, pb_wire_type_t wire_type);
+    
+    /* Called once after all regular fields have been encoded.
+     * If you have something to write, do so and return true.
+     * If you do not have anything to write, just return true.
+     * If you run into an error, return false.
+     * Set to NULL for default handler.
+     */
+    bool (*encode)(pb_ostream_t *stream, const pb_extension_t *extension);
+    
+    /* Free field for use by the callback. */
+    const void *arg;
+};
+
+struct pb_extension_s {
+    /* Type describing the extension field. Usually you'll initialize
+     * this to a pointer to the automatically generated structure. */
+    const pb_extension_type_t *type;
+    
+    /* Destination for the decoded data. This must match the datatype
+     * of the extension field. */
+    void *dest;
+    
+    /* Pointer to the next extension handler, or NULL.
+     * If this extension does not match a field, the next handler is
+     * automatically called. */
+    pb_extension_t *next;
+
+    /* The decoder sets this to true if the extension was found.
+     * Ignored for encoding. */
+    bool found;
+};
+
+/* Memory allocation functions to use. You can define pb_realloc and
+ * pb_free to custom functions if you want. */
+#ifdef PB_ENABLE_MALLOC
+#   ifndef pb_realloc
+#       define pb_realloc(ptr, size) realloc(ptr, size)
+#   endif
+#   ifndef pb_free
+#       define pb_free(ptr) free(ptr)
+#   endif
+#endif
+
+/* This is used to inform about need to regenerate .pb.h/.pb.c files. */
+#define PB_PROTO_HEADER_VERSION 30
+
+/* These macros are used to declare pb_field_t's in the constant array. */
+/* Size of a structure member, in bytes. */
+#define pb_membersize(st, m) (sizeof ((st*)0)->m)
+/* Number of entries in an array. */
+#define pb_arraysize(st, m) (pb_membersize(st, m) / pb_membersize(st, m[0]))
+/* Delta from start of one member to the start of another member. */
+#define pb_delta(st, m1, m2) ((int)offsetof(st, m1) - (int)offsetof(st, m2))
+/* Marks the end of the field list */
+#define PB_LAST_FIELD {0,(pb_type_t) 0,0,0,0,0,0}
+
+/* Macros for filling in the data_offset field */
+/* data_offset for first field in a message */
+#define PB_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
+/* data_offset for subsequent fields */
+#define PB_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - pb_membersize(st, m2))
+/* Choose first/other based on m1 == m2 (deprecated, remains for backwards compatibility) */
+#define PB_DATAOFFSET_CHOOSE(st, m1, m2) (int)(offsetof(st, m1) == offsetof(st, m2) \
+                                  ? PB_DATAOFFSET_FIRST(st, m1, m2) \
+                                  : PB_DATAOFFSET_OTHER(st, m1, m2))
+
+/* Required fields are the simplest. They just have delta (padding) from
+ * previous field end, and the size of the field. Pointer is used for
+ * submessages and default values.
+ */
+#define PB_REQUIRED_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_REQUIRED | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+
+/* Optional fields add the delta to the has_ variable. */
+#define PB_OPTIONAL_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
+    fd, \
+    pb_delta(st, has_ ## m, m), \
+    pb_membersize(st, m), 0, ptr}
+
+/* Repeated fields have a _count field and also the maximum number of entries. */
+#define PB_REPEATED_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_REPEATED | ltype, \
+    fd, \
+    pb_delta(st, m ## _count, m), \
+    pb_membersize(st, m[0]), \
+    pb_arraysize(st, m), ptr}
+
+/* Allocated fields carry the size of the actual data, not the pointer */
+#define PB_REQUIRED_POINTER(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_REQUIRED | ltype, \
+    fd, 0, pb_membersize(st, m[0]), 0, ptr}
+
+/* Optional fields don't need a has_ variable, as information would be redundant */
+#define PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_OPTIONAL | ltype, \
+    fd, 0, pb_membersize(st, m[0]), 0, ptr}
+
+/* Repeated fields have a _count field and a pointer to array of pointers */
+#define PB_REPEATED_POINTER(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_REPEATED | ltype, \
+    fd, pb_delta(st, m ## _count, m), \
+    pb_membersize(st, m[0]), 0, ptr}
+
+/* Callbacks are much like required fields except with special datatype. */
+#define PB_REQUIRED_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REQUIRED | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+
+#define PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_OPTIONAL | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+    
+#define PB_REPEATED_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_CALLBACK | PB_HTYPE_REPEATED | ltype, \
+    fd, 0, pb_membersize(st, m), 0, ptr}
+
+/* Optional extensions don't have the has_ field, as that would be redundant. */
+#define PB_OPTEXT_STATIC(tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_OPTIONAL | ltype, \
+    0, \
+    0, \
+    pb_membersize(st, m), 0, ptr}
+
+#define PB_OPTEXT_POINTER(tag, st, m, fd, ltype, ptr) \
+    PB_OPTIONAL_POINTER(tag, st, m, fd, ltype, ptr)
+
+#define PB_OPTEXT_CALLBACK(tag, st, m, fd, ltype, ptr) \
+    PB_OPTIONAL_CALLBACK(tag, st, m, fd, ltype, ptr)
+
+/* The mapping from protobuf types to LTYPEs is done using these macros. */
+#define PB_LTYPE_MAP_BOOL       PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_BYTES      PB_LTYPE_BYTES
+#define PB_LTYPE_MAP_DOUBLE     PB_LTYPE_FIXED64
+#define PB_LTYPE_MAP_ENUM       PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_UENUM      PB_LTYPE_UVARINT
+#define PB_LTYPE_MAP_FIXED32    PB_LTYPE_FIXED32
+#define PB_LTYPE_MAP_FIXED64    PB_LTYPE_FIXED64
+#define PB_LTYPE_MAP_FLOAT      PB_LTYPE_FIXED32
+#define PB_LTYPE_MAP_INT32      PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_INT64      PB_LTYPE_VARINT
+#define PB_LTYPE_MAP_MESSAGE    PB_LTYPE_SUBMESSAGE
+#define PB_LTYPE_MAP_SFIXED32   PB_LTYPE_FIXED32
+#define PB_LTYPE_MAP_SFIXED64   PB_LTYPE_FIXED64
+#define PB_LTYPE_MAP_SINT32     PB_LTYPE_SVARINT
+#define PB_LTYPE_MAP_SINT64     PB_LTYPE_SVARINT
+#define PB_LTYPE_MAP_STRING     PB_LTYPE_STRING
+#define PB_LTYPE_MAP_UINT32     PB_LTYPE_UVARINT
+#define PB_LTYPE_MAP_UINT64     PB_LTYPE_UVARINT
+#define PB_LTYPE_MAP_EXTENSION  PB_LTYPE_EXTENSION
+
+/* This is the actual macro used in field descriptions.
+ * It takes these arguments:
+ * - Field tag number
+ * - Field type:   BOOL, BYTES, DOUBLE, ENUM, UENUM, FIXED32, FIXED64,
+ *                 FLOAT, INT32, INT64, MESSAGE, SFIXED32, SFIXED64
+ *                 SINT32, SINT64, STRING, UINT32, UINT64 or EXTENSION
+ * - Field rules:  REQUIRED, OPTIONAL or REPEATED
+ * - Allocation:   STATIC or CALLBACK
+ * - Placement: FIRST or OTHER, depending on if this is the first field in structure.
+ * - Message name
+ * - Field name
+ * - Previous field name (or field name again for first field)
+ * - Pointer to default value or submsg fields.
+ */
+
+#define PB_FIELD(tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
+        PB_ ## rules ## _ ## allocation(tag, message, field, \
+        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
+        PB_LTYPE_MAP_ ## type, ptr)
+
+/* Field description for oneof fields. This requires taking into account the
+ * union name also, that's why a separate set of macros is needed.
+ */
+#define PB_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, u.m), \
+    pb_membersize(st, u.m), 0, ptr}
+
+#define PB_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, u.m), \
+    pb_membersize(st, u.m[0]), 0, ptr}
+
+#define PB_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
+        PB_ONEOF_ ## allocation(union_name, tag, message, field, \
+        PB_DATAOFFSET_ ## placement(message, union_name.field, prevfield), \
+        PB_LTYPE_MAP_ ## type, ptr)
+
+#define PB_ANONYMOUS_ONEOF_STATIC(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_STATIC | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, m), \
+    pb_membersize(st, m), 0, ptr}
+
+#define PB_ANONYMOUS_ONEOF_POINTER(u, tag, st, m, fd, ltype, ptr) \
+    {tag, PB_ATYPE_POINTER | PB_HTYPE_ONEOF | ltype, \
+    fd, pb_delta(st, which_ ## u, m), \
+    pb_membersize(st, m[0]), 0, ptr}
+
+#define PB_ANONYMOUS_ONEOF_FIELD(union_name, tag, type, rules, allocation, placement, message, field, prevfield, ptr) \
+        PB_ANONYMOUS_ONEOF_ ## allocation(union_name, tag, message, field, \
+        PB_DATAOFFSET_ ## placement(message, field, prevfield), \
+        PB_LTYPE_MAP_ ## type, ptr)
+
+/* These macros are used for giving out error messages.
+ * They are mostly a debugging aid; the main error information
+ * is the true/false return value from functions.
+ * Some code space can be saved by disabling the error
+ * messages if not used.
+ *
+ * PB_SET_ERROR() sets the error message if none has been set yet.
+ *                msg must be a constant string literal.
+ * PB_GET_ERROR() always returns a pointer to a string.
+ * PB_RETURN_ERROR() sets the error and returns false from current
+ *                   function.
+ */
+#ifdef PB_NO_ERRMSG
+#define PB_SET_ERROR(stream, msg) PB_UNUSED(stream)
+#define PB_GET_ERROR(stream) "(errmsg disabled)"
+#else
+#define PB_SET_ERROR(stream, msg) (stream->errmsg = (stream)->errmsg ? (stream)->errmsg : (msg))
+#define PB_GET_ERROR(stream) ((stream)->errmsg ? (stream)->errmsg : "(none)")
+#endif
+
+#define PB_RETURN_ERROR(stream, msg) return PB_SET_ERROR(stream, msg), false
+
+#endif
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb_common.c
@@ -0,0 +1,97 @@
+/* pb_common.c: Common support functions for pb_encode.c and pb_decode.c.
+ *
+ * 2014 Petteri Aimonen <jpa@kapsi.fi>
+ */
+
+#include "pb_common.h"
+
+bool pb_field_iter_begin(pb_field_iter_t *iter, const pb_field_t *fields, void *dest_struct)
+{
+    iter->start = fields;
+    iter->pos = fields;
+    iter->required_field_index = 0;
+    iter->dest_struct = dest_struct;
+    iter->pData = (char*)dest_struct + iter->pos->data_offset;
+    iter->pSize = (char*)iter->pData + iter->pos->size_offset;
+    
+    return (iter->pos->tag != 0);
+}
+
+bool pb_field_iter_next(pb_field_iter_t *iter)
+{
+    const pb_field_t *prev_field = iter->pos;
+
+    if (prev_field->tag == 0)
+    {
+        /* Handle empty message types, where the first field is already the terminator.
+         * In other cases, the iter->pos never points to the terminator. */
+        return false;
+    }
+    
+    iter->pos++;
+    
+    if (iter->pos->tag == 0)
+    {
+        /* Wrapped back to beginning, reinitialize */
+        (void)pb_field_iter_begin(iter, iter->start, iter->dest_struct);
+        return false;
+    }
+    else
+    {
+        /* Increment the pointers based on previous field size */
+        size_t prev_size = prev_field->data_size;
+    
+        if (PB_HTYPE(prev_field->type) == PB_HTYPE_ONEOF &&
+            PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)
+        {
+            /* Don't advance pointers inside unions */
+            prev_size = 0;
+            iter->pData = (char*)iter->pData - prev_field->data_offset;
+        }
+        else if (PB_ATYPE(prev_field->type) == PB_ATYPE_STATIC &&
+                 PB_HTYPE(prev_field->type) == PB_HTYPE_REPEATED)
+        {
+            /* In static arrays, the data_size tells the size of a single entry and
+             * array_size is the number of entries */
+            prev_size *= prev_field->array_size;
+        }
+        else if (PB_ATYPE(prev_field->type) == PB_ATYPE_POINTER)
+        {
+            /* Pointer fields always have a constant size in the main structure.
+             * The data_size only applies to the dynamically allocated area. */
+            prev_size = sizeof(void*);
+        }
+
+        if (PB_HTYPE(prev_field->type) == PB_HTYPE_REQUIRED)
+        {
+            /* Count the required fields, in order to check their presence in the
+             * decoder. */
+            iter->required_field_index++;
+        }
+    
+        iter->pData = (char*)iter->pData + prev_size + iter->pos->data_offset;
+        iter->pSize = (char*)iter->pData + iter->pos->size_offset;
+        return true;
+    }
+}
+
+bool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag)
+{
+    const pb_field_t *start = iter->pos;
+    
+    do {
+        if (iter->pos->tag == tag &&
+            PB_LTYPE(iter->pos->type) != PB_LTYPE_EXTENSION)
+        {
+            /* Found the wanted field */
+            return true;
+        }
+        
+        (void)pb_field_iter_next(iter);
+    } while (iter->pos != start);
+    
+    /* Searched all the way back to start, and found nothing. */
+    return false;
+}
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb_common.h
@@ -0,0 +1,42 @@
+/* pb_common.h: Common support functions for pb_encode.c and pb_decode.c.
+ * These functions are rarely needed by applications directly.
+ */
+
+#ifndef PB_COMMON_H_INCLUDED
+#define PB_COMMON_H_INCLUDED
+
+#include "pb.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Iterator for pb_field_t list */
+struct pb_field_iter_s {
+    const pb_field_t *start;       /* Start of the pb_field_t array */
+    const pb_field_t *pos;         /* Current position of the iterator */
+    unsigned required_field_index; /* Zero-based index that counts only the required fields */
+    void *dest_struct;             /* Pointer to start of the structure */
+    void *pData;                   /* Pointer to current field value */
+    void *pSize;                   /* Pointer to count/has field */
+};
+typedef struct pb_field_iter_s pb_field_iter_t;
+
+/* Initialize the field iterator structure to beginning.
+ * Returns false if the message type is empty. */
+bool pb_field_iter_begin(pb_field_iter_t *iter, const pb_field_t *fields, void *dest_struct);
+
+/* Advance the iterator to the next field.
+ * Returns false when the iterator wraps back to the first field. */
+bool pb_field_iter_next(pb_field_iter_t *iter);
+
+/* Advance the iterator until it points at a field with the given tag.
+ * Returns false if no such field exists. */
+bool pb_field_iter_find(pb_field_iter_t *iter, uint32_t tag);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb_decode.c
@@ -0,0 +1,1340 @@
+/* pb_decode.c -- decode a protobuf using minimal resources
+ *
+ * 2011 Petteri Aimonen <jpa@kapsi.fi>
+ */
+
+/* Use the GCC warn_unused_result attribute to check that all return values
+ * are propagated correctly. On other compilers and gcc before 3.4.0 just
+ * ignore the annotation.
+ */
+#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+    #define checkreturn
+#else
+    #define checkreturn __attribute__((warn_unused_result))
+#endif
+
+#include "pb.h"
+#include "pb_decode.h"
+#include "pb_common.h"
+
+/**************************************
+ * Declarations internal to this file *
+ **************************************/
+
+typedef bool (*pb_decoder_t)(pb_istream_t *stream, const pb_field_t *field, void *dest) checkreturn;
+
+static bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+static bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest);
+static bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size);
+static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension);
+static bool checkreturn default_extension_decoder(pb_istream_t *stream, pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type);
+static bool checkreturn decode_extension(pb_istream_t *stream, uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter);
+static bool checkreturn find_extension_field(pb_field_iter_t *iter);
+static void pb_field_set_to_default(pb_field_iter_t *iter);
+static void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct);
+static bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest);
+static bool checkreturn pb_skip_varint(pb_istream_t *stream);
+static bool checkreturn pb_skip_string(pb_istream_t *stream);
+
+#ifdef PB_ENABLE_MALLOC
+static bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size);
+static bool checkreturn pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter);
+static void pb_release_single_field(const pb_field_iter_t *iter);
+#endif
+
+/* --- Function pointers to field decoders ---
+ * Order in the array must match pb_action_t LTYPE numbering.
+ */
+static const pb_decoder_t PB_DECODERS[PB_LTYPES_COUNT] = {
+    &pb_dec_varint,
+    &pb_dec_uvarint,
+    &pb_dec_svarint,
+    &pb_dec_fixed32,
+    &pb_dec_fixed64,
+    
+    &pb_dec_bytes,
+    &pb_dec_string,
+    &pb_dec_submessage,
+    NULL /* extensions */
+};
+
+/*******************************
+ * pb_istream_t implementation *
+ *******************************/
+
+static bool checkreturn buf_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)
+{
+    const pb_byte_t *source = (const pb_byte_t*)stream->state;
+    stream->state = (pb_byte_t*)stream->state + count;
+    
+    if (buf != NULL)
+    {
+        while (count--)
+            *buf++ = *source++;
+    }
+    
+    return true;
+}
+
+bool checkreturn pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count)
+{
+#ifndef PB_BUFFER_ONLY
+	if (buf == NULL && stream->callback != buf_read)
+	{
+		/* Skip input bytes */
+		pb_byte_t tmp[16];
+		while (count > 16)
+		{
+			if (!pb_read(stream, tmp, 16))
+				return false;
+			
+			count -= 16;
+		}
+		
+		return pb_read(stream, tmp, count);
+	}
+#endif
+
+    if (stream->bytes_left < count)
+        PB_RETURN_ERROR(stream, "end-of-stream");
+    
+#ifndef PB_BUFFER_ONLY
+    if (!stream->callback(stream, buf, count))
+        PB_RETURN_ERROR(stream, "io error");
+#else
+    if (!buf_read(stream, buf, count))
+        return false;
+#endif
+    
+    stream->bytes_left -= count;
+    return true;
+}
+
+/* Read a single byte from input stream. buf may not be NULL.
+ * This is an optimization for the varint decoding. */
+static bool checkreturn pb_readbyte(pb_istream_t *stream, pb_byte_t *buf)
+{
+    if (stream->bytes_left == 0)
+        PB_RETURN_ERROR(stream, "end-of-stream");
+
+#ifndef PB_BUFFER_ONLY
+    if (!stream->callback(stream, buf, 1))
+        PB_RETURN_ERROR(stream, "io error");
+#else
+    *buf = *(const pb_byte_t*)stream->state;
+    stream->state = (pb_byte_t*)stream->state + 1;
+#endif
+
+    stream->bytes_left--;
+    
+    return true;    
+}
+
+pb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize)
+{
+    pb_istream_t stream;
+    /* Cast away the const from buf without a compiler error.  We are
+     * careful to use it only in a const manner in the callbacks.
+     */
+    union {
+        void *state;
+        const void *c_state;
+    } state;
+#ifdef PB_BUFFER_ONLY
+    stream.callback = NULL;
+#else
+    stream.callback = &buf_read;
+#endif
+    state.c_state = buf;
+    stream.state = state.state;
+    stream.bytes_left = bufsize;
+#ifndef PB_NO_ERRMSG
+    stream.errmsg = NULL;
+#endif
+    return stream;
+}
+
+/********************
+ * Helper functions *
+ ********************/
+
+static bool checkreturn pb_decode_varint32(pb_istream_t *stream, uint32_t *dest)
+{
+    pb_byte_t byte;
+    uint32_t result;
+    
+    if (!pb_readbyte(stream, &byte))
+        return false;
+    
+    if ((byte & 0x80) == 0)
+    {
+        /* Quick case, 1 byte value */
+        result = byte;
+    }
+    else
+    {
+        /* Multibyte case */
+        uint_fast8_t bitpos = 7;
+        result = byte & 0x7F;
+        
+        do
+        {
+            if (bitpos >= 32)
+                PB_RETURN_ERROR(stream, "varint overflow");
+            
+            if (!pb_readbyte(stream, &byte))
+                return false;
+            
+            result |= (uint32_t)(byte & 0x7F) << bitpos;
+            bitpos = (uint_fast8_t)(bitpos + 7);
+        } while (byte & 0x80);
+   }
+   
+   *dest = result;
+   return true;
+}
+
+bool checkreturn pb_decode_varint(pb_istream_t *stream, uint64_t *dest)
+{
+    pb_byte_t byte;
+    uint_fast8_t bitpos = 0;
+    uint64_t result = 0;
+    
+    do
+    {
+        if (bitpos >= 64)
+            PB_RETURN_ERROR(stream, "varint overflow");
+        
+        if (!pb_readbyte(stream, &byte))
+            return false;
+
+        result |= (uint64_t)(byte & 0x7F) << bitpos;
+        bitpos = (uint_fast8_t)(bitpos + 7);
+    } while (byte & 0x80);
+    
+    *dest = result;
+    return true;
+}
+
+bool checkreturn pb_skip_varint(pb_istream_t *stream)
+{
+    pb_byte_t byte;
+    do
+    {
+        if (!pb_read(stream, &byte, 1))
+            return false;
+    } while (byte & 0x80);
+    return true;
+}
+
+bool checkreturn pb_skip_string(pb_istream_t *stream)
+{
+    uint32_t length;
+    if (!pb_decode_varint32(stream, &length))
+        return false;
+    
+    return pb_read(stream, NULL, length);
+}
+
+bool checkreturn pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof)
+{
+    uint32_t temp;
+    *eof = false;
+    *wire_type = (pb_wire_type_t) 0;
+    *tag = 0;
+    
+    if (!pb_decode_varint32(stream, &temp))
+    {
+        if (stream->bytes_left == 0)
+            *eof = true;
+
+        return false;
+    }
+    
+    if (temp == 0)
+    {
+        *eof = true; /* Special feature: allow 0-terminated messages. */
+        return false;
+    }
+    
+    *tag = temp >> 3;
+    *wire_type = (pb_wire_type_t)(temp & 7);
+    return true;
+}
+
+bool checkreturn pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type)
+{
+    switch (wire_type)
+    {
+        case PB_WT_VARINT: return pb_skip_varint(stream);
+        case PB_WT_64BIT: return pb_read(stream, NULL, 8);
+        case PB_WT_STRING: return pb_skip_string(stream);
+        case PB_WT_32BIT: return pb_read(stream, NULL, 4);
+        default: PB_RETURN_ERROR(stream, "invalid wire_type");
+    }
+}
+
+/* Read a raw value to buffer, for the purpose of passing it to callback as
+ * a substream. Size is maximum size on call, and actual size on return.
+ */
+static bool checkreturn read_raw_value(pb_istream_t *stream, pb_wire_type_t wire_type, pb_byte_t *buf, size_t *size)
+{
+    size_t max_size = *size;
+    switch (wire_type)
+    {
+        case PB_WT_VARINT:
+            *size = 0;
+            do
+            {
+                (*size)++;
+                if (*size > max_size) return false;
+                if (!pb_read(stream, buf, 1)) return false;
+            } while (*buf++ & 0x80);
+            return true;
+            
+        case PB_WT_64BIT:
+            *size = 8;
+            return pb_read(stream, buf, 8);
+        
+        case PB_WT_32BIT:
+            *size = 4;
+            return pb_read(stream, buf, 4);
+        
+        default: PB_RETURN_ERROR(stream, "invalid wire_type");
+    }
+}
+
+/* Decode string length from stream and return a substream with limited length.
+ * Remember to close the substream using pb_close_string_substream().
+ */
+bool checkreturn pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream)
+{
+    uint32_t size;
+    if (!pb_decode_varint32(stream, &size))
+        return false;
+    
+    *substream = *stream;
+    if (substream->bytes_left < size)
+        PB_RETURN_ERROR(stream, "parent stream too short");
+    
+    substream->bytes_left = size;
+    stream->bytes_left -= size;
+    return true;
+}
+
+void pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream)
+{
+    stream->state = substream->state;
+
+#ifndef PB_NO_ERRMSG
+    stream->errmsg = substream->errmsg;
+#endif
+}
+
+/*************************
+ * Decode a single field *
+ *************************/
+
+static bool checkreturn decode_static_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+    pb_type_t type;
+    pb_decoder_t func;
+    
+    type = iter->pos->type;
+    func = PB_DECODERS[PB_LTYPE(type)];
+
+    switch (PB_HTYPE(type))
+    {
+        case PB_HTYPE_REQUIRED:
+            return func(stream, iter->pos, iter->pData);
+            
+        case PB_HTYPE_OPTIONAL:
+            *(bool*)iter->pSize = true;
+            return func(stream, iter->pos, iter->pData);
+    
+        case PB_HTYPE_REPEATED:
+            if (wire_type == PB_WT_STRING
+                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
+            {
+                /* Packed array */
+                bool status = true;
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                pb_istream_t substream;
+                if (!pb_make_string_substream(stream, &substream))
+                    return false;
+                
+                while (substream.bytes_left > 0 && *size < iter->pos->array_size)
+                {
+                    void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);
+                    if (!func(&substream, iter->pos, pItem))
+                    {
+                        status = false;
+                        break;
+                    }
+                    (*size)++;
+                }
+                pb_close_string_substream(stream, &substream);
+                
+                if (substream.bytes_left != 0)
+                    PB_RETURN_ERROR(stream, "array overflow");
+                
+                return status;
+            }
+            else
+            {
+                /* Repeated field */
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                void *pItem = (char*)iter->pData + iter->pos->data_size * (*size);
+                if (*size >= iter->pos->array_size)
+                    PB_RETURN_ERROR(stream, "array overflow");
+                
+                (*size)++;
+                return func(stream, iter->pos, pItem);
+            }
+
+        case PB_HTYPE_ONEOF:
+            *(pb_size_t*)iter->pSize = iter->pos->tag;
+            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
+            {
+                /* We memset to zero so that any callbacks are set to NULL.
+                 * Then set any default values. */
+                memset(iter->pData, 0, iter->pos->data_size);
+                pb_message_set_to_defaults((const pb_field_t*)iter->pos->ptr, iter->pData);
+            }
+            return func(stream, iter->pos, iter->pData);
+
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+}
+
+#ifdef PB_ENABLE_MALLOC
+/* Allocate storage for the field and store the pointer at iter->pData.
+ * array_size is the number of entries to reserve in an array.
+ * Zero size is not allowed, use pb_free() for releasing.
+ */
+static bool checkreturn allocate_field(pb_istream_t *stream, void *pData, size_t data_size, size_t array_size)
+{    
+    void *ptr = *(void**)pData;
+    
+    if (data_size == 0 || array_size == 0)
+        PB_RETURN_ERROR(stream, "invalid size");
+    
+    /* Check for multiplication overflows.
+     * This code avoids the costly division if the sizes are small enough.
+     * Multiplication is safe as long as only half of bits are set
+     * in either multiplicand.
+     */
+    {
+        const size_t check_limit = (size_t)1 << (sizeof(size_t) * 4);
+        if (data_size >= check_limit || array_size >= check_limit)
+        {
+            const size_t size_max = (size_t)-1;
+            if (size_max / array_size < data_size)
+            {
+                PB_RETURN_ERROR(stream, "size too large");
+            }
+        }
+    }
+    
+    /* Allocate new or expand previous allocation */
+    /* Note: on failure the old pointer will remain in the structure,
+     * the message must be freed by caller also on error return. */
+    ptr = pb_realloc(ptr, array_size * data_size);
+    if (ptr == NULL)
+        PB_RETURN_ERROR(stream, "realloc failed");
+    
+    *(void**)pData = ptr;
+    return true;
+}
+
+/* Clear a newly allocated item in case it contains a pointer, or is a submessage. */
+static void initialize_pointer_field(void *pItem, pb_field_iter_t *iter)
+{
+    if (PB_LTYPE(iter->pos->type) == PB_LTYPE_STRING ||
+        PB_LTYPE(iter->pos->type) == PB_LTYPE_BYTES)
+    {
+        *(void**)pItem = NULL;
+    }
+    else if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)
+    {
+        pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, pItem);
+    }
+}
+#endif
+
+static bool checkreturn decode_pointer_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+#ifndef PB_ENABLE_MALLOC
+    PB_UNUSED(wire_type);
+    PB_UNUSED(iter);
+    PB_RETURN_ERROR(stream, "no malloc support");
+#else
+    pb_type_t type;
+    pb_decoder_t func;
+    
+    type = iter->pos->type;
+    func = PB_DECODERS[PB_LTYPE(type)];
+    
+    switch (PB_HTYPE(type))
+    {
+        case PB_HTYPE_REQUIRED:
+        case PB_HTYPE_OPTIONAL:
+        case PB_HTYPE_ONEOF:
+            if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE &&
+                *(void**)iter->pData != NULL)
+            {
+                /* Duplicate field, have to release the old allocation first. */
+                pb_release_single_field(iter);
+            }
+        
+            if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
+            {
+                *(pb_size_t*)iter->pSize = iter->pos->tag;
+            }
+
+            if (PB_LTYPE(type) == PB_LTYPE_STRING ||
+                PB_LTYPE(type) == PB_LTYPE_BYTES)
+            {
+                return func(stream, iter->pos, iter->pData);
+            }
+            else
+            {
+                if (!allocate_field(stream, iter->pData, iter->pos->data_size, 1))
+                    return false;
+                
+                initialize_pointer_field(*(void**)iter->pData, iter);
+                return func(stream, iter->pos, *(void**)iter->pData);
+            }
+    
+        case PB_HTYPE_REPEATED:
+            if (wire_type == PB_WT_STRING
+                && PB_LTYPE(type) <= PB_LTYPE_LAST_PACKABLE)
+            {
+                /* Packed array, multiple items come in at once. */
+                bool status = true;
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                size_t allocated_size = *size;
+                void *pItem;
+                pb_istream_t substream;
+                
+                if (!pb_make_string_substream(stream, &substream))
+                    return false;
+                
+                while (substream.bytes_left)
+                {
+                    if ((size_t)*size + 1 > allocated_size)
+                    {
+                        /* Allocate more storage. This tries to guess the
+                         * number of remaining entries. Round the division
+                         * upwards. */
+                        allocated_size += (substream.bytes_left - 1) / iter->pos->data_size + 1;
+                        
+                        if (!allocate_field(&substream, iter->pData, iter->pos->data_size, allocated_size))
+                        {
+                            status = false;
+                            break;
+                        }
+                    }
+
+                    /* Decode the array entry */
+                    pItem = *(char**)iter->pData + iter->pos->data_size * (*size);
+                    initialize_pointer_field(pItem, iter);
+                    if (!func(&substream, iter->pos, pItem))
+                    {
+                        status = false;
+                        break;
+                    }
+                    
+                    if (*size == PB_SIZE_MAX)
+                    {
+#ifndef PB_NO_ERRMSG
+                        stream->errmsg = "too many array entries";
+#endif
+                        status = false;
+                        break;
+                    }
+                    
+                    (*size)++;
+                }
+                pb_close_string_substream(stream, &substream);
+                
+                return status;
+            }
+            else
+            {
+                /* Normal repeated field, i.e. only one item at a time. */
+                pb_size_t *size = (pb_size_t*)iter->pSize;
+                void *pItem;
+                
+                if (*size == PB_SIZE_MAX)
+                    PB_RETURN_ERROR(stream, "too many array entries");
+                
+                (*size)++;
+                if (!allocate_field(stream, iter->pData, iter->pos->data_size, *size))
+                    return false;
+            
+                pItem = *(char**)iter->pData + iter->pos->data_size * (*size - 1);
+                initialize_pointer_field(pItem, iter);
+                return func(stream, iter->pos, pItem);
+            }
+
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+#endif
+}
+
+static bool checkreturn decode_callback_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+    pb_callback_t *pCallback = (pb_callback_t*)iter->pData;
+    
+#ifdef PB_OLD_CALLBACK_STYLE
+    void *arg = pCallback->arg;
+#else
+    void **arg = &(pCallback->arg);
+#endif
+    
+    if (pCallback->funcs.decode == NULL)
+        return pb_skip_field(stream, wire_type);
+    
+    if (wire_type == PB_WT_STRING)
+    {
+        pb_istream_t substream;
+        
+        if (!pb_make_string_substream(stream, &substream))
+            return false;
+        
+        do
+        {
+            if (!pCallback->funcs.decode(&substream, iter->pos, arg))
+                PB_RETURN_ERROR(stream, "callback failed");
+        } while (substream.bytes_left);
+        
+        pb_close_string_substream(stream, &substream);
+        return true;
+    }
+    else
+    {
+        /* Copy the single scalar value to stack.
+         * This is required so that we can limit the stream length,
+         * which in turn allows to use same callback for packed and
+         * not-packed fields. */
+        pb_istream_t substream;
+        pb_byte_t buffer[10];
+        size_t size = sizeof(buffer);
+        
+        if (!read_raw_value(stream, wire_type, buffer, &size))
+            return false;
+        substream = pb_istream_from_buffer(buffer, size);
+        
+        return pCallback->funcs.decode(&substream, iter->pos, arg);
+    }
+}
+
+static bool checkreturn decode_field(pb_istream_t *stream, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+#ifdef PB_ENABLE_MALLOC
+    /* When decoding an oneof field, check if there is old data that must be
+     * released first. */
+    if (PB_HTYPE(iter->pos->type) == PB_HTYPE_ONEOF)
+    {
+        if (!pb_release_union_field(stream, iter))
+            return false;
+    }
+#endif
+
+    switch (PB_ATYPE(iter->pos->type))
+    {
+        case PB_ATYPE_STATIC:
+            return decode_static_field(stream, wire_type, iter);
+        
+        case PB_ATYPE_POINTER:
+            return decode_pointer_field(stream, wire_type, iter);
+        
+        case PB_ATYPE_CALLBACK:
+            return decode_callback_field(stream, wire_type, iter);
+        
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+}
+
+static void iter_from_extension(pb_field_iter_t *iter, pb_extension_t *extension)
+{
+    /* Fake a field iterator for the extension field.
+     * It is not actually safe to advance this iterator, but decode_field
+     * will not even try to. */
+    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
+    (void)pb_field_iter_begin(iter, field, extension->dest);
+    iter->pData = extension->dest;
+    iter->pSize = &extension->found;
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+        /* For pointer extensions, the pointer is stored directly
+         * in the extension structure. This avoids having an extra
+         * indirection. */
+        iter->pData = &extension->dest;
+    }
+}
+
+/* Default handler for extension fields. Expects a pb_field_t structure
+ * in extension->type->arg. */
+static bool checkreturn default_extension_decoder(pb_istream_t *stream,
+    pb_extension_t *extension, uint32_t tag, pb_wire_type_t wire_type)
+{
+    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
+    pb_field_iter_t iter;
+    
+    if (field->tag != tag)
+        return true;
+    
+    iter_from_extension(&iter, extension);
+    extension->found = true;
+    return decode_field(stream, wire_type, &iter);
+}
+
+/* Try to decode an unknown field as an extension field. Tries each extension
+ * decoder in turn, until one of them handles the field or loop ends. */
+static bool checkreturn decode_extension(pb_istream_t *stream,
+    uint32_t tag, pb_wire_type_t wire_type, pb_field_iter_t *iter)
+{
+    pb_extension_t *extension = *(pb_extension_t* const *)iter->pData;
+    size_t pos = stream->bytes_left;
+    
+    while (extension != NULL && pos == stream->bytes_left)
+    {
+        bool status;
+        if (extension->type->decode)
+            status = extension->type->decode(stream, extension, tag, wire_type);
+        else
+            status = default_extension_decoder(stream, extension, tag, wire_type);
+
+        if (!status)
+            return false;
+        
+        extension = extension->next;
+    }
+    
+    return true;
+}
+
+/* Step through the iterator until an extension field is found or until all
+ * entries have been checked. There can be only one extension field per
+ * message. Returns false if no extension field is found. */
+static bool checkreturn find_extension_field(pb_field_iter_t *iter)
+{
+    const pb_field_t *start = iter->pos;
+    
+    do {
+        if (PB_LTYPE(iter->pos->type) == PB_LTYPE_EXTENSION)
+            return true;
+        (void)pb_field_iter_next(iter);
+    } while (iter->pos != start);
+    
+    return false;
+}
+
+/* Initialize message fields to default values, recursively */
+static void pb_field_set_to_default(pb_field_iter_t *iter)
+{
+    pb_type_t type;
+    type = iter->pos->type;
+    
+    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)
+    {
+        pb_extension_t *ext = *(pb_extension_t* const *)iter->pData;
+        while (ext != NULL)
+        {
+            pb_field_iter_t ext_iter;
+            ext->found = false;
+            iter_from_extension(&ext_iter, ext);
+            pb_field_set_to_default(&ext_iter);
+            ext = ext->next;
+        }
+    }
+    else if (PB_ATYPE(type) == PB_ATYPE_STATIC)
+    {
+        bool init_data = true;
+        if (PB_HTYPE(type) == PB_HTYPE_OPTIONAL)
+        {
+            /* Set has_field to false. Still initialize the optional field
+             * itself also. */
+            *(bool*)iter->pSize = false;
+        }
+        else if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||
+                 PB_HTYPE(type) == PB_HTYPE_ONEOF)
+        {
+            /* REPEATED: Set array count to 0, no need to initialize contents.
+               ONEOF: Set which_field to 0. */
+            *(pb_size_t*)iter->pSize = 0;
+            init_data = false;
+        }
+
+        if (init_data)
+        {
+            if (PB_LTYPE(iter->pos->type) == PB_LTYPE_SUBMESSAGE)
+            {
+                /* Initialize submessage to defaults */
+                pb_message_set_to_defaults((const pb_field_t *) iter->pos->ptr, iter->pData);
+            }
+            else if (iter->pos->ptr != NULL)
+            {
+                /* Initialize to default value */
+                memcpy(iter->pData, iter->pos->ptr, iter->pos->data_size);
+            }
+            else
+            {
+                /* Initialize to zeros */
+                memset(iter->pData, 0, iter->pos->data_size);
+            }
+        }
+    }
+    else if (PB_ATYPE(type) == PB_ATYPE_POINTER)
+    {
+        /* Initialize the pointer to NULL. */
+        *(void**)iter->pData = NULL;
+        
+        /* Initialize array count to 0. */
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED ||
+            PB_HTYPE(type) == PB_HTYPE_ONEOF)
+        {
+            *(pb_size_t*)iter->pSize = 0;
+        }
+    }
+    else if (PB_ATYPE(type) == PB_ATYPE_CALLBACK)
+    {
+        /* Don't overwrite callback */
+    }
+}
+
+static void pb_message_set_to_defaults(const pb_field_t fields[], void *dest_struct)
+{
+    pb_field_iter_t iter;
+
+    if (!pb_field_iter_begin(&iter, fields, dest_struct))
+        return; /* Empty message type */
+    
+    do
+    {
+        pb_field_set_to_default(&iter);
+    } while (pb_field_iter_next(&iter));
+}
+
+/*********************
+ * Decode all fields *
+ *********************/
+
+bool checkreturn pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    uint32_t fields_seen[(PB_MAX_REQUIRED_FIELDS + 31) / 32] = {0, 0};
+    const uint32_t allbits = ~(uint32_t)0;
+    uint32_t extension_range_start = 0;
+    pb_field_iter_t iter;
+    
+    /* Return value ignored, as empty message types will be correctly handled by
+     * pb_field_iter_find() anyway. */
+    (void)pb_field_iter_begin(&iter, fields, dest_struct);
+    
+    while (stream->bytes_left)
+    {
+        uint32_t tag;
+        pb_wire_type_t wire_type;
+        bool eof;
+        
+        if (!pb_decode_tag(stream, &wire_type, &tag, &eof))
+        {
+            if (eof)
+                break;
+            else
+                return false;
+        }
+        
+        if (!pb_field_iter_find(&iter, tag))
+        {
+            /* No match found, check if it matches an extension. */
+            if (tag >= extension_range_start)
+            {
+                if (!find_extension_field(&iter))
+                    extension_range_start = (uint32_t)-1;
+                else
+                    extension_range_start = iter.pos->tag;
+                
+                if (tag >= extension_range_start)
+                {
+                    size_t pos = stream->bytes_left;
+                
+                    if (!decode_extension(stream, tag, wire_type, &iter))
+                        return false;
+                    
+                    if (pos != stream->bytes_left)
+                    {
+                        /* The field was handled */
+                        continue;                    
+                    }
+                }
+            }
+        
+            /* No match found, skip data */
+            if (!pb_skip_field(stream, wire_type))
+                return false;
+            continue;
+        }
+        
+        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REQUIRED
+            && iter.required_field_index < PB_MAX_REQUIRED_FIELDS)
+        {
+            uint32_t tmp = ((uint32_t)1 << (iter.required_field_index & 31));
+            fields_seen[iter.required_field_index >> 5] |= tmp;
+        }
+            
+        if (!decode_field(stream, wire_type, &iter))
+            return false;
+    }
+    
+    /* Check that all required fields were present. */
+    {
+        /* First figure out the number of required fields by
+         * seeking to the end of the field array. Usually we
+         * are already close to end after decoding.
+         */
+        unsigned req_field_count;
+        pb_type_t last_type;
+        unsigned i;
+        do {
+            req_field_count = iter.required_field_index;
+            last_type = iter.pos->type;
+        } while (pb_field_iter_next(&iter));
+        
+        /* Fixup if last field was also required. */
+        if (PB_HTYPE(last_type) == PB_HTYPE_REQUIRED && iter.pos->tag != 0)
+            req_field_count++;
+        
+        if (req_field_count > 0)
+        {
+            /* Check the whole words */
+            for (i = 0; i < (req_field_count >> 5); i++)
+            {
+                if (fields_seen[i] != allbits)
+                    PB_RETURN_ERROR(stream, "missing required field");
+            }
+            
+            /* Check the remaining bits */
+            if (fields_seen[req_field_count >> 5] != (allbits >> (32 - (req_field_count & 31))))
+                PB_RETURN_ERROR(stream, "missing required field");
+        }
+    }
+    
+    return true;
+}
+
+bool checkreturn pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    bool status;
+    pb_message_set_to_defaults(fields, dest_struct);
+    status = pb_decode_noinit(stream, fields, dest_struct);
+    
+#ifdef PB_ENABLE_MALLOC
+    if (!status)
+        pb_release(fields, dest_struct);
+#endif
+    
+    return status;
+}
+
+bool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct)
+{
+    pb_istream_t substream;
+    bool status;
+    
+    if (!pb_make_string_substream(stream, &substream))
+        return false;
+    
+    status = pb_decode(&substream, fields, dest_struct);
+    pb_close_string_substream(stream, &substream);
+    return status;
+}
+
+#ifdef PB_ENABLE_MALLOC
+/* Given an oneof field, if there has already been a field inside this oneof,
+ * release it before overwriting with a different one. */
+static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *iter)
+{
+    pb_size_t old_tag = *(pb_size_t*)iter->pSize; /* Previous which_ value */
+    pb_size_t new_tag = iter->pos->tag; /* New which_ value */
+
+    if (old_tag == 0)
+        return true; /* Ok, no old data in union */
+
+    if (old_tag == new_tag)
+        return true; /* Ok, old data is of same type => merge */
+
+    /* Release old data. The find can fail if the message struct contains
+     * invalid data. */
+    if (!pb_field_iter_find(iter, old_tag))
+        PB_RETURN_ERROR(stream, "invalid union tag");
+
+    pb_release_single_field(iter);
+
+    /* Restore iterator to where it should be.
+     * This shouldn't fail unless the pb_field_t structure is corrupted. */
+    if (!pb_field_iter_find(iter, new_tag))
+        PB_RETURN_ERROR(stream, "iterator error");
+    
+    return true;
+}
+
+static void pb_release_single_field(const pb_field_iter_t *iter)
+{
+    pb_type_t type;
+    type = iter->pos->type;
+
+    if (PB_HTYPE(type) == PB_HTYPE_ONEOF)
+    {
+        if (*(pb_size_t*)iter->pSize != iter->pos->tag)
+            return; /* This is not the current field in the union */
+    }
+
+    /* Release anything contained inside an extension or submsg.
+     * This has to be done even if the submsg itself is statically
+     * allocated. */
+    if (PB_LTYPE(type) == PB_LTYPE_EXTENSION)
+    {
+        /* Release fields from all extensions in the linked list */
+        pb_extension_t *ext = *(pb_extension_t**)iter->pData;
+        while (ext != NULL)
+        {
+            pb_field_iter_t ext_iter;
+            iter_from_extension(&ext_iter, ext);
+            pb_release_single_field(&ext_iter);
+            ext = ext->next;
+        }
+    }
+    else if (PB_LTYPE(type) == PB_LTYPE_SUBMESSAGE)
+    {
+        /* Release fields in submessage or submsg array */
+        void *pItem = iter->pData;
+        pb_size_t count = 1;
+        
+        if (PB_ATYPE(type) == PB_ATYPE_POINTER)
+        {
+            pItem = *(void**)iter->pData;
+        }
+        
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
+        {
+            count = *(pb_size_t*)iter->pSize;
+
+            if (PB_ATYPE(type) == PB_ATYPE_STATIC && count > iter->pos->array_size)
+            {
+                /* Protect against corrupted _count fields */
+                count = iter->pos->array_size;
+            }
+        }
+        
+        if (pItem)
+        {
+            while (count--)
+            {
+                pb_release((const pb_field_t*)iter->pos->ptr, pItem);
+                pItem = (char*)pItem + iter->pos->data_size;
+            }
+        }
+    }
+    
+    if (PB_ATYPE(type) == PB_ATYPE_POINTER)
+    {
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED &&
+            (PB_LTYPE(type) == PB_LTYPE_STRING ||
+             PB_LTYPE(type) == PB_LTYPE_BYTES))
+        {
+            /* Release entries in repeated string or bytes array */
+            void **pItem = *(void***)iter->pData;
+            pb_size_t count = *(pb_size_t*)iter->pSize;
+            while (count--)
+            {
+                pb_free(*pItem);
+                *pItem++ = NULL;
+            }
+        }
+        
+        if (PB_HTYPE(type) == PB_HTYPE_REPEATED)
+        {
+            /* We are going to release the array, so set the size to 0 */
+            *(pb_size_t*)iter->pSize = 0;
+        }
+        
+        /* Release main item */
+        pb_free(*(void**)iter->pData);
+        *(void**)iter->pData = NULL;
+    }
+}
+
+void pb_release(const pb_field_t fields[], void *dest_struct)
+{
+    pb_field_iter_t iter;
+    
+    if (!dest_struct)
+        return; /* Ignore NULL pointers, similar to free() */
+
+    if (!pb_field_iter_begin(&iter, fields, dest_struct))
+        return; /* Empty message type */
+    
+    do
+    {
+        pb_release_single_field(&iter);
+    } while (pb_field_iter_next(&iter));
+}
+#endif
+
+/* Field decoders */
+
+bool pb_decode_svarint(pb_istream_t *stream, int64_t *dest)
+{
+    uint64_t value;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    if (value & 1)
+        *dest = (int64_t)(~(value >> 1));
+    else
+        *dest = (int64_t)(value >> 1);
+    
+    return true;
+}
+
+bool pb_decode_fixed32(pb_istream_t *stream, void *dest)
+{
+    pb_byte_t bytes[4];
+
+    if (!pb_read(stream, bytes, 4))
+        return false;
+    
+    *(uint32_t*)dest = ((uint32_t)bytes[0] << 0) |
+                       ((uint32_t)bytes[1] << 8) |
+                       ((uint32_t)bytes[2] << 16) |
+                       ((uint32_t)bytes[3] << 24);
+    return true;
+}
+
+bool pb_decode_fixed64(pb_istream_t *stream, void *dest)
+{
+    pb_byte_t bytes[8];
+
+    if (!pb_read(stream, bytes, 8))
+        return false;
+    
+    *(uint64_t*)dest = ((uint64_t)bytes[0] << 0) |
+                       ((uint64_t)bytes[1] << 8) |
+                       ((uint64_t)bytes[2] << 16) |
+                       ((uint64_t)bytes[3] << 24) |
+                       ((uint64_t)bytes[4] << 32) |
+                       ((uint64_t)bytes[5] << 40) |
+                       ((uint64_t)bytes[6] << 48) |
+                       ((uint64_t)bytes[7] << 56);
+    
+    return true;
+}
+
+static bool checkreturn pb_dec_varint(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint64_t value;
+    int64_t svalue;
+    int64_t clamped;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    /* See issue 97: Google's C++ protobuf allows negative varint values to
+     * be cast as int32_t, instead of the int64_t that should be used when
+     * encoding. Previous nanopb versions had a bug in encoding. In order to
+     * not break decoding of such messages, we cast <=32 bit fields to
+     * int32_t first to get the sign correct.
+     */
+    if (field->data_size == sizeof(int64_t))
+        svalue = (int64_t)value;
+    else
+        svalue = (int32_t)value;
+
+    /* Cast to the proper field size, while checking for overflows */
+    if (field->data_size == sizeof(int64_t))
+        clamped = *(int64_t*)dest = svalue;
+    else if (field->data_size == sizeof(int32_t))
+        clamped = *(int32_t*)dest = (int32_t)svalue;
+    else if (field->data_size == sizeof(int_least16_t))
+        clamped = *(int_least16_t*)dest = (int_least16_t)svalue;
+    else if (field->data_size == sizeof(int_least8_t))
+        clamped = *(int_least8_t*)dest = (int_least8_t)svalue;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+
+    if (clamped != svalue)
+        PB_RETURN_ERROR(stream, "integer too large");
+    
+    return true;
+}
+
+static bool checkreturn pb_dec_uvarint(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint64_t value, clamped;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    /* Cast to the proper field size, while checking for overflows */
+    if (field->data_size == sizeof(uint64_t))
+        clamped = *(uint64_t*)dest = value;
+    else if (field->data_size == sizeof(uint32_t))
+        clamped = *(uint32_t*)dest = (uint32_t)value;
+    else if (field->data_size == sizeof(uint_least16_t))
+        clamped = *(uint_least16_t*)dest = (uint_least16_t)value;
+    else if (field->data_size == sizeof(uint_least8_t))
+        clamped = *(uint_least8_t*)dest = (uint_least8_t)value;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+    
+    if (clamped != value)
+        PB_RETURN_ERROR(stream, "integer too large");
+
+    return true;
+}
+
+static bool checkreturn pb_dec_svarint(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    int64_t value, clamped;
+    if (!pb_decode_svarint(stream, &value))
+        return false;
+    
+    /* Cast to the proper field size, while checking for overflows */
+    if (field->data_size == sizeof(int64_t))
+        clamped = *(int64_t*)dest = value;
+    else if (field->data_size == sizeof(int32_t))
+        clamped = *(int32_t*)dest = (int32_t)value;
+    else if (field->data_size == sizeof(int_least16_t))
+        clamped = *(int_least16_t*)dest = (int_least16_t)value;
+    else if (field->data_size == sizeof(int_least8_t))
+        clamped = *(int_least8_t*)dest = (int_least8_t)value;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+
+    if (clamped != value)
+        PB_RETURN_ERROR(stream, "integer too large");
+    
+    return true;
+}
+
+static bool checkreturn pb_dec_fixed32(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    PB_UNUSED(field);
+    return pb_decode_fixed32(stream, dest);
+}
+
+static bool checkreturn pb_dec_fixed64(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    PB_UNUSED(field);
+    return pb_decode_fixed64(stream, dest);
+}
+
+static bool checkreturn pb_dec_bytes(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint32_t size;
+    size_t alloc_size;
+    pb_bytes_array_t *bdest;
+    
+    if (!pb_decode_varint32(stream, &size))
+        return false;
+    
+    if (size > PB_SIZE_MAX)
+        PB_RETURN_ERROR(stream, "bytes overflow");
+    
+    alloc_size = PB_BYTES_ARRAY_T_ALLOCSIZE(size);
+    if (size > alloc_size)
+        PB_RETURN_ERROR(stream, "size too large");
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+#ifndef PB_ENABLE_MALLOC
+        PB_RETURN_ERROR(stream, "no malloc support");
+#else
+        if (!allocate_field(stream, dest, alloc_size, 1))
+            return false;
+        bdest = *(pb_bytes_array_t**)dest;
+#endif
+    }
+    else
+    {
+        if (alloc_size > field->data_size)
+            PB_RETURN_ERROR(stream, "bytes overflow");
+        bdest = (pb_bytes_array_t*)dest;
+    }
+
+    bdest->size = (pb_size_t)size;
+    return pb_read(stream, bdest->bytes, size);
+}
+
+static bool checkreturn pb_dec_string(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    uint32_t size;
+    size_t alloc_size;
+    bool status;
+    if (!pb_decode_varint32(stream, &size))
+        return false;
+    
+    /* Space for null terminator */
+    alloc_size = size + 1;
+    
+    if (alloc_size < size)
+        PB_RETURN_ERROR(stream, "size too large");
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+#ifndef PB_ENABLE_MALLOC
+        PB_RETURN_ERROR(stream, "no malloc support");
+#else
+        if (!allocate_field(stream, dest, alloc_size, 1))
+            return false;
+        dest = *(void**)dest;
+#endif
+    }
+    else
+    {
+        if (alloc_size > field->data_size)
+            PB_RETURN_ERROR(stream, "string overflow");
+    }
+    
+    status = pb_read(stream, (pb_byte_t*)dest, size);
+    *((pb_byte_t*)dest + size) = 0;
+    return status;
+}
+
+static bool checkreturn pb_dec_submessage(pb_istream_t *stream, const pb_field_t *field, void *dest)
+{
+    bool status;
+    pb_istream_t substream;
+    const pb_field_t* submsg_fields = (const pb_field_t*)field->ptr;
+    
+    if (!pb_make_string_substream(stream, &substream))
+        return false;
+    
+    if (field->ptr == NULL)
+        PB_RETURN_ERROR(stream, "invalid field descriptor");
+    
+    /* New array entries need to be initialized, while required and optional
+     * submessages have already been initialized in the top-level pb_decode. */
+    if (PB_HTYPE(field->type) == PB_HTYPE_REPEATED)
+        status = pb_decode(&substream, submsg_fields, dest);
+    else
+        status = pb_decode_noinit(&substream, submsg_fields, dest);
+    
+    pb_close_string_substream(stream, &substream);
+    return status;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb_decode.h
@@ -0,0 +1,149 @@
+/* pb_decode.h: Functions to decode protocol buffers. Depends on pb_decode.c.
+ * The main function is pb_decode. You also need an input stream, and the
+ * field descriptions created by nanopb_generator.py.
+ */
+
+#ifndef PB_DECODE_H_INCLUDED
+#define PB_DECODE_H_INCLUDED
+
+#include "pb.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Structure for defining custom input streams. You will need to provide
+ * a callback function to read the bytes from your storage, which can be
+ * for example a file or a network socket.
+ * 
+ * The callback must conform to these rules:
+ *
+ * 1) Return false on IO errors. This will cause decoding to abort.
+ * 2) You can use state to store your own data (e.g. buffer pointer),
+ *    and rely on pb_read to verify that no-body reads past bytes_left.
+ * 3) Your callback may be used with substreams, in which case bytes_left
+ *    is different than from the main stream. Don't use bytes_left to compute
+ *    any pointers.
+ */
+struct pb_istream_s
+{
+#ifdef PB_BUFFER_ONLY
+    /* Callback pointer is not used in buffer-only configuration.
+     * Having an int pointer here allows binary compatibility but
+     * gives an error if someone tries to assign callback function.
+     */
+    int *callback;
+#else
+    bool (*callback)(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+#endif
+
+    void *state; /* Free field for use by callback implementation */
+    size_t bytes_left;
+    
+#ifndef PB_NO_ERRMSG
+    const char *errmsg;
+#endif
+};
+
+/***************************
+ * Main decoding functions *
+ ***************************/
+ 
+/* Decode a single protocol buffers message from input stream into a C structure.
+ * Returns true on success, false on any failure.
+ * The actual struct pointed to by dest must match the description in fields.
+ * Callback fields of the destination structure must be initialized by caller.
+ * All other fields will be initialized by this function.
+ *
+ * Example usage:
+ *    MyMessage msg = {};
+ *    uint8_t buffer[64];
+ *    pb_istream_t stream;
+ *    
+ *    // ... read some data into buffer ...
+ *
+ *    stream = pb_istream_from_buffer(buffer, count);
+ *    pb_decode(&stream, MyMessage_fields, &msg);
+ */
+bool pb_decode(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+/* Same as pb_decode, except does not initialize the destination structure
+ * to default values. This is slightly faster if you need no default values
+ * and just do memset(struct, 0, sizeof(struct)) yourself.
+ *
+ * This can also be used for 'merging' two messages, i.e. update only the
+ * fields that exist in the new message.
+ *
+ * Note: If this function returns with an error, it will not release any
+ * dynamically allocated fields. You will need to call pb_release() yourself.
+ */
+bool pb_decode_noinit(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+/* Same as pb_decode, except expects the stream to start with the message size
+ * encoded as varint. Corresponds to parseDelimitedFrom() in Google's
+ * protobuf API.
+ */
+bool pb_decode_delimited(pb_istream_t *stream, const pb_field_t fields[], void *dest_struct);
+
+#ifdef PB_ENABLE_MALLOC
+/* Release any allocated pointer fields. If you use dynamic allocation, you should
+ * call this for any successfully decoded message when you are done with it. If
+ * pb_decode() returns with an error, the message is already released.
+ */
+void pb_release(const pb_field_t fields[], void *dest_struct);
+#endif
+
+
+/**************************************
+ * Functions for manipulating streams *
+ **************************************/
+
+/* Create an input stream for reading from a memory buffer.
+ *
+ * Alternatively, you can use a custom stream that reads directly from e.g.
+ * a file or a network socket.
+ */
+pb_istream_t pb_istream_from_buffer(const pb_byte_t *buf, size_t bufsize);
+
+/* Function to read from a pb_istream_t. You can use this if you need to
+ * read some custom header data, or to read data in field callbacks.
+ */
+bool pb_read(pb_istream_t *stream, pb_byte_t *buf, size_t count);
+
+
+/************************************************
+ * Helper functions for writing field callbacks *
+ ************************************************/
+
+/* Decode the tag for the next field in the stream. Gives the wire type and
+ * field tag. At end of the message, returns false and sets eof to true. */
+bool pb_decode_tag(pb_istream_t *stream, pb_wire_type_t *wire_type, uint32_t *tag, bool *eof);
+
+/* Skip the field payload data, given the wire type. */
+bool pb_skip_field(pb_istream_t *stream, pb_wire_type_t wire_type);
+
+/* Decode an integer in the varint format. This works for bool, enum, int32,
+ * int64, uint32 and uint64 field types. */
+bool pb_decode_varint(pb_istream_t *stream, uint64_t *dest);
+
+/* Decode an integer in the zig-zagged svarint format. This works for sint32
+ * and sint64. */
+bool pb_decode_svarint(pb_istream_t *stream, int64_t *dest);
+
+/* Decode a fixed32, sfixed32 or float value. You need to pass a pointer to
+ * a 4-byte wide C variable. */
+bool pb_decode_fixed32(pb_istream_t *stream, void *dest);
+
+/* Decode a fixed64, sfixed64 or double value. You need to pass a pointer to
+ * a 8-byte wide C variable. */
+bool pb_decode_fixed64(pb_istream_t *stream, void *dest);
+
+/* Make a limited-length substream for reading a PB_WT_STRING field. */
+bool pb_make_string_substream(pb_istream_t *stream, pb_istream_t *substream);
+void pb_close_string_substream(pb_istream_t *stream, pb_istream_t *substream);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb_encode.c
@@ -0,0 +1,689 @@
+/* pb_encode.c -- encode a protobuf using minimal resources
+ *
+ * 2011 Petteri Aimonen <jpa@kapsi.fi>
+ */
+
+#include "pb.h"
+#include "pb_encode.h"
+#include "pb_common.h"
+
+/* Use the GCC warn_unused_result attribute to check that all return values
+ * are propagated correctly. On other compilers and gcc before 3.4.0 just
+ * ignore the annotation.
+ */
+#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
+    #define checkreturn
+#else
+    #define checkreturn __attribute__((warn_unused_result))
+#endif
+
+/**************************************
+ * Declarations internal to this file *
+ **************************************/
+typedef bool (*pb_encoder_t)(pb_ostream_t *stream, const pb_field_t *field, const void *src) checkreturn;
+
+static bool checkreturn buf_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
+static bool checkreturn encode_array(pb_ostream_t *stream, const pb_field_t *field, const void *pData, size_t count, pb_encoder_t func);
+static bool checkreturn encode_field(pb_ostream_t *stream, const pb_field_t *field, const void *pData);
+static bool checkreturn default_extension_encoder(pb_ostream_t *stream, const pb_extension_t *extension);
+static bool checkreturn encode_extension_field(pb_ostream_t *stream, const pb_field_t *field, const void *pData);
+static bool checkreturn pb_enc_varint(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_uvarint(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_svarint(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_fixed32(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_fixed64(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_string(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+static bool checkreturn pb_enc_submessage(pb_ostream_t *stream, const pb_field_t *field, const void *src);
+
+/* --- Function pointers to field encoders ---
+ * Order in the array must match pb_action_t LTYPE numbering.
+ */
+static const pb_encoder_t PB_ENCODERS[PB_LTYPES_COUNT] = {
+    &pb_enc_varint,
+    &pb_enc_uvarint,
+    &pb_enc_svarint,
+    &pb_enc_fixed32,
+    &pb_enc_fixed64,
+    
+    &pb_enc_bytes,
+    &pb_enc_string,
+    &pb_enc_submessage,
+    NULL /* extensions */
+};
+
+/*******************************
+ * pb_ostream_t implementation *
+ *******************************/
+
+static bool checkreturn buf_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count)
+{
+    pb_byte_t *dest = (pb_byte_t*)stream->state;
+    stream->state = dest + count;
+    
+    while (count--)
+        *dest++ = *buf++;
+    
+    return true;
+}
+
+pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize)
+{
+    pb_ostream_t stream;
+#ifdef PB_BUFFER_ONLY
+    stream.callback = (void*)1; /* Just a marker value */
+#else
+    stream.callback = &buf_write;
+#endif
+    stream.state = buf;
+    stream.max_size = bufsize;
+    stream.bytes_written = 0;
+#ifndef PB_NO_ERRMSG
+    stream.errmsg = NULL;
+#endif
+    return stream;
+}
+
+bool checkreturn pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count)
+{
+    if (stream->callback != NULL)
+    {
+        if (stream->bytes_written + count > stream->max_size)
+            PB_RETURN_ERROR(stream, "stream full");
+
+#ifdef PB_BUFFER_ONLY
+        if (!buf_write(stream, buf, count))
+            PB_RETURN_ERROR(stream, "io error");
+#else        
+        if (!stream->callback(stream, buf, count))
+            PB_RETURN_ERROR(stream, "io error");
+#endif
+    }
+    
+    stream->bytes_written += count;
+    return true;
+}
+
+/*************************
+ * Encode a single field *
+ *************************/
+
+/* Encode a static array. Handles the size calculations and possible packing. */
+static bool checkreturn encode_array(pb_ostream_t *stream, const pb_field_t *field,
+                         const void *pData, size_t count, pb_encoder_t func)
+{
+    size_t i;
+    const void *p;
+    size_t size;
+    
+    if (count == 0)
+        return true;
+
+    if (PB_ATYPE(field->type) != PB_ATYPE_POINTER && count > field->array_size)
+        PB_RETURN_ERROR(stream, "array max size exceeded");
+    
+    /* We always pack arrays if the datatype allows it. */
+    if (PB_LTYPE(field->type) <= PB_LTYPE_LAST_PACKABLE)
+    {
+        if (!pb_encode_tag(stream, PB_WT_STRING, field->tag))
+            return false;
+        
+        /* Determine the total size of packed array. */
+        if (PB_LTYPE(field->type) == PB_LTYPE_FIXED32)
+        {
+            size = 4 * count;
+        }
+        else if (PB_LTYPE(field->type) == PB_LTYPE_FIXED64)
+        {
+            size = 8 * count;
+        }
+        else
+        { 
+            pb_ostream_t sizestream = PB_OSTREAM_SIZING;
+            p = pData;
+            for (i = 0; i < count; i++)
+            {
+                if (!func(&sizestream, field, p))
+                    return false;
+                p = (const char*)p + field->data_size;
+            }
+            size = sizestream.bytes_written;
+        }
+        
+        if (!pb_encode_varint(stream, (uint64_t)size))
+            return false;
+        
+        if (stream->callback == NULL)
+            return pb_write(stream, NULL, size); /* Just sizing.. */
+        
+        /* Write the data */
+        p = pData;
+        for (i = 0; i < count; i++)
+        {
+            if (!func(stream, field, p))
+                return false;
+            p = (const char*)p + field->data_size;
+        }
+    }
+    else
+    {
+        p = pData;
+        for (i = 0; i < count; i++)
+        {
+            if (!pb_encode_tag_for_field(stream, field))
+                return false;
+
+            /* Normally the data is stored directly in the array entries, but
+             * for pointer-type string and bytes fields, the array entries are
+             * actually pointers themselves also. So we have to dereference once
+             * more to get to the actual data. */
+            if (PB_ATYPE(field->type) == PB_ATYPE_POINTER &&
+                (PB_LTYPE(field->type) == PB_LTYPE_STRING ||
+                 PB_LTYPE(field->type) == PB_LTYPE_BYTES))
+            {
+                if (!func(stream, field, *(const void* const*)p))
+                    return false;      
+            }
+            else
+            {
+                if (!func(stream, field, p))
+                    return false;
+            }
+            p = (const char*)p + field->data_size;
+        }
+    }
+    
+    return true;
+}
+
+/* Encode a field with static or pointer allocation, i.e. one whose data
+ * is available to the encoder directly. */
+static bool checkreturn encode_basic_field(pb_ostream_t *stream,
+    const pb_field_t *field, const void *pData)
+{
+    pb_encoder_t func;
+    const void *pSize;
+    bool implicit_has = true;
+    
+    func = PB_ENCODERS[PB_LTYPE(field->type)];
+    
+    if (field->size_offset)
+        pSize = (const char*)pData + field->size_offset;
+    else
+        pSize = &implicit_has;
+
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+        /* pData is a pointer to the field, which contains pointer to
+         * the data. If the 2nd pointer is NULL, it is interpreted as if
+         * the has_field was false.
+         */
+        
+        pData = *(const void* const*)pData;
+        implicit_has = (pData != NULL);
+    }
+
+    switch (PB_HTYPE(field->type))
+    {
+        case PB_HTYPE_REQUIRED:
+            if (!pData)
+                PB_RETURN_ERROR(stream, "missing required field");
+            if (!pb_encode_tag_for_field(stream, field))
+                return false;
+            if (!func(stream, field, pData))
+                return false;
+            break;
+        
+        case PB_HTYPE_OPTIONAL:
+            if (*(const bool*)pSize)
+            {
+                if (!pb_encode_tag_for_field(stream, field))
+                    return false;
+            
+                if (!func(stream, field, pData))
+                    return false;
+            }
+            break;
+        
+        case PB_HTYPE_REPEATED:
+            if (!encode_array(stream, field, pData, *(const pb_size_t*)pSize, func))
+                return false;
+            break;
+        
+        case PB_HTYPE_ONEOF:
+            if (*(const pb_size_t*)pSize == field->tag)
+            {
+                if (!pb_encode_tag_for_field(stream, field))
+                    return false;
+
+                if (!func(stream, field, pData))
+                    return false;
+            }
+            break;
+            
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+    
+    return true;
+}
+
+/* Encode a field with callback semantics. This means that a user function is
+ * called to provide and encode the actual data. */
+static bool checkreturn encode_callback_field(pb_ostream_t *stream,
+    const pb_field_t *field, const void *pData)
+{
+    const pb_callback_t *callback = (const pb_callback_t*)pData;
+    
+#ifdef PB_OLD_CALLBACK_STYLE
+    const void *arg = callback->arg;
+#else
+    void * const *arg = &(callback->arg);
+#endif    
+    
+    if (callback->funcs.encode != NULL)
+    {
+        if (!callback->funcs.encode(stream, field, arg))
+            PB_RETURN_ERROR(stream, "callback error");
+    }
+    return true;
+}
+
+/* Encode a single field of any callback or static type. */
+static bool checkreturn encode_field(pb_ostream_t *stream,
+    const pb_field_t *field, const void *pData)
+{
+    switch (PB_ATYPE(field->type))
+    {
+        case PB_ATYPE_STATIC:
+        case PB_ATYPE_POINTER:
+            return encode_basic_field(stream, field, pData);
+        
+        case PB_ATYPE_CALLBACK:
+            return encode_callback_field(stream, field, pData);
+        
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+}
+
+/* Default handler for extension fields. Expects to have a pb_field_t
+ * pointer in the extension->type->arg field. */
+static bool checkreturn default_extension_encoder(pb_ostream_t *stream,
+    const pb_extension_t *extension)
+{
+    const pb_field_t *field = (const pb_field_t*)extension->type->arg;
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+    {
+        /* For pointer extensions, the pointer is stored directly
+         * in the extension structure. This avoids having an extra
+         * indirection. */
+        return encode_field(stream, field, &extension->dest);
+    }
+    else
+    {
+        return encode_field(stream, field, extension->dest);
+    }
+}
+
+/* Walk through all the registered extensions and give them a chance
+ * to encode themselves. */
+static bool checkreturn encode_extension_field(pb_ostream_t *stream,
+    const pb_field_t *field, const void *pData)
+{
+    const pb_extension_t *extension = *(const pb_extension_t* const *)pData;
+    PB_UNUSED(field);
+    
+    while (extension)
+    {
+        bool status;
+        if (extension->type->encode)
+            status = extension->type->encode(stream, extension);
+        else
+            status = default_extension_encoder(stream, extension);
+
+        if (!status)
+            return false;
+        
+        extension = extension->next;
+    }
+    
+    return true;
+}
+
+/*********************
+ * Encode all fields *
+ *********************/
+
+static void *remove_const(const void *p)
+{
+    /* Note: this casts away const, in order to use the common field iterator
+     * logic for both encoding and decoding. */
+    union {
+        void *p1;
+        const void *p2;
+    } t;
+    t.p2 = p;
+    return t.p1;
+}
+
+bool checkreturn pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
+{
+    pb_field_iter_t iter;
+    if (!pb_field_iter_begin(&iter, fields, remove_const(src_struct)))
+        return true; /* Empty message type */
+    
+    do {
+        if (PB_LTYPE(iter.pos->type) == PB_LTYPE_EXTENSION)
+        {
+            /* Special case for the extension field placeholder */
+            if (!encode_extension_field(stream, iter.pos, iter.pData))
+                return false;
+        }
+        else
+        {
+            /* Regular field */
+            if (!encode_field(stream, iter.pos, iter.pData))
+                return false;
+        }
+    } while (pb_field_iter_next(&iter));
+    
+    return true;
+}
+
+bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
+{
+    return pb_encode_submessage(stream, fields, src_struct);
+}
+
+bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct)
+{
+    pb_ostream_t stream = PB_OSTREAM_SIZING;
+    
+    if (!pb_encode(&stream, fields, src_struct))
+        return false;
+    
+    *size = stream.bytes_written;
+    return true;
+}
+
+/********************
+ * Helper functions *
+ ********************/
+bool checkreturn pb_encode_varint(pb_ostream_t *stream, uint64_t value)
+{
+    pb_byte_t buffer[10];
+    size_t i = 0;
+    
+    if (value <= 0x7F)
+    {
+        pb_byte_t v = (pb_byte_t)value;
+        return pb_write(stream, &v, 1);
+    }
+    
+    while (value)
+    {
+        buffer[i] = (pb_byte_t)((value & 0x7F) | 0x80);
+        value >>= 7;
+        i++;
+    }
+    buffer[i-1] &= 0x7F; /* Unset top bit on last byte */
+    
+    return pb_write(stream, buffer, i);
+}
+
+bool checkreturn pb_encode_svarint(pb_ostream_t *stream, int64_t value)
+{
+    uint64_t zigzagged;
+    if (value < 0)
+        zigzagged = ~((uint64_t)value << 1);
+    else
+        zigzagged = (uint64_t)value << 1;
+    
+    return pb_encode_varint(stream, zigzagged);
+}
+
+bool checkreturn pb_encode_fixed32(pb_ostream_t *stream, const void *value)
+{
+    uint32_t val = *(const uint32_t*)value;
+    pb_byte_t bytes[4];
+    bytes[0] = (pb_byte_t)(val & 0xFF);
+    bytes[1] = (pb_byte_t)((val >> 8) & 0xFF);
+    bytes[2] = (pb_byte_t)((val >> 16) & 0xFF);
+    bytes[3] = (pb_byte_t)((val >> 24) & 0xFF);
+    return pb_write(stream, bytes, 4);
+}
+
+bool checkreturn pb_encode_fixed64(pb_ostream_t *stream, const void *value)
+{
+    uint64_t val = *(const uint64_t*)value;
+    pb_byte_t bytes[8];
+    bytes[0] = (pb_byte_t)(val & 0xFF);
+    bytes[1] = (pb_byte_t)((val >> 8) & 0xFF);
+    bytes[2] = (pb_byte_t)((val >> 16) & 0xFF);
+    bytes[3] = (pb_byte_t)((val >> 24) & 0xFF);
+    bytes[4] = (pb_byte_t)((val >> 32) & 0xFF);
+    bytes[5] = (pb_byte_t)((val >> 40) & 0xFF);
+    bytes[6] = (pb_byte_t)((val >> 48) & 0xFF);
+    bytes[7] = (pb_byte_t)((val >> 56) & 0xFF);
+    return pb_write(stream, bytes, 8);
+}
+
+bool checkreturn pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number)
+{
+    uint64_t tag = ((uint64_t)field_number << 3) | wiretype;
+    return pb_encode_varint(stream, tag);
+}
+
+bool checkreturn pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field)
+{
+    pb_wire_type_t wiretype;
+    switch (PB_LTYPE(field->type))
+    {
+        case PB_LTYPE_VARINT:
+        case PB_LTYPE_UVARINT:
+        case PB_LTYPE_SVARINT:
+            wiretype = PB_WT_VARINT;
+            break;
+        
+        case PB_LTYPE_FIXED32:
+            wiretype = PB_WT_32BIT;
+            break;
+        
+        case PB_LTYPE_FIXED64:
+            wiretype = PB_WT_64BIT;
+            break;
+        
+        case PB_LTYPE_BYTES:
+        case PB_LTYPE_STRING:
+        case PB_LTYPE_SUBMESSAGE:
+            wiretype = PB_WT_STRING;
+            break;
+        
+        default:
+            PB_RETURN_ERROR(stream, "invalid field type");
+    }
+    
+    return pb_encode_tag(stream, wiretype, field->tag);
+}
+
+bool checkreturn pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size)
+{
+    if (!pb_encode_varint(stream, (uint64_t)size))
+        return false;
+    
+    return pb_write(stream, buffer, size);
+}
+
+bool checkreturn pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct)
+{
+    /* First calculate the message size using a non-writing substream. */
+    pb_ostream_t substream = PB_OSTREAM_SIZING;
+    size_t size;
+    bool status;
+    
+    if (!pb_encode(&substream, fields, src_struct))
+    {
+#ifndef PB_NO_ERRMSG
+        stream->errmsg = substream.errmsg;
+#endif
+        return false;
+    }
+    
+    size = substream.bytes_written;
+    
+    if (!pb_encode_varint(stream, (uint64_t)size))
+        return false;
+    
+    if (stream->callback == NULL)
+        return pb_write(stream, NULL, size); /* Just sizing */
+    
+    if (stream->bytes_written + size > stream->max_size)
+        PB_RETURN_ERROR(stream, "stream full");
+        
+    /* Use a substream to verify that a callback doesn't write more than
+     * what it did the first time. */
+    substream.callback = stream->callback;
+    substream.state = stream->state;
+    substream.max_size = size;
+    substream.bytes_written = 0;
+#ifndef PB_NO_ERRMSG
+    substream.errmsg = NULL;
+#endif
+    
+    status = pb_encode(&substream, fields, src_struct);
+    
+    stream->bytes_written += substream.bytes_written;
+    stream->state = substream.state;
+#ifndef PB_NO_ERRMSG
+    stream->errmsg = substream.errmsg;
+#endif
+    
+    if (substream.bytes_written != size)
+        PB_RETURN_ERROR(stream, "submsg size changed");
+    
+    return status;
+}
+
+/* Field encoders */
+
+static bool checkreturn pb_enc_varint(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    int64_t value = 0;
+    
+    if (field->data_size == sizeof(int_least8_t))
+        value = *(const int_least8_t*)src;
+    else if (field->data_size == sizeof(int_least16_t))
+        value = *(const int_least16_t*)src;
+    else if (field->data_size == sizeof(int32_t))
+        value = *(const int32_t*)src;
+    else if (field->data_size == sizeof(int64_t))
+        value = *(const int64_t*)src;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+    
+    return pb_encode_varint(stream, (uint64_t)value);
+}
+
+static bool checkreturn pb_enc_uvarint(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    uint64_t value = 0;
+    
+    if (field->data_size == sizeof(uint_least8_t))
+        value = *(const uint_least8_t*)src;
+    else if (field->data_size == sizeof(uint_least16_t))
+        value = *(const uint_least16_t*)src;
+    else if (field->data_size == sizeof(uint32_t))
+        value = *(const uint32_t*)src;
+    else if (field->data_size == sizeof(uint64_t))
+        value = *(const uint64_t*)src;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+    
+    return pb_encode_varint(stream, value);
+}
+
+static bool checkreturn pb_enc_svarint(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    int64_t value = 0;
+    
+    if (field->data_size == sizeof(int_least8_t))
+        value = *(const int_least8_t*)src;
+    else if (field->data_size == sizeof(int_least16_t))
+        value = *(const int_least16_t*)src;
+    else if (field->data_size == sizeof(int32_t))
+        value = *(const int32_t*)src;
+    else if (field->data_size == sizeof(int64_t))
+        value = *(const int64_t*)src;
+    else
+        PB_RETURN_ERROR(stream, "invalid data_size");
+    
+    return pb_encode_svarint(stream, value);
+}
+
+static bool checkreturn pb_enc_fixed64(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    PB_UNUSED(field);
+    return pb_encode_fixed64(stream, src);
+}
+
+static bool checkreturn pb_enc_fixed32(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    PB_UNUSED(field);
+    return pb_encode_fixed32(stream, src);
+}
+
+static bool checkreturn pb_enc_bytes(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    const pb_bytes_array_t *bytes = (const pb_bytes_array_t*)src;
+    
+    if (src == NULL)
+    {
+        /* Threat null pointer as an empty bytes field */
+        return pb_encode_string(stream, NULL, 0);
+    }
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_STATIC &&
+        PB_BYTES_ARRAY_T_ALLOCSIZE(bytes->size) > field->data_size)
+    {
+        PB_RETURN_ERROR(stream, "bytes size exceeded");
+    }
+    
+    return pb_encode_string(stream, bytes->bytes, bytes->size);
+}
+
+static bool checkreturn pb_enc_string(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    size_t size = 0;
+    size_t max_size = field->data_size;
+    const char *p = (const char*)src;
+    
+    if (PB_ATYPE(field->type) == PB_ATYPE_POINTER)
+        max_size = (size_t)-1;
+
+    if (src == NULL)
+    {
+        size = 0; /* Threat null pointer as an empty string */
+    }
+    else
+    {
+        /* strnlen() is not always available, so just use a loop */
+        while (size < max_size && *p != '\0')
+        {
+            size++;
+            p++;
+        }
+    }
+
+    return pb_encode_string(stream, (const pb_byte_t*)src, size);
+}
+
+static bool checkreturn pb_enc_submessage(pb_ostream_t *stream, const pb_field_t *field, const void *src)
+{
+    if (field->ptr == NULL)
+        PB_RETURN_ERROR(stream, "invalid field descriptor");
+    
+    return pb_encode_submessage(stream, (const pb_field_t*)field->ptr, src);
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/pb_encode.h
@@ -0,0 +1,154 @@
+/* pb_encode.h: Functions to encode protocol buffers. Depends on pb_encode.c.
+ * The main function is pb_encode. You also need an output stream, and the
+ * field descriptions created by nanopb_generator.py.
+ */
+
+#ifndef PB_ENCODE_H_INCLUDED
+#define PB_ENCODE_H_INCLUDED
+
+#include "pb.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Structure for defining custom output streams. You will need to provide
+ * a callback function to write the bytes to your storage, which can be
+ * for example a file or a network socket.
+ *
+ * The callback must conform to these rules:
+ *
+ * 1) Return false on IO errors. This will cause encoding to abort.
+ * 2) You can use state to store your own data (e.g. buffer pointer).
+ * 3) pb_write will update bytes_written after your callback runs.
+ * 4) Substreams will modify max_size and bytes_written. Don't use them
+ *    to calculate any pointers.
+ */
+struct pb_ostream_s
+{
+#ifdef PB_BUFFER_ONLY
+    /* Callback pointer is not used in buffer-only configuration.
+     * Having an int pointer here allows binary compatibility but
+     * gives an error if someone tries to assign callback function.
+     * Also, NULL pointer marks a 'sizing stream' that does not
+     * write anything.
+     */
+    int *callback;
+#else
+    bool (*callback)(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
+#endif
+    void *state;          /* Free field for use by callback implementation. */
+    size_t max_size;      /* Limit number of output bytes written (or use SIZE_MAX). */
+    size_t bytes_written; /* Number of bytes written so far. */
+    
+#ifndef PB_NO_ERRMSG
+    const char *errmsg;
+#endif
+};
+
+/***************************
+ * Main encoding functions *
+ ***************************/
+
+/* Encode a single protocol buffers message from C structure into a stream.
+ * Returns true on success, false on any failure.
+ * The actual struct pointed to by src_struct must match the description in fields.
+ * All required fields in the struct are assumed to have been filled in.
+ *
+ * Example usage:
+ *    MyMessage msg = {};
+ *    uint8_t buffer[64];
+ *    pb_ostream_t stream;
+ *
+ *    msg.field1 = 42;
+ *    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+ *    pb_encode(&stream, MyMessage_fields, &msg);
+ */
+bool pb_encode(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
+
+/* Same as pb_encode, but prepends the length of the message as a varint.
+ * Corresponds to writeDelimitedTo() in Google's protobuf API.
+ */
+bool pb_encode_delimited(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
+
+/* Encode the message to get the size of the encoded data, but do not store
+ * the data. */
+bool pb_get_encoded_size(size_t *size, const pb_field_t fields[], const void *src_struct);
+
+/**************************************
+ * Functions for manipulating streams *
+ **************************************/
+
+/* Create an output stream for writing into a memory buffer.
+ * The number of bytes written can be found in stream.bytes_written after
+ * encoding the message.
+ *
+ * Alternatively, you can use a custom stream that writes directly to e.g.
+ * a file or a network socket.
+ */
+pb_ostream_t pb_ostream_from_buffer(pb_byte_t *buf, size_t bufsize);
+
+/* Pseudo-stream for measuring the size of a message without actually storing
+ * the encoded data.
+ * 
+ * Example usage:
+ *    MyMessage msg = {};
+ *    pb_ostream_t stream = PB_OSTREAM_SIZING;
+ *    pb_encode(&stream, MyMessage_fields, &msg);
+ *    printf("Message size is %d\n", stream.bytes_written);
+ */
+#ifndef PB_NO_ERRMSG
+#define PB_OSTREAM_SIZING {0,0,0,0,0}
+#else
+#define PB_OSTREAM_SIZING {0,0,0,0}
+#endif
+
+/* Function to write into a pb_ostream_t stream. You can use this if you need
+ * to append or prepend some custom headers to the message.
+ */
+bool pb_write(pb_ostream_t *stream, const pb_byte_t *buf, size_t count);
+
+
+/************************************************
+ * Helper functions for writing field callbacks *
+ ************************************************/
+
+/* Encode field header based on type and field number defined in the field
+ * structure. Call this from the callback before writing out field contents. */
+bool pb_encode_tag_for_field(pb_ostream_t *stream, const pb_field_t *field);
+
+/* Encode field header by manually specifing wire type. You need to use this
+ * if you want to write out packed arrays from a callback field. */
+bool pb_encode_tag(pb_ostream_t *stream, pb_wire_type_t wiretype, uint32_t field_number);
+
+/* Encode an integer in the varint format.
+ * This works for bool, enum, int32, int64, uint32 and uint64 field types. */
+bool pb_encode_varint(pb_ostream_t *stream, uint64_t value);
+
+/* Encode an integer in the zig-zagged svarint format.
+ * This works for sint32 and sint64. */
+bool pb_encode_svarint(pb_ostream_t *stream, int64_t value);
+
+/* Encode a string or bytes type field. For strings, pass strlen(s) as size. */
+bool pb_encode_string(pb_ostream_t *stream, const pb_byte_t *buffer, size_t size);
+
+/* Encode a fixed32, sfixed32 or float value.
+ * You need to pass a pointer to a 4-byte wide C variable. */
+bool pb_encode_fixed32(pb_ostream_t *stream, const void *value);
+
+/* Encode a fixed64, sfixed64 or double value.
+ * You need to pass a pointer to a 8-byte wide C variable. */
+bool pb_encode_fixed64(pb_ostream_t *stream, const void *value);
+
+/* Encode a submessage field.
+ * You need to pass the pb_field_t array and pointer to struct, just like
+ * with pb_encode(). This internally encodes the submessage twice, first to
+ * calculate message size and then to actually write it out.
+ */
+bool pb_encode_submessage(pb_ostream_t *stream, const pb_field_t fields[], const void *src_struct);
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/Makefile
@@ -0,0 +1,21 @@
+all:
+	scons
+
+clean:
+	scons -c
+
+coverage:
+	rm -rf build coverage
+
+	# LCOV does not like the newer gcov format
+	scons CC=gcc-4.6 CXX=gcc-4.6
+
+	# Collect the data
+	mkdir build/coverage
+	lcov --base-directory . --directory build/ --gcov-tool gcov-4.6 -c -o build/coverage/nanopb.info
+
+	# Remove the test code from results
+	lcov -r build/coverage/nanopb.info '*tests*' -o build/coverage/nanopb.info
+
+	# Generate HTML
+	genhtml -o build/coverage build/coverage/nanopb.info
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/SConstruct
@@ -0,0 +1,155 @@
+Help('''
+Type 'scons' to build and run all the available test cases.
+It will automatically detect your platform and C compiler and
+build appropriately.
+
+You can modify the behavious using following options:
+CC          Name of C compiler
+CXX         Name of C++ compiler
+CCFLAGS     Flags to pass to the C compiler
+CXXFLAGS    Flags to pass to the C++ compiler
+
+For example, for a clang build, use:
+scons CC=clang CXX=clang++
+''')
+
+import os
+env = Environment(ENV = os.environ, tools = ['default', 'nanopb'])
+
+# Allow overriding the compiler with scons CC=???
+if 'CC' in ARGUMENTS: env.Replace(CC = ARGUMENTS['CC'])
+if 'CXX' in ARGUMENTS: env.Replace(CXX = ARGUMENTS['CXX'])
+if 'CCFLAGS' in ARGUMENTS: env.Append(CCFLAGS = ARGUMENTS['CCFLAGS'])
+if 'CXXFLAGS' in ARGUMENTS: env.Append(CXXFLAGS = ARGUMENTS['CXXFLAGS'])
+
+# Add the builders defined in site_init.py
+add_nanopb_builders(env)
+
+# Path to the files shared by tests, and to the nanopb core.
+env.Append(CPPPATH = ["#../", "$COMMON"])
+
+# Path for finding nanopb.proto
+env.Append(PROTOCPATH = '#../generator')
+
+# Check the compilation environment, unless we are just cleaning up.
+if not env.GetOption('clean'):
+    def check_ccflags(context, flags, linkflags = ''):
+        '''Check if given CCFLAGS are supported'''
+        context.Message('Checking support for CCFLAGS="%s"... ' % flags)
+        oldflags = context.env['CCFLAGS']
+        oldlinkflags = context.env['CCFLAGS']
+        context.env.Append(CCFLAGS = flags)
+        context.env.Append(LINKFLAGS = linkflags)
+        result = context.TryCompile("int main() {return 0;}", '.c')
+        context.env.Replace(CCFLAGS = oldflags)
+        context.env.Replace(LINKFLAGS = oldlinkflags)
+        context.Result(result)
+        return result
+    
+    conf = Configure(env, custom_tests = {'CheckCCFLAGS': check_ccflags})
+
+    # If the platform doesn't support C99, use our own header file instead.
+    stdbool = conf.CheckCHeader('stdbool.h')
+    stdint = conf.CheckCHeader('stdint.h')
+    stddef = conf.CheckCHeader('stddef.h')
+    string = conf.CheckCHeader('string.h')
+    stdlib = conf.CheckCHeader('stdlib.h')
+    if not stdbool or not stdint or not stddef or not string:
+        conf.env.Append(CPPDEFINES = {'PB_SYSTEM_HEADER': '\\"pb_syshdr.h\\"'})
+        conf.env.Append(CPPPATH = "#../extra")
+	conf.env.Append(SYSHDR = '\\"pb_syshdr.h\\"')
+        
+        if stdbool: conf.env.Append(CPPDEFINES = {'HAVE_STDBOOL_H': 1})
+        if stdint: conf.env.Append(CPPDEFINES = {'HAVE_STDINT_H': 1})
+        if stddef: conf.env.Append(CPPDEFINES = {'HAVE_STDDEF_H': 1})
+        if string: conf.env.Append(CPPDEFINES = {'HAVE_STRING_H': 1})
+        if stdlib: conf.env.Append(CPPDEFINES = {'HAVE_STDLIB_H': 1})
+    
+    # Check if we can use pkg-config to find protobuf include path
+    status, output = conf.TryAction('pkg-config protobuf --variable=includedir > $TARGET')
+    if status:
+        conf.env.Append(PROTOCPATH = output.strip())
+    else:
+        conf.env.Append(PROTOCPATH = '/usr/include')
+    
+    # Check protoc version
+    status, output = conf.TryAction('$PROTOC --version > $TARGET')
+    if status:
+        conf.env['PROTOC_VERSION'] = output
+
+    # Check if libmudflap is available (only with GCC)
+    if 'gcc' in env['CC']:
+        if conf.CheckLib('mudflap'):
+            conf.env.Append(CCFLAGS = '-fmudflap')
+            conf.env.Append(LINKFLAGS = '-fmudflap')
+    
+    # Check if we can use extra strict warning flags (only with GCC)
+    extra = '-Wcast-qual -Wlogical-op -Wconversion'
+    extra += ' -fstrict-aliasing -Wstrict-aliasing=1'
+    extra += ' -Wmissing-prototypes -Wmissing-declarations -Wredundant-decls'
+    extra += ' -Wstack-protector '
+    if 'gcc' in env['CC']:
+        if conf.CheckCCFLAGS(extra):
+            conf.env.Append(CORECFLAGS = extra)
+    
+    # Check if we can use undefined behaviour sanitizer (only with clang)
+    extra = '-fsanitize=undefined '
+    if 'clang' in env['CC']:
+        if conf.CheckCCFLAGS(extra, linkflags = extra):
+            conf.env.Append(CORECFLAGS = extra)
+            conf.env.Append(LINKFLAGS = extra)
+    
+    # End the config stuff
+    env = conf.Finish()
+
+# Initialize the CCFLAGS according to the compiler
+if 'gcc' in env['CC']:
+    # GNU Compiler Collection
+    
+    # Debug info, warnings as errors
+    env.Append(CFLAGS = '-ansi -pedantic -g -Wall -Werror -fprofile-arcs -ftest-coverage ')
+    env.Append(CORECFLAGS = '-Wextra')
+    env.Append(LINKFLAGS = '-g --coverage')
+    
+    # We currently need uint64_t anyway, even though ANSI C90 otherwise..
+    env.Append(CFLAGS = '-Wno-long-long')
+elif 'clang' in env['CC']:
+    # CLang
+    env.Append(CFLAGS = '-ansi -g -Wall -Werror')
+    env.Append(CORECFLAGS = ' -Wextra -Wcast-qual -Wconversion')
+elif 'cl' in env['CC']:
+    # Microsoft Visual C++
+    
+    # Debug info on, warning level 2 for tests, warnings as errors
+    env.Append(CFLAGS = '/Zi /W2 /WX')
+    env.Append(LINKFLAGS = '/DEBUG')
+    
+    # More strict checks on the nanopb core
+    env.Append(CORECFLAGS = '/W4')
+elif 'tcc' in env['CC']:
+    # Tiny C Compiler
+    env.Append(CFLAGS = '-Wall -Werror -g')
+
+env.SetDefault(CORECFLAGS = '')
+
+if 'clang' in env['CXX']:
+    env.Append(CXXFLAGS = '-g -Wall -Werror -Wextra -Wno-missing-field-initializers')
+elif 'g++' in env['CXX'] or 'gcc' in env['CXX']:
+    env.Append(CXXFLAGS = '-g -Wall -Werror -Wextra -Wno-missing-field-initializers')
+elif 'cl' in env['CXX']:
+    env.Append(CXXFLAGS = '/Zi /W2 /WX')
+
+# Now include the SConscript files from all subdirectories
+import os.path
+env['VARIANT_DIR'] = 'build'
+env['BUILD'] = '#' + env['VARIANT_DIR']
+env['COMMON'] = '#' + env['VARIANT_DIR'] + '/common'
+
+# Include common/SConscript first to make sure its exports are available
+# to other SConscripts.
+SConscript("common/SConscript", exports = 'env', variant_dir = env['VARIANT_DIR'] + '/common')
+
+for subdir in Glob('*/SConscript') + Glob('regression/*/SConscript'):
+    if str(subdir).startswith("common"): continue
+    SConscript(subdir, exports = 'env', variant_dir = env['VARIANT_DIR'] + '/' + os.path.dirname(str(subdir)))
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes/SConscript
@@ -0,0 +1,35 @@
+# Build and run a test that encodes and decodes a message that contains
+# all of the Protocol Buffers data types.
+
+Import("env")
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+enc = env.Program(["encode_alltypes.c", "alltypes.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = env.Program(["decode_alltypes.c", "alltypes.pb.c", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+# Test the round-trip from nanopb encoder to nanopb decoder
+env.RunTest(enc)
+env.RunTest([dec, "encode_alltypes.output"])
+
+# Re-encode the data using protoc, and check that the results from nanopb
+# match byte-per-byte to the protoc output.
+env.Decode("encode_alltypes.output.decoded",
+           ["encode_alltypes.output", "alltypes.proto"],
+           MESSAGE='AllTypes')
+env.Encode("encode_alltypes.output.recoded",
+           ["encode_alltypes.output.decoded", "alltypes.proto"],
+           MESSAGE='AllTypes')
+env.Compare(["encode_alltypes.output", "encode_alltypes.output.recoded"])
+
+# Do the same checks with the optional fields present.
+env.RunTest("optionals.output", enc, ARGS = ['1'])
+env.RunTest("optionals.decout", [dec, "optionals.output"], ARGS = ['1'])
+env.Decode("optionals.output.decoded",
+           ["optionals.output", "alltypes.proto"],
+           MESSAGE='AllTypes')
+env.Encode("optionals.output.recoded",
+           ["optionals.output.decoded", "alltypes.proto"],
+           MESSAGE='AllTypes')
+env.Compare(["optionals.output", "optionals.output.recoded"])
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes/alltypes.options
@@ -0,0 +1,3 @@
+* max_size:16
+* max_count:5
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes/alltypes.proto
@@ -0,0 +1,123 @@
+syntax = "proto2";
+// package name placeholder
+
+message SubMessage {
+    required string substuff1 = 1 [default = "1"];
+    required int32 substuff2 = 2 [default = 2];
+    optional fixed32 substuff3 = 3 [default = 3];
+}
+
+message EmptyMessage {
+
+}
+
+enum HugeEnum {
+    Negative = -2147483647; /* protoc doesn't accept -2147483648 here */
+    Positive =  2147483647;
+}
+
+message Limits {
+    required int32      int32_min  =  1 [default = 2147483647];
+    required int32      int32_max  =  2 [default = -2147483647];
+    required uint32     uint32_min =  3 [default = 4294967295];
+    required uint32     uint32_max =  4 [default = 0];
+    required int64      int64_min  =  5 [default = 9223372036854775807];
+    required int64      int64_max  =  6 [default = -9223372036854775807];
+    required uint64     uint64_min =  7 [default = 18446744073709551615];
+    required uint64     uint64_max =  8 [default = 0];
+    required HugeEnum   enum_min   =  9 [default = Positive];
+    required HugeEnum   enum_max   = 10 [default = Negative];
+}
+
+enum MyEnum {
+    Zero = 0;
+    First = 1;
+    Second = 2;
+    Truth = 42;
+}
+
+message AllTypes {
+    required int32      req_int32   = 1;
+    required int64      req_int64   = 2;
+    required uint32     req_uint32  = 3;
+    required uint64     req_uint64  = 4;
+    required sint32     req_sint32  = 5;
+    required sint64     req_sint64  = 6;
+    required bool       req_bool    = 7;
+    
+    required fixed32    req_fixed32 = 8;
+    required sfixed32   req_sfixed32= 9;
+    required float      req_float   = 10;
+    
+    required fixed64    req_fixed64 = 11;
+    required sfixed64   req_sfixed64= 12;
+    required double     req_double  = 13;
+    
+    required string     req_string  = 14;
+    required bytes      req_bytes   = 15;
+    required SubMessage req_submsg  = 16;
+    required MyEnum     req_enum    = 17;
+    required EmptyMessage req_emptymsg = 18;
+    
+    
+    repeated int32      rep_int32   = 21 [packed = true];
+    repeated int64      rep_int64   = 22 [packed = true];
+    repeated uint32     rep_uint32  = 23 [packed = true];
+    repeated uint64     rep_uint64  = 24 [packed = true];
+    repeated sint32     rep_sint32  = 25 [packed = true];
+    repeated sint64     rep_sint64  = 26 [packed = true];
+    repeated bool       rep_bool    = 27 [packed = true];
+    
+    repeated fixed32    rep_fixed32 = 28 [packed = true];
+    repeated sfixed32   rep_sfixed32= 29 [packed = true];
+    repeated float      rep_float   = 30 [packed = true];
+    
+    repeated fixed64    rep_fixed64 = 31 [packed = true];
+    repeated sfixed64   rep_sfixed64= 32 [packed = true];
+    repeated double     rep_double  = 33 [packed = true];
+    
+    repeated string     rep_string  = 34;
+    repeated bytes      rep_bytes   = 35;
+    repeated SubMessage rep_submsg  = 36;
+    repeated MyEnum     rep_enum    = 37 [packed = true];
+    repeated EmptyMessage rep_emptymsg = 38;
+    
+    optional int32      opt_int32   = 41 [default = 4041];
+    optional int64      opt_int64   = 42 [default = 4042];
+    optional uint32     opt_uint32  = 43 [default = 4043];
+    optional uint64     opt_uint64  = 44 [default = 4044];
+    optional sint32     opt_sint32  = 45 [default = 4045];
+    optional sint64     opt_sint64  = 46 [default = 4046];
+    optional bool       opt_bool    = 47 [default = false];
+    
+    optional fixed32    opt_fixed32 = 48 [default = 4048];
+    optional sfixed32   opt_sfixed32= 49 [default = 4049];
+    optional float      opt_float   = 50 [default = 4050];
+    
+    optional fixed64    opt_fixed64 = 51 [default = 4051];
+    optional sfixed64   opt_sfixed64= 52 [default = 4052];
+    optional double     opt_double  = 53 [default = 4053];
+    
+    optional string     opt_string  = 54 [default = "4054"];
+    optional bytes      opt_bytes   = 55 [default = "4055"];
+    optional SubMessage opt_submsg  = 56;
+    optional MyEnum     opt_enum    = 57 [default = Second];
+    optional EmptyMessage opt_emptymsg = 58;
+
+    oneof oneof
+    {
+        SubMessage oneof_msg1 = 59;
+        EmptyMessage oneof_msg2 = 60;
+    }
+    
+    // Check that extreme integer values are handled correctly
+    required Limits     req_limits = 98;
+
+    // Just to make sure that the size of the fields has been calculated
+    // properly, i.e. otherwise a bug in last field might not be detected.
+    required int32      end = 99;
+
+
+    extensions 200 to 255;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes/decode_alltypes.c
@@ -0,0 +1,221 @@
+/* Tests the decoding of all types.
+ * This is the counterpart of test_encode3.
+ * Run e.g. ./test_encode3 | ./test_decode3
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pb_decode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+#define TEST(x) if (!(x)) { \
+    printf("Test " #x " failed.\n"); \
+    return false; \
+    }
+
+/* This function is called once from main(), it handles
+   the decoding and checks the fields. */
+bool check_alltypes(pb_istream_t *stream, int mode)
+{
+    /* Uses _init_default to just make sure that it works. */
+    AllTypes alltypes = AllTypes_init_default;
+    
+    /* Fill with garbage to better detect initialization errors */
+    memset(&alltypes, 0xAA, sizeof(alltypes));
+    alltypes.extensions = 0;
+    
+    if (!pb_decode(stream, AllTypes_fields, &alltypes))
+        return false;
+    
+    TEST(alltypes.req_int32         == -1001);
+    TEST(alltypes.req_int64         == -1002);
+    TEST(alltypes.req_uint32        == 1003);
+    TEST(alltypes.req_uint64        == 1004);
+    TEST(alltypes.req_sint32        == -1005);
+    TEST(alltypes.req_sint64        == -1006);
+    TEST(alltypes.req_bool          == true);
+    
+    TEST(alltypes.req_fixed32       == 1008);
+    TEST(alltypes.req_sfixed32      == -1009);
+    TEST(alltypes.req_float         == 1010.0f);
+    
+    TEST(alltypes.req_fixed64       == 1011);
+    TEST(alltypes.req_sfixed64      == -1012);
+    TEST(alltypes.req_double        == 1013.0f);
+    
+    TEST(strcmp(alltypes.req_string, "1014") == 0);
+    TEST(alltypes.req_bytes.size == 4);
+    TEST(memcmp(alltypes.req_bytes.bytes, "1015", 4) == 0);
+    TEST(strcmp(alltypes.req_submsg.substuff1, "1016") == 0);
+    TEST(alltypes.req_submsg.substuff2 == 1016);
+    TEST(alltypes.req_submsg.substuff3 == 3);
+    TEST(alltypes.req_enum == MyEnum_Truth);
+    
+    TEST(alltypes.rep_int32_count == 5 && alltypes.rep_int32[4] == -2001 && alltypes.rep_int32[0] == 0);
+    TEST(alltypes.rep_int64_count == 5 && alltypes.rep_int64[4] == -2002 && alltypes.rep_int64[0] == 0);
+    TEST(alltypes.rep_uint32_count == 5 && alltypes.rep_uint32[4] == 2003 && alltypes.rep_uint32[0] == 0);
+    TEST(alltypes.rep_uint64_count == 5 && alltypes.rep_uint64[4] == 2004 && alltypes.rep_uint64[0] == 0);
+    TEST(alltypes.rep_sint32_count == 5 && alltypes.rep_sint32[4] == -2005 && alltypes.rep_sint32[0] == 0);
+    TEST(alltypes.rep_sint64_count == 5 && alltypes.rep_sint64[4] == -2006 && alltypes.rep_sint64[0] == 0);
+    TEST(alltypes.rep_bool_count == 5 && alltypes.rep_bool[4] == true && alltypes.rep_bool[0] == false);
+    
+    TEST(alltypes.rep_fixed32_count == 5 && alltypes.rep_fixed32[4] == 2008 && alltypes.rep_fixed32[0] == 0);
+    TEST(alltypes.rep_sfixed32_count == 5 && alltypes.rep_sfixed32[4] == -2009 && alltypes.rep_sfixed32[0] == 0);
+    TEST(alltypes.rep_float_count == 5 && alltypes.rep_float[4] == 2010.0f && alltypes.rep_float[0] == 0.0f);
+    
+    TEST(alltypes.rep_fixed64_count == 5 && alltypes.rep_fixed64[4] == 2011 && alltypes.rep_fixed64[0] == 0);
+    TEST(alltypes.rep_sfixed64_count == 5 && alltypes.rep_sfixed64[4] == -2012 && alltypes.rep_sfixed64[0] == 0);
+    TEST(alltypes.rep_double_count == 5 && alltypes.rep_double[4] == 2013.0 && alltypes.rep_double[0] == 0.0);
+    
+    TEST(alltypes.rep_string_count == 5 && strcmp(alltypes.rep_string[4], "2014") == 0 && alltypes.rep_string[0][0] == '\0');
+    TEST(alltypes.rep_bytes_count == 5 && alltypes.rep_bytes[4].size == 4 && alltypes.rep_bytes[0].size == 0);
+    TEST(memcmp(alltypes.rep_bytes[4].bytes, "2015", 4) == 0);
+
+    TEST(alltypes.rep_submsg_count == 5);
+    TEST(strcmp(alltypes.rep_submsg[4].substuff1, "2016") == 0 && alltypes.rep_submsg[0].substuff1[0] == '\0');
+    TEST(alltypes.rep_submsg[4].substuff2 == 2016 && alltypes.rep_submsg[0].substuff2 == 0);
+    TEST(alltypes.rep_submsg[4].substuff3 == 2016 && alltypes.rep_submsg[0].substuff3 == 3);
+    
+    TEST(alltypes.rep_enum_count == 5 && alltypes.rep_enum[4] == MyEnum_Truth && alltypes.rep_enum[0] == MyEnum_Zero);
+    TEST(alltypes.rep_emptymsg_count == 5);
+    
+    if (mode == 0)
+    {
+        /* Expect default values */
+        TEST(alltypes.has_opt_int32     == false);
+        TEST(alltypes.opt_int32         == 4041);
+        TEST(alltypes.has_opt_int64     == false);
+        TEST(alltypes.opt_int64         == 4042);
+        TEST(alltypes.has_opt_uint32    == false);
+        TEST(alltypes.opt_uint32        == 4043);
+        TEST(alltypes.has_opt_uint64    == false);
+        TEST(alltypes.opt_uint64        == 4044);
+        TEST(alltypes.has_opt_sint32    == false);
+        TEST(alltypes.opt_sint32        == 4045);
+        TEST(alltypes.has_opt_sint64    == false);
+        TEST(alltypes.opt_sint64        == 4046);
+        TEST(alltypes.has_opt_bool      == false);
+        TEST(alltypes.opt_bool          == false);
+        
+        TEST(alltypes.has_opt_fixed32   == false);
+        TEST(alltypes.opt_fixed32       == 4048);
+        TEST(alltypes.has_opt_sfixed32  == false);
+        TEST(alltypes.opt_sfixed32      == 4049);
+        TEST(alltypes.has_opt_float     == false);
+        TEST(alltypes.opt_float         == 4050.0f);
+        
+        TEST(alltypes.has_opt_fixed64   == false);
+        TEST(alltypes.opt_fixed64       == 4051);
+        TEST(alltypes.has_opt_sfixed64  == false);
+        TEST(alltypes.opt_sfixed64      == 4052);
+        TEST(alltypes.has_opt_double    == false);
+        TEST(alltypes.opt_double        == 4053.0);
+        
+        TEST(alltypes.has_opt_string    == false);
+        TEST(strcmp(alltypes.opt_string, "4054") == 0);
+        TEST(alltypes.has_opt_bytes     == false);
+        TEST(alltypes.opt_bytes.size == 4);
+        TEST(memcmp(alltypes.opt_bytes.bytes, "4055", 4) == 0);
+        TEST(alltypes.has_opt_submsg    == false);
+        TEST(strcmp(alltypes.opt_submsg.substuff1, "1") == 0);
+        TEST(alltypes.opt_submsg.substuff2 == 2);
+        TEST(alltypes.opt_submsg.substuff3 == 3);
+        TEST(alltypes.has_opt_enum     == false);
+        TEST(alltypes.opt_enum == MyEnum_Second);
+        TEST(alltypes.has_opt_emptymsg == false);
+
+        TEST(alltypes.which_oneof == 0);
+    }
+    else
+    {
+        /* Expect filled-in values */
+        TEST(alltypes.has_opt_int32     == true);
+        TEST(alltypes.opt_int32         == 3041);
+        TEST(alltypes.has_opt_int64     == true);
+        TEST(alltypes.opt_int64         == 3042);
+        TEST(alltypes.has_opt_uint32    == true);
+        TEST(alltypes.opt_uint32        == 3043);
+        TEST(alltypes.has_opt_uint64    == true);
+        TEST(alltypes.opt_uint64        == 3044);
+        TEST(alltypes.has_opt_sint32    == true);
+        TEST(alltypes.opt_sint32        == 3045);
+        TEST(alltypes.has_opt_sint64    == true);
+        TEST(alltypes.opt_sint64        == 3046);
+        TEST(alltypes.has_opt_bool      == true);
+        TEST(alltypes.opt_bool          == true);
+        
+        TEST(alltypes.has_opt_fixed32   == true);
+        TEST(alltypes.opt_fixed32       == 3048);
+        TEST(alltypes.has_opt_sfixed32  == true);
+        TEST(alltypes.opt_sfixed32      == 3049);
+        TEST(alltypes.has_opt_float     == true);
+        TEST(alltypes.opt_float         == 3050.0f);
+        
+        TEST(alltypes.has_opt_fixed64   == true);
+        TEST(alltypes.opt_fixed64       == 3051);
+        TEST(alltypes.has_opt_sfixed64  == true);
+        TEST(alltypes.opt_sfixed64      == 3052);
+        TEST(alltypes.has_opt_double    == true);
+        TEST(alltypes.opt_double        == 3053.0);
+        
+        TEST(alltypes.has_opt_string    == true);
+        TEST(strcmp(alltypes.opt_string, "3054") == 0);
+        TEST(alltypes.has_opt_bytes     == true);
+        TEST(alltypes.opt_bytes.size == 4);
+        TEST(memcmp(alltypes.opt_bytes.bytes, "3055", 4) == 0);
+        TEST(alltypes.has_opt_submsg    == true);
+        TEST(strcmp(alltypes.opt_submsg.substuff1, "3056") == 0);
+        TEST(alltypes.opt_submsg.substuff2 == 3056);
+        TEST(alltypes.opt_submsg.substuff3 == 3);
+        TEST(alltypes.has_opt_enum      == true);
+        TEST(alltypes.opt_enum == MyEnum_Truth);
+        TEST(alltypes.has_opt_emptymsg  == true);
+
+        TEST(alltypes.which_oneof == AllTypes_oneof_msg1_tag);
+        TEST(strcmp(alltypes.oneof.oneof_msg1.substuff1, "4059") == 0);
+        TEST(alltypes.oneof.oneof_msg1.substuff2 == 4059);
+    }
+    
+    TEST(alltypes.req_limits.int32_min  == INT32_MIN);
+    TEST(alltypes.req_limits.int32_max  == INT32_MAX);
+    TEST(alltypes.req_limits.uint32_min == 0);
+    TEST(alltypes.req_limits.uint32_max == UINT32_MAX);
+    TEST(alltypes.req_limits.int64_min  == INT64_MIN);
+    TEST(alltypes.req_limits.int64_max  == INT64_MAX);
+    TEST(alltypes.req_limits.uint64_min == 0);
+    TEST(alltypes.req_limits.uint64_max == UINT64_MAX);
+    TEST(alltypes.req_limits.enum_min   == HugeEnum_Negative);
+    TEST(alltypes.req_limits.enum_max   == HugeEnum_Positive);
+    
+    TEST(alltypes.end == 1099);
+    
+    return true;
+}
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[1024];
+    size_t count;
+    pb_istream_t stream;
+
+    /* Whether to expect the optional values or the default values. */
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Read the data into buffer */
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+    
+    /* Construct a pb_istream_t for reading from the buffer */
+    stream = pb_istream_from_buffer(buffer, count);
+    
+    /* Decode and print out the stuff */
+    if (!check_alltypes(&stream, mode))
+    {
+        printf("Parsing failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    } else {
+        return 0;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes/encode_alltypes.c
@@ -0,0 +1,149 @@
+/* Attempts to test all the datatypes supported by ProtoBuf.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+int main(int argc, char **argv)
+{
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Initialize the structure with constants */
+    AllTypes alltypes = AllTypes_init_zero;
+    
+    alltypes.req_int32         = -1001;
+    alltypes.req_int64         = -1002;
+    alltypes.req_uint32        = 1003;
+    alltypes.req_uint64        = 1004;
+    alltypes.req_sint32        = -1005;
+    alltypes.req_sint64        = -1006;
+    alltypes.req_bool          = true;
+    
+    alltypes.req_fixed32       = 1008;
+    alltypes.req_sfixed32      = -1009;
+    alltypes.req_float         = 1010.0f;
+    
+    alltypes.req_fixed64       = 1011;
+    alltypes.req_sfixed64      = -1012;
+    alltypes.req_double        = 1013.0;
+    
+    strcpy(alltypes.req_string, "1014");
+    alltypes.req_bytes.size = 4;
+    memcpy(alltypes.req_bytes.bytes, "1015", 4);
+    strcpy(alltypes.req_submsg.substuff1, "1016");
+    alltypes.req_submsg.substuff2 = 1016;
+    alltypes.req_enum = MyEnum_Truth;
+    
+    alltypes.rep_int32_count = 5; alltypes.rep_int32[4] = -2001;
+    alltypes.rep_int64_count = 5; alltypes.rep_int64[4] = -2002;
+    alltypes.rep_uint32_count = 5; alltypes.rep_uint32[4] = 2003;
+    alltypes.rep_uint64_count = 5; alltypes.rep_uint64[4] = 2004;
+    alltypes.rep_sint32_count = 5; alltypes.rep_sint32[4] = -2005;
+    alltypes.rep_sint64_count = 5; alltypes.rep_sint64[4] = -2006;
+    alltypes.rep_bool_count = 5; alltypes.rep_bool[4] = true;
+    
+    alltypes.rep_fixed32_count = 5; alltypes.rep_fixed32[4] = 2008;
+    alltypes.rep_sfixed32_count = 5; alltypes.rep_sfixed32[4] = -2009;
+    alltypes.rep_float_count = 5; alltypes.rep_float[4] = 2010.0f;
+    
+    alltypes.rep_fixed64_count = 5; alltypes.rep_fixed64[4] = 2011;
+    alltypes.rep_sfixed64_count = 5; alltypes.rep_sfixed64[4] = -2012;
+    alltypes.rep_double_count = 5; alltypes.rep_double[4] = 2013.0;
+    
+    alltypes.rep_string_count = 5; strcpy(alltypes.rep_string[4], "2014");
+    alltypes.rep_bytes_count = 5; alltypes.rep_bytes[4].size = 4;
+    memcpy(alltypes.rep_bytes[4].bytes, "2015", 4);
+
+    alltypes.rep_submsg_count = 5;
+    strcpy(alltypes.rep_submsg[4].substuff1, "2016");
+    alltypes.rep_submsg[4].substuff2 = 2016;
+    alltypes.rep_submsg[4].has_substuff3 = true;
+    alltypes.rep_submsg[4].substuff3 = 2016;
+    
+    alltypes.rep_enum_count = 5; alltypes.rep_enum[4] = MyEnum_Truth;
+    alltypes.rep_emptymsg_count = 5;
+    
+    alltypes.req_limits.int32_min  = INT32_MIN;
+    alltypes.req_limits.int32_max  = INT32_MAX;
+    alltypes.req_limits.uint32_min = 0;
+    alltypes.req_limits.uint32_max = UINT32_MAX;
+    alltypes.req_limits.int64_min  = INT64_MIN;
+    alltypes.req_limits.int64_max  = INT64_MAX;
+    alltypes.req_limits.uint64_min = 0;
+    alltypes.req_limits.uint64_max = UINT64_MAX;
+    alltypes.req_limits.enum_min   = HugeEnum_Negative;
+    alltypes.req_limits.enum_max   = HugeEnum_Positive;
+    
+    if (mode != 0)
+    {
+        /* Fill in values for optional fields */
+        alltypes.has_opt_int32 = true;
+        alltypes.opt_int32         = 3041;
+        alltypes.has_opt_int64 = true;
+        alltypes.opt_int64         = 3042;
+        alltypes.has_opt_uint32 = true;
+        alltypes.opt_uint32        = 3043;
+        alltypes.has_opt_uint64 = true;
+        alltypes.opt_uint64        = 3044;
+        alltypes.has_opt_sint32 = true;
+        alltypes.opt_sint32        = 3045;
+        alltypes.has_opt_sint64 = true;
+        alltypes.opt_sint64        = 3046;
+        alltypes.has_opt_bool = true;
+        alltypes.opt_bool          = true;
+        
+        alltypes.has_opt_fixed32 = true;
+        alltypes.opt_fixed32       = 3048;
+        alltypes.has_opt_sfixed32 = true;
+        alltypes.opt_sfixed32      = 3049;
+        alltypes.has_opt_float = true;
+        alltypes.opt_float         = 3050.0f;
+        
+        alltypes.has_opt_fixed64 = true;
+        alltypes.opt_fixed64       = 3051;
+        alltypes.has_opt_sfixed64 = true;
+        alltypes.opt_sfixed64      = 3052;
+        alltypes.has_opt_double = true;
+        alltypes.opt_double        = 3053.0;
+        
+        alltypes.has_opt_string = true;
+        strcpy(alltypes.opt_string, "3054");
+        alltypes.has_opt_bytes = true;
+        alltypes.opt_bytes.size = 4;
+        memcpy(alltypes.opt_bytes.bytes, "3055", 4);
+        alltypes.has_opt_submsg = true;
+        strcpy(alltypes.opt_submsg.substuff1, "3056");
+        alltypes.opt_submsg.substuff2 = 3056;
+        alltypes.has_opt_enum = true;
+        alltypes.opt_enum = MyEnum_Truth;
+        alltypes.has_opt_emptymsg = true;
+
+        alltypes.which_oneof = AllTypes_oneof_msg1_tag;
+        strcpy(alltypes.oneof.oneof_msg1.substuff1, "4059");
+        alltypes.oneof.oneof_msg1.substuff2 = 4059;
+    }
+    
+    alltypes.end = 1099;
+    
+    {
+        uint8_t buffer[AllTypes_size];
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        /* Now encode it and check if we succeeded. */
+        if (pb_encode(&stream, AllTypes_fields, &alltypes))
+        {
+            SET_BINARY_MODE(stdout);
+            fwrite(buffer, 1, stream.bytes_written, stdout);
+            return 0; /* Success */
+        }
+        else
+        {
+            fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1; /* Failure */
+        }
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_callback/SConscript
@@ -0,0 +1,23 @@
+# Test the AllTypes encoding & decoding using callbacks for all fields.
+
+Import("env")
+
+c = Copy("$TARGET", "$SOURCE")
+env.Command("alltypes.proto", "#alltypes/alltypes.proto", c)
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+enc = env.Program(["encode_alltypes_callback.c", "alltypes.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = env.Program(["decode_alltypes_callback.c", "alltypes.pb.c", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+refdec = "$BUILD/alltypes/decode_alltypes$PROGSUFFIX"
+
+# Encode and compare results
+env.RunTest(enc)
+env.RunTest("decode_alltypes.output", [refdec, "encode_alltypes_callback.output"])
+env.RunTest("decode_alltypes_callback.output", [dec, "encode_alltypes_callback.output"])
+
+# Do the same thing with the optional fields present
+env.RunTest("optionals.output", enc, ARGS = ['1'])
+env.RunTest("optionals.refdecout", [refdec, "optionals.output"], ARGS = ['1'])
+env.RunTest("optionals.decout", [dec, "optionals.output"], ARGS = ['1'])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_callback/alltypes.options
@@ -0,0 +1,4 @@
+# Generate all fields as callbacks.
+AllTypes.*              type:FT_CALLBACK
+SubMessage.substuff1    max_size:16
+AllTypes.oneof          no_unions:true
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_callback/decode_alltypes_callback.c
@@ -0,0 +1,429 @@
+/* Attempts to test all the datatypes supported by ProtoBuf when used as callback fields.
+ * Note that normally there would be no reason to use callback fields for this,
+ * because each encoder defined here only gives a single field.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pb_decode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+#define TEST(x) if (!(x)) { \
+    printf("Test " #x " failed (in field %d).\n", field->tag); \
+    return false; \
+    }
+
+static bool read_varint(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint64_t value;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    TEST((int64_t)value == (long)*arg);
+    return true;
+}
+
+static bool read_svarint(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    int64_t value;
+    if (!pb_decode_svarint(stream, &value))
+        return false;
+    
+    TEST(value == (long)*arg);
+    return true;
+}
+
+static bool read_fixed32(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint32_t value;
+    if (!pb_decode_fixed32(stream, &value))
+        return false;
+    
+    TEST(value == *(uint32_t*)*arg);
+    return true;
+}
+
+static bool read_fixed64(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint64_t value;
+    if (!pb_decode_fixed64(stream, &value))
+        return false;
+    
+    TEST(value == *(uint64_t*)*arg);
+    return true;
+}
+
+static bool read_string(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint8_t buf[16] = {0};
+    size_t len = stream->bytes_left;
+    
+    if (len > sizeof(buf) - 1 || !pb_read(stream, buf, len))
+        return false;
+    
+    TEST(strcmp((char*)buf, *arg) == 0);
+    return true;
+}
+
+static bool read_submsg(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    SubMessage submsg = {""};
+    
+    if (!pb_decode(stream, SubMessage_fields, &submsg))
+        return false;
+    
+    TEST(memcmp(&submsg, *arg, sizeof(submsg)));
+    return true;
+}
+
+static bool read_emptymsg(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    EmptyMessage emptymsg = {0};
+    return pb_decode(stream, EmptyMessage_fields, &emptymsg);
+}
+
+static bool read_repeated_varint(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    int32_t** expected = (int32_t**)arg;
+    uint64_t value;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+
+    TEST(*(*expected)++ == value);
+    return true;
+}
+
+static bool read_repeated_svarint(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    int32_t** expected = (int32_t**)arg;
+    int64_t value;
+    if (!pb_decode_svarint(stream, &value))
+        return false;
+
+    TEST(*(*expected)++ == value);
+    return true;
+}
+
+static bool read_repeated_fixed32(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint32_t** expected = (uint32_t**)arg;
+    uint32_t value;
+    if (!pb_decode_fixed32(stream, &value))
+        return false;
+
+    TEST(*(*expected)++ == value);
+    return true;
+}
+
+static bool read_repeated_fixed64(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint64_t** expected = (uint64_t**)arg;
+    uint64_t value;
+    if (!pb_decode_fixed64(stream, &value))
+        return false;
+
+    TEST(*(*expected)++ == value);
+    return true;
+}
+
+static bool read_repeated_string(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint8_t*** expected = (uint8_t***)arg;
+    uint8_t buf[16] = {0};
+    size_t len = stream->bytes_left;
+    
+    if (len > sizeof(buf) - 1 || !pb_read(stream, buf, len))
+        return false;
+    
+    TEST(strcmp((char*)*(*expected)++, (char*)buf) == 0);
+    return true;
+}
+
+static bool read_repeated_submsg(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    SubMessage** expected = (SubMessage**)arg;
+    SubMessage decoded = {""};
+    if (!pb_decode(stream, SubMessage_fields, &decoded))
+        return false;
+
+    TEST(memcmp((*expected)++, &decoded, sizeof(decoded)) == 0);
+    return true;
+}
+
+static bool read_limits(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    Limits decoded = {0};
+    if (!pb_decode(stream, Limits_fields, &decoded))
+        return false;
+
+    TEST(decoded.int32_min  == INT32_MIN);
+    TEST(decoded.int32_max  == INT32_MAX);
+    TEST(decoded.uint32_min == 0);
+    TEST(decoded.uint32_max == UINT32_MAX);
+    TEST(decoded.int64_min  == INT64_MIN);
+    TEST(decoded.int64_max  == INT64_MAX);
+    TEST(decoded.uint64_min == 0);
+    TEST(decoded.uint64_max == UINT64_MAX);
+    TEST(decoded.enum_min   == HugeEnum_Negative);
+    TEST(decoded.enum_max   == HugeEnum_Positive);
+    
+    return true;
+}
+
+/* This function is called once from main(), it handles
+   the decoding and checks the fields. */
+bool check_alltypes(pb_istream_t *stream, int mode)
+{
+    /* Values for use from callbacks through pointers. */
+    uint32_t    req_fixed32     = 1008;
+    int32_t     req_sfixed32    = -1009;
+    float       req_float       = 1010.0f;
+    uint64_t    req_fixed64     = 1011;
+    int64_t     req_sfixed64    = -1012;
+    double      req_double      = 1013.0;
+    SubMessage  req_submsg      = {"1016", 1016};
+    
+    int32_t     rep_int32[5]    = {0, 0, 0, 0, -2001};
+    int32_t     rep_int64[5]    = {0, 0, 0, 0, -2002};
+    int32_t     rep_uint32[5]   = {0, 0, 0, 0,  2003};
+    int32_t     rep_uint64[5]   = {0, 0, 0, 0,  2004};
+    int32_t     rep_sint32[5]   = {0, 0, 0, 0, -2005};
+    int32_t     rep_sint64[5]   = {0, 0, 0, 0, -2006};
+    int32_t     rep_bool[5]     = {false, false, false, false, true};
+    uint32_t    rep_fixed32[5]  = {0, 0, 0, 0,  2008};
+    int32_t     rep_sfixed32[5] = {0, 0, 0, 0, -2009};
+    float       rep_float[5]    = {0, 0, 0, 0,  2010.0f};
+    uint64_t    rep_fixed64[5]  = {0, 0, 0, 0,  2011};
+    int64_t     rep_sfixed64[5] = {0, 0, 0, 0, -2012};
+    double      rep_double[5]   = {0, 0, 0, 0,  2013.0};
+    char*       rep_string[5]   = {"", "", "", "", "2014"};
+    char*       rep_bytes[5]    = {"", "", "", "", "2015"};
+    SubMessage  rep_submsg[5]   = {{"", 0, 0, 3},
+                                   {"", 0, 0, 3},
+                                   {"", 0, 0, 3},
+                                   {"", 0, 0, 3},
+                                   {"2016", 2016, true, 2016}};
+    int32_t     rep_enum[5]     = {0, 0, 0, 0, MyEnum_Truth};
+    
+    uint32_t    opt_fixed32     = 3048;
+    int32_t     opt_sfixed32    = 3049;
+    float       opt_float       = 3050.0f;
+    uint64_t    opt_fixed64     = 3051;
+    int64_t     opt_sfixed64    = 3052;
+    double      opt_double      = 3053.0f;
+    SubMessage  opt_submsg      = {"3056", 3056};
+
+    SubMessage  oneof_msg1      = {"4059", 4059};
+    
+    /* Bind callbacks for required fields */
+    AllTypes alltypes;
+    
+    /* Fill with garbage to better detect initialization errors */
+    memset(&alltypes, 0xAA, sizeof(alltypes));
+    alltypes.extensions = 0;
+    
+    alltypes.req_int32.funcs.decode = &read_varint;
+    alltypes.req_int32.arg = (void*)-1001;
+    
+    alltypes.req_int64.funcs.decode = &read_varint;
+    alltypes.req_int64.arg = (void*)-1002;
+    
+    alltypes.req_uint32.funcs.decode = &read_varint;
+    alltypes.req_uint32.arg = (void*)1003;
+
+    alltypes.req_uint32.funcs.decode = &read_varint;
+    alltypes.req_uint32.arg = (void*)1003;    
+    
+    alltypes.req_uint64.funcs.decode = &read_varint;
+    alltypes.req_uint64.arg = (void*)1004;
+    
+    alltypes.req_sint32.funcs.decode = &read_svarint;
+    alltypes.req_sint32.arg = (void*)-1005;   
+    
+    alltypes.req_sint64.funcs.decode = &read_svarint;
+    alltypes.req_sint64.arg = (void*)-1006;   
+    
+    alltypes.req_bool.funcs.decode = &read_varint;
+    alltypes.req_bool.arg = (void*)true;   
+    
+    alltypes.req_fixed32.funcs.decode = &read_fixed32;
+    alltypes.req_fixed32.arg = &req_fixed32;
+    
+    alltypes.req_sfixed32.funcs.decode = &read_fixed32;
+    alltypes.req_sfixed32.arg = &req_sfixed32;
+    
+    alltypes.req_float.funcs.decode = &read_fixed32;
+    alltypes.req_float.arg = &req_float;
+    
+    alltypes.req_fixed64.funcs.decode = &read_fixed64;
+    alltypes.req_fixed64.arg = &req_fixed64;
+    
+    alltypes.req_sfixed64.funcs.decode = &read_fixed64;
+    alltypes.req_sfixed64.arg = &req_sfixed64;
+    
+    alltypes.req_double.funcs.decode = &read_fixed64;
+    alltypes.req_double.arg = &req_double;
+    
+    alltypes.req_string.funcs.decode = &read_string;
+    alltypes.req_string.arg = "1014";
+    
+    alltypes.req_bytes.funcs.decode = &read_string;
+    alltypes.req_bytes.arg = "1015";
+    
+    alltypes.req_submsg.funcs.decode = &read_submsg;
+    alltypes.req_submsg.arg = &req_submsg;
+    
+    alltypes.req_enum.funcs.decode = &read_varint;
+    alltypes.req_enum.arg = (void*)MyEnum_Truth;
+    
+    alltypes.req_emptymsg.funcs.decode = &read_emptymsg;
+    
+    /* Bind callbacks for repeated fields */
+    alltypes.rep_int32.funcs.decode = &read_repeated_varint;
+    alltypes.rep_int32.arg = rep_int32;
+    
+    alltypes.rep_int64.funcs.decode = &read_repeated_varint;
+    alltypes.rep_int64.arg = rep_int64;
+    
+    alltypes.rep_uint32.funcs.decode = &read_repeated_varint;
+    alltypes.rep_uint32.arg = rep_uint32;
+    
+    alltypes.rep_uint64.funcs.decode = &read_repeated_varint;
+    alltypes.rep_uint64.arg = rep_uint64;
+    
+    alltypes.rep_sint32.funcs.decode = &read_repeated_svarint;
+    alltypes.rep_sint32.arg = rep_sint32;
+    
+    alltypes.rep_sint64.funcs.decode = &read_repeated_svarint;
+    alltypes.rep_sint64.arg = rep_sint64;
+    
+    alltypes.rep_bool.funcs.decode = &read_repeated_varint;
+    alltypes.rep_bool.arg = rep_bool;
+    
+    alltypes.rep_fixed32.funcs.decode = &read_repeated_fixed32;
+    alltypes.rep_fixed32.arg = rep_fixed32;
+    
+    alltypes.rep_sfixed32.funcs.decode = &read_repeated_fixed32;
+    alltypes.rep_sfixed32.arg = rep_sfixed32;
+    
+    alltypes.rep_float.funcs.decode = &read_repeated_fixed32;
+    alltypes.rep_float.arg = rep_float;
+    
+    alltypes.rep_fixed64.funcs.decode = &read_repeated_fixed64;
+    alltypes.rep_fixed64.arg = rep_fixed64;
+    
+    alltypes.rep_sfixed64.funcs.decode = &read_repeated_fixed64;
+    alltypes.rep_sfixed64.arg = rep_sfixed64;
+    
+    alltypes.rep_double.funcs.decode = &read_repeated_fixed64;
+    alltypes.rep_double.arg = rep_double;
+    
+    alltypes.rep_string.funcs.decode = &read_repeated_string;
+    alltypes.rep_string.arg = rep_string;
+    
+    alltypes.rep_bytes.funcs.decode = &read_repeated_string;
+    alltypes.rep_bytes.arg = rep_bytes;
+    
+    alltypes.rep_submsg.funcs.decode = &read_repeated_submsg;
+    alltypes.rep_submsg.arg = rep_submsg;
+    
+    alltypes.rep_enum.funcs.decode = &read_repeated_varint;
+    alltypes.rep_enum.arg = rep_enum;
+    
+    alltypes.rep_emptymsg.funcs.decode = &read_emptymsg;
+    
+    alltypes.req_limits.funcs.decode = &read_limits;
+    
+    alltypes.end.funcs.decode = &read_varint;
+    alltypes.end.arg = (void*)1099;
+    
+    /* Bind callbacks for optional fields */
+    if (mode == 1)
+    {
+        alltypes.opt_int32.funcs.decode = &read_varint;
+        alltypes.opt_int32.arg = (void*)3041;
+        
+        alltypes.opt_int64.funcs.decode = &read_varint;
+        alltypes.opt_int64.arg = (void*)3042;
+        
+        alltypes.opt_uint32.funcs.decode = &read_varint;
+        alltypes.opt_uint32.arg = (void*)3043;
+        
+        alltypes.opt_uint64.funcs.decode = &read_varint;
+        alltypes.opt_uint64.arg = (void*)3044;
+        
+        alltypes.opt_sint32.funcs.decode = &read_svarint;
+        alltypes.opt_sint32.arg = (void*)3045;
+        
+        alltypes.opt_sint64.funcs.decode = &read_svarint;
+        alltypes.opt_sint64.arg = (void*)3046;
+        
+        alltypes.opt_bool.funcs.decode = &read_varint;
+        alltypes.opt_bool.arg = (void*)true;
+
+        alltypes.opt_fixed32.funcs.decode = &read_fixed32;
+        alltypes.opt_fixed32.arg = &opt_fixed32;
+        
+        alltypes.opt_sfixed32.funcs.decode = &read_fixed32;
+        alltypes.opt_sfixed32.arg = &opt_sfixed32;
+        
+        alltypes.opt_float.funcs.decode = &read_fixed32;
+        alltypes.opt_float.arg = &opt_float;
+        
+        alltypes.opt_fixed64.funcs.decode = &read_fixed64;
+        alltypes.opt_fixed64.arg = &opt_fixed64;
+        
+        alltypes.opt_sfixed64.funcs.decode = &read_fixed64;
+        alltypes.opt_sfixed64.arg = &opt_sfixed64;
+        
+        alltypes.opt_double.funcs.decode = &read_fixed64;
+        alltypes.opt_double.arg = &opt_double;
+        
+        alltypes.opt_string.funcs.decode = &read_string;
+        alltypes.opt_string.arg = "3054";
+        
+        alltypes.opt_bytes.funcs.decode = &read_string;
+        alltypes.opt_bytes.arg = "3055";
+        
+        alltypes.opt_submsg.funcs.decode = &read_submsg;
+        alltypes.opt_submsg.arg = &opt_submsg;
+        
+        alltypes.opt_enum.funcs.decode = &read_varint;
+        alltypes.opt_enum.arg = (void*)MyEnum_Truth;
+        
+        alltypes.opt_emptymsg.funcs.decode = &read_emptymsg;
+
+        alltypes.oneof_msg1.funcs.decode = &read_submsg;
+        alltypes.oneof_msg1.arg = &oneof_msg1;
+    }
+    
+    return pb_decode(stream, AllTypes_fields, &alltypes);
+}
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[1024];
+    size_t count;
+    pb_istream_t stream;
+
+    /* Whether to expect the optional values or the default values. */
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Read the data into buffer */
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+    
+    /* Construct a pb_istream_t for reading from the buffer */
+    stream = pb_istream_from_buffer(buffer, count);
+    
+    /* Decode and print out the stuff */
+    if (!check_alltypes(&stream, mode))
+    {
+        printf("Parsing failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    } else {
+        return 0;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_callback/encode_alltypes_callback.c
@@ -0,0 +1,402 @@
+/* Attempts to test all the datatypes supported by ProtoBuf when used as callback fields.
+ * Note that normally there would be no reason to use callback fields for this,
+ * because each encoder defined here only gives a single field.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+static bool write_varint(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_varint(stream, (long)*arg);
+}
+
+static bool write_svarint(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_svarint(stream, (long)*arg);
+}
+
+static bool write_fixed32(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_fixed32(stream, *arg);
+}
+
+static bool write_fixed64(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_fixed64(stream, *arg);
+}
+
+static bool write_string(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(stream, *arg, strlen(*arg));
+}
+
+static bool write_submsg(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+   
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, SubMessage_fields, *arg);
+}
+
+static bool write_emptymsg(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    EmptyMessage emptymsg = {0};
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, EmptyMessage_fields, &emptymsg);
+}
+
+static bool write_repeated_varint(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_varint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_varint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_varint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_varint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_varint(stream, (long)*arg);
+}
+
+static bool write_repeated_svarint(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_svarint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_svarint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_svarint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_svarint(stream, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_svarint(stream, (long)*arg);
+}
+
+static bool write_repeated_fixed32(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    uint32_t dummy = 0;
+
+    /* Make it a packed field */
+    return pb_encode_tag(stream, PB_WT_STRING, field->tag) &&
+           pb_encode_varint(stream, 5 * 4) && /* Number of bytes */
+           pb_encode_fixed32(stream, &dummy) &&
+           pb_encode_fixed32(stream, &dummy) &&
+           pb_encode_fixed32(stream, &dummy) &&
+           pb_encode_fixed32(stream, &dummy) &&
+           pb_encode_fixed32(stream, *arg);
+}
+
+static bool write_repeated_fixed64(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    uint64_t dummy = 0;
+
+    /* Make it a packed field */
+    return pb_encode_tag(stream, PB_WT_STRING, field->tag) &&
+           pb_encode_varint(stream, 5 * 8) && /* Number of bytes */
+           pb_encode_fixed64(stream, &dummy) &&
+           pb_encode_fixed64(stream, &dummy) &&
+           pb_encode_fixed64(stream, &dummy) &&
+           pb_encode_fixed64(stream, &dummy) &&
+           pb_encode_fixed64(stream, *arg);
+}
+
+static bool write_repeated_string(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(stream, 0, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(stream, 0, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(stream, 0, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(stream, 0, 0) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_string(stream, *arg, strlen(*arg));
+}
+
+static bool write_repeated_submsg(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    SubMessage dummy = {""};
+
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, SubMessage_fields, &dummy) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, SubMessage_fields, &dummy) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, SubMessage_fields, &dummy) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, SubMessage_fields, &dummy) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, SubMessage_fields, *arg);
+}
+
+static bool write_limits(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    Limits limits = {0};
+    limits.int32_min  = INT32_MIN;
+    limits.int32_max  = INT32_MAX;
+    limits.uint32_min = 0;
+    limits.uint32_max = UINT32_MAX;
+    limits.int64_min  = INT64_MIN;
+    limits.int64_max  = INT64_MAX;
+    limits.uint64_min = 0;
+    limits.uint64_max = UINT64_MAX;
+    limits.enum_min   = HugeEnum_Negative;
+    limits.enum_max   = HugeEnum_Positive;
+   
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, Limits_fields, &limits);
+}
+
+static bool write_repeated_emptymsg(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    EmptyMessage emptymsg = {0};
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, EmptyMessage_fields, &emptymsg) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, EmptyMessage_fields, &emptymsg) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, EmptyMessage_fields, &emptymsg) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, EmptyMessage_fields, &emptymsg) &&
+           pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, EmptyMessage_fields, &emptymsg);
+}
+
+int main(int argc, char **argv)
+{
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+
+    /* Values for use from callbacks through pointers. */
+    uint32_t    req_fixed32     = 1008;
+    int32_t     req_sfixed32    = -1009;
+    float       req_float       = 1010.0f;
+    uint64_t    req_fixed64     = 1011;
+    int64_t     req_sfixed64    = -1012;
+    double      req_double      = 1013.0;
+    SubMessage  req_submsg      = {"1016", 1016};
+    
+    uint32_t    rep_fixed32     = 2008;
+    int32_t     rep_sfixed32    = -2009;
+    float       rep_float       = 2010.0f;
+    uint64_t    rep_fixed64     = 2011;
+    int64_t     rep_sfixed64    = -2012;
+    double      rep_double      = 2013.0;
+    SubMessage  rep_submsg      = {"2016", 2016, true, 2016};
+    
+    uint32_t    opt_fixed32     = 3048;
+    int32_t     opt_sfixed32    = 3049;
+    float       opt_float       = 3050.0f;
+    uint64_t    opt_fixed64     = 3051;
+    int64_t     opt_sfixed64    = 3052;
+    double      opt_double      = 3053.0f;
+    SubMessage  opt_submsg      = {"3056", 3056};
+    
+    SubMessage  oneof_msg1      = {"4059", 4059};
+
+    /* Bind callbacks for required fields */
+    AllTypes alltypes = {{{0}}};
+    
+    alltypes.req_int32.funcs.encode = &write_varint;
+    alltypes.req_int32.arg = (void*)-1001;
+    
+    alltypes.req_int64.funcs.encode = &write_varint;
+    alltypes.req_int64.arg = (void*)-1002;
+    
+    alltypes.req_uint32.funcs.encode = &write_varint;
+    alltypes.req_uint32.arg = (void*)1003;
+
+    alltypes.req_uint32.funcs.encode = &write_varint;
+    alltypes.req_uint32.arg = (void*)1003;    
+    
+    alltypes.req_uint64.funcs.encode = &write_varint;
+    alltypes.req_uint64.arg = (void*)1004;
+    
+    alltypes.req_sint32.funcs.encode = &write_svarint;
+    alltypes.req_sint32.arg = (void*)-1005;   
+    
+    alltypes.req_sint64.funcs.encode = &write_svarint;
+    alltypes.req_sint64.arg = (void*)-1006;   
+    
+    alltypes.req_bool.funcs.encode = &write_varint;
+    alltypes.req_bool.arg = (void*)true;   
+    
+    alltypes.req_fixed32.funcs.encode = &write_fixed32;
+    alltypes.req_fixed32.arg = &req_fixed32;
+    
+    alltypes.req_sfixed32.funcs.encode = &write_fixed32;
+    alltypes.req_sfixed32.arg = &req_sfixed32;
+    
+    alltypes.req_float.funcs.encode = &write_fixed32;
+    alltypes.req_float.arg = &req_float;
+    
+    alltypes.req_fixed64.funcs.encode = &write_fixed64;
+    alltypes.req_fixed64.arg = &req_fixed64;
+    
+    alltypes.req_sfixed64.funcs.encode = &write_fixed64;
+    alltypes.req_sfixed64.arg = &req_sfixed64;
+    
+    alltypes.req_double.funcs.encode = &write_fixed64;
+    alltypes.req_double.arg = &req_double;
+    
+    alltypes.req_string.funcs.encode = &write_string;
+    alltypes.req_string.arg = "1014";
+    
+    alltypes.req_bytes.funcs.encode = &write_string;
+    alltypes.req_bytes.arg = "1015";
+    
+    alltypes.req_submsg.funcs.encode = &write_submsg;
+    alltypes.req_submsg.arg = &req_submsg;
+    
+    alltypes.req_enum.funcs.encode = &write_varint;
+    alltypes.req_enum.arg = (void*)MyEnum_Truth;
+    
+    alltypes.req_emptymsg.funcs.encode = &write_emptymsg;
+    
+    /* Bind callbacks for repeated fields */
+    alltypes.rep_int32.funcs.encode = &write_repeated_varint;
+    alltypes.rep_int32.arg = (void*)-2001;
+    
+    alltypes.rep_int64.funcs.encode = &write_repeated_varint;
+    alltypes.rep_int64.arg = (void*)-2002;
+    
+    alltypes.rep_uint32.funcs.encode = &write_repeated_varint;
+    alltypes.rep_uint32.arg = (void*)2003;
+    
+    alltypes.rep_uint64.funcs.encode = &write_repeated_varint;
+    alltypes.rep_uint64.arg = (void*)2004;
+    
+    alltypes.rep_sint32.funcs.encode = &write_repeated_svarint;
+    alltypes.rep_sint32.arg = (void*)-2005;
+    
+    alltypes.rep_sint64.funcs.encode = &write_repeated_svarint;
+    alltypes.rep_sint64.arg = (void*)-2006;
+    
+    alltypes.rep_bool.funcs.encode = &write_repeated_varint;
+    alltypes.rep_bool.arg = (void*)true;
+    
+    alltypes.rep_fixed32.funcs.encode = &write_repeated_fixed32;
+    alltypes.rep_fixed32.arg = &rep_fixed32;
+
+    alltypes.rep_sfixed32.funcs.encode = &write_repeated_fixed32;
+    alltypes.rep_sfixed32.arg = &rep_sfixed32;
+    
+    alltypes.rep_float.funcs.encode = &write_repeated_fixed32;
+    alltypes.rep_float.arg = &rep_float;
+    
+    alltypes.rep_fixed64.funcs.encode = &write_repeated_fixed64;
+    alltypes.rep_fixed64.arg = &rep_fixed64;
+
+    alltypes.rep_sfixed64.funcs.encode = &write_repeated_fixed64;
+    alltypes.rep_sfixed64.arg = &rep_sfixed64;
+    
+    alltypes.rep_double.funcs.encode = &write_repeated_fixed64;
+    alltypes.rep_double.arg = &rep_double;
+    
+    alltypes.rep_string.funcs.encode = &write_repeated_string;
+    alltypes.rep_string.arg = "2014";
+    
+    alltypes.rep_bytes.funcs.encode = &write_repeated_string;
+    alltypes.rep_bytes.arg = "2015";
+    
+    alltypes.rep_submsg.funcs.encode = &write_repeated_submsg;
+    alltypes.rep_submsg.arg = &rep_submsg;
+    
+    alltypes.rep_enum.funcs.encode = &write_repeated_varint;
+    alltypes.rep_enum.arg = (void*)MyEnum_Truth;
+    
+    alltypes.rep_emptymsg.funcs.encode = &write_repeated_emptymsg;
+    
+    alltypes.req_limits.funcs.encode = &write_limits;
+    
+    /* Bind callbacks for optional fields */
+    if (mode != 0)
+    {
+        alltypes.opt_int32.funcs.encode = &write_varint;
+        alltypes.opt_int32.arg = (void*)3041;
+        
+        alltypes.opt_int64.funcs.encode = &write_varint;
+        alltypes.opt_int64.arg = (void*)3042;
+        
+        alltypes.opt_uint32.funcs.encode = &write_varint;
+        alltypes.opt_uint32.arg = (void*)3043;
+        
+        alltypes.opt_uint64.funcs.encode = &write_varint;
+        alltypes.opt_uint64.arg = (void*)3044;
+        
+        alltypes.opt_sint32.funcs.encode = &write_svarint;
+        alltypes.opt_sint32.arg = (void*)3045;
+        
+        alltypes.opt_sint64.funcs.encode = &write_svarint;
+        alltypes.opt_sint64.arg = (void*)3046;
+        
+        alltypes.opt_bool.funcs.encode = &write_varint;
+        alltypes.opt_bool.arg = (void*)true;
+
+        alltypes.opt_fixed32.funcs.encode = &write_fixed32;
+        alltypes.opt_fixed32.arg = &opt_fixed32;
+        
+        alltypes.opt_sfixed32.funcs.encode = &write_fixed32;
+        alltypes.opt_sfixed32.arg = &opt_sfixed32;
+        
+        alltypes.opt_float.funcs.encode = &write_fixed32;
+        alltypes.opt_float.arg = &opt_float;
+        
+        alltypes.opt_fixed64.funcs.encode = &write_fixed64;
+        alltypes.opt_fixed64.arg = &opt_fixed64;
+        
+        alltypes.opt_sfixed64.funcs.encode = &write_fixed64;
+        alltypes.opt_sfixed64.arg = &opt_sfixed64;
+        
+        alltypes.opt_double.funcs.encode = &write_fixed64;
+        alltypes.opt_double.arg = &opt_double;
+        
+        alltypes.opt_string.funcs.encode = &write_string;
+        alltypes.opt_string.arg = "3054";
+        
+        alltypes.opt_bytes.funcs.encode = &write_string;
+        alltypes.opt_bytes.arg = "3055";
+        
+        alltypes.opt_submsg.funcs.encode = &write_submsg;
+        alltypes.opt_submsg.arg = &opt_submsg;
+        
+        alltypes.opt_enum.funcs.encode = &write_varint;
+        alltypes.opt_enum.arg = (void*)MyEnum_Truth;
+        
+        alltypes.opt_emptymsg.funcs.encode = &write_emptymsg;
+
+        alltypes.oneof_msg1.funcs.encode = &write_submsg;
+        alltypes.oneof_msg1.arg = &oneof_msg1;
+    }
+    
+    alltypes.end.funcs.encode = &write_varint;
+    alltypes.end.arg = (void*)1099;
+    
+    {
+        uint8_t buffer[2048];
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        /* Now encode it and check if we succeeded. */
+        if (pb_encode(&stream, AllTypes_fields, &alltypes))
+        {
+            SET_BINARY_MODE(stdout);
+            fwrite(buffer, 1, stream.bytes_written, stdout);
+            return 0; /* Success */
+        }
+        else
+        {
+            fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1; /* Failure */
+        }
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_pointer/SConscript
@@ -0,0 +1,40 @@
+# Encode the AllTypes message using pointers for all fields, and verify the
+# output against the normal AllTypes test case.
+
+Import("env", "malloc_env")
+
+c = Copy("$TARGET", "$SOURCE")
+env.Command("alltypes.proto", "#alltypes/alltypes.proto", c)
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+enc = malloc_env.Program(["encode_alltypes_pointer.c",
+                          "alltypes.pb.c",
+                          "$COMMON/pb_encode_with_malloc.o",
+                          "$COMMON/pb_common_with_malloc.o",
+                          "$COMMON/malloc_wrappers.o"])
+dec = malloc_env.Program(["decode_alltypes_pointer.c",
+                          "alltypes.pb.c",
+                          "$COMMON/pb_decode_with_malloc.o",
+                          "$COMMON/pb_common_with_malloc.o",
+                          "$COMMON/malloc_wrappers.o"])
+
+# Encode and compare results to non-pointer alltypes test case
+env.RunTest(enc)
+env.Compare(["encode_alltypes_pointer.output", "$BUILD/alltypes/encode_alltypes.output"])
+
+# Decode (under valgrind if available)
+valgrind = env.WhereIs('valgrind')
+kwargs = {}
+if valgrind:
+    kwargs['COMMAND'] = valgrind
+    kwargs['ARGS'] = ["-q", "--error-exitcode=99", dec[0].abspath]
+
+env.RunTest("decode_alltypes.output", [dec, "encode_alltypes_pointer.output"], **kwargs)
+
+# Do the same thing with the optional fields present
+env.RunTest("optionals.output", enc, ARGS = ['1'])
+env.Compare(["optionals.output", "$BUILD/alltypes/optionals.output"])
+
+kwargs['ARGS'] = kwargs.get('ARGS', []) + ['1']
+env.RunTest("optionals.decout", [dec, "optionals.output"], **kwargs)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_pointer/alltypes.options
@@ -0,0 +1,3 @@
+# Generate all fields as pointers.
+* type:FT_POINTER
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_pointer/decode_alltypes_pointer.c
@@ -0,0 +1,180 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pb_decode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+#define TEST(x) if (!(x)) { \
+    fprintf(stderr, "Test " #x " failed.\n"); \
+    status = false; \
+    }
+
+/* This function is called once from main(), it handles
+   the decoding and checks the fields. */
+bool check_alltypes(pb_istream_t *stream, int mode)
+{
+    bool status = true;
+    AllTypes alltypes;
+    
+    /* Fill with garbage to better detect initialization errors */
+    memset(&alltypes, 0xAA, sizeof(alltypes));
+    alltypes.extensions = 0;
+    
+    if (!pb_decode(stream, AllTypes_fields, &alltypes))
+        return false;
+    
+    TEST(alltypes.req_int32     && *alltypes.req_int32         == -1001);
+    TEST(alltypes.req_int64     && *alltypes.req_int64         == -1002);
+    TEST(alltypes.req_uint32    && *alltypes.req_uint32        == 1003);
+    TEST(alltypes.req_uint64    && *alltypes.req_uint64        == 1004);
+    TEST(alltypes.req_sint32    && *alltypes.req_sint32        == -1005);
+    TEST(alltypes.req_sint64    && *alltypes.req_sint64        == -1006);
+    TEST(alltypes.req_bool      && *alltypes.req_bool          == true);
+    
+    TEST(alltypes.req_fixed32   && *alltypes.req_fixed32       == 1008);
+    TEST(alltypes.req_sfixed32  && *alltypes.req_sfixed32      == -1009);
+    TEST(alltypes.req_float     && *alltypes.req_float         == 1010.0f);
+    
+    TEST(alltypes.req_fixed64   && *alltypes.req_fixed64       == 1011);
+    TEST(alltypes.req_sfixed64  && *alltypes.req_sfixed64      == -1012);
+    TEST(alltypes.req_double    && *alltypes.req_double        == 1013.0f);
+    
+    TEST(alltypes.req_string    && strcmp(alltypes.req_string, "1014") == 0);
+    TEST(alltypes.req_bytes     && alltypes.req_bytes->size == 4);
+    TEST(alltypes.req_bytes     && memcmp(&alltypes.req_bytes->bytes, "1015", 4) == 0);
+    TEST(alltypes.req_submsg    && alltypes.req_submsg->substuff1
+                                && strcmp(alltypes.req_submsg->substuff1, "1016") == 0);
+    TEST(alltypes.req_submsg    && alltypes.req_submsg->substuff2
+                                && *alltypes.req_submsg->substuff2 == 1016);
+    TEST(*alltypes.req_enum == MyEnum_Truth);
+
+    TEST(alltypes.rep_int32_count == 5 && alltypes.rep_int32[4] == -2001 && alltypes.rep_int32[0] == 0);
+    TEST(alltypes.rep_int64_count == 5 && alltypes.rep_int64[4] == -2002 && alltypes.rep_int64[0] == 0);
+    TEST(alltypes.rep_uint32_count == 5 && alltypes.rep_uint32[4] == 2003 && alltypes.rep_uint32[0] == 0);
+    TEST(alltypes.rep_uint64_count == 5 && alltypes.rep_uint64[4] == 2004 && alltypes.rep_uint64[0] == 0);
+    TEST(alltypes.rep_sint32_count == 5 && alltypes.rep_sint32[4] == -2005 && alltypes.rep_sint32[0] == 0);
+    TEST(alltypes.rep_sint64_count == 5 && alltypes.rep_sint64[4] == -2006 && alltypes.rep_sint64[0] == 0);
+    TEST(alltypes.rep_bool_count == 5 && alltypes.rep_bool[4] == true && alltypes.rep_bool[0] == false);
+    
+    TEST(alltypes.rep_fixed32_count == 5 && alltypes.rep_fixed32[4] == 2008 && alltypes.rep_fixed32[0] == 0);
+    TEST(alltypes.rep_sfixed32_count == 5 && alltypes.rep_sfixed32[4] == -2009 && alltypes.rep_sfixed32[0] == 0);
+    TEST(alltypes.rep_float_count == 5 && alltypes.rep_float[4] == 2010.0f && alltypes.rep_float[0] == 0.0f);
+    
+    TEST(alltypes.rep_fixed64_count == 5 && alltypes.rep_fixed64[4] == 2011 && alltypes.rep_fixed64[0] == 0);
+    TEST(alltypes.rep_sfixed64_count == 5 && alltypes.rep_sfixed64[4] == -2012 && alltypes.rep_sfixed64[0] == 0);
+    TEST(alltypes.rep_double_count == 5 && alltypes.rep_double[4] == 2013.0 && alltypes.rep_double[0] == 0.0);
+    
+    TEST(alltypes.rep_string_count == 5 && strcmp(alltypes.rep_string[4], "2014") == 0 && alltypes.rep_string[0][0] == '\0');
+    TEST(alltypes.rep_bytes_count == 5 && alltypes.rep_bytes[4]->size == 4 && alltypes.rep_bytes[0]->size == 0);
+    TEST(memcmp(&alltypes.rep_bytes[4]->bytes, "2015", 4) == 0);
+
+    TEST(alltypes.rep_submsg_count == 5);
+    TEST(strcmp(alltypes.rep_submsg[4].substuff1, "2016") == 0 && alltypes.rep_submsg[0].substuff1[0] == '\0');
+    TEST(*alltypes.rep_submsg[4].substuff2 == 2016 && *alltypes.rep_submsg[0].substuff2 == 0);
+    TEST(*alltypes.rep_submsg[4].substuff3 == 2016 && alltypes.rep_submsg[0].substuff3 == NULL);
+    
+    TEST(alltypes.rep_enum_count == 5 && alltypes.rep_enum[4] == MyEnum_Truth && alltypes.rep_enum[0] == MyEnum_Zero);
+    TEST(alltypes.rep_emptymsg_count == 5);
+
+    if (mode == 0)
+    {
+        /* Expect that optional values are not present */
+        TEST(alltypes.opt_int32         == NULL);
+        TEST(alltypes.opt_int64         == NULL);
+        TEST(alltypes.opt_uint32        == NULL);
+        TEST(alltypes.opt_uint64        == NULL);
+        TEST(alltypes.opt_sint32        == NULL);
+        TEST(alltypes.opt_sint64        == NULL);
+        TEST(alltypes.opt_bool          == NULL);
+        
+        TEST(alltypes.opt_fixed32       == NULL);
+        TEST(alltypes.opt_sfixed32      == NULL);
+        TEST(alltypes.opt_float         == NULL);
+        TEST(alltypes.opt_fixed64       == NULL);
+        TEST(alltypes.opt_sfixed64      == NULL);
+        TEST(alltypes.opt_double        == NULL);
+        
+        TEST(alltypes.opt_string        == NULL);
+        TEST(alltypes.opt_bytes         == NULL);
+        TEST(alltypes.opt_submsg        == NULL);
+        TEST(alltypes.opt_enum          == NULL);
+
+        TEST(alltypes.which_oneof       == 0);
+    }
+    else
+    {
+        /* Expect filled-in values */
+        TEST(alltypes.opt_int32 && *alltypes.opt_int32      == 3041);
+        TEST(alltypes.opt_int64 && *alltypes.opt_int64      == 3042);
+        TEST(alltypes.opt_uint32 && *alltypes.opt_uint32    == 3043);
+        TEST(alltypes.opt_uint64 && *alltypes.opt_uint64    == 3044);
+        TEST(alltypes.opt_sint32 && *alltypes.opt_sint32    == 3045);
+        TEST(alltypes.opt_sint64 && *alltypes.opt_sint64    == 3046);
+        TEST(alltypes.opt_bool && *alltypes.opt_bool        == true);
+        
+        TEST(alltypes.opt_fixed32 && *alltypes.opt_fixed32  == 3048);
+        TEST(alltypes.opt_sfixed32 && *alltypes.opt_sfixed32== 3049);
+        TEST(alltypes.opt_float && *alltypes.opt_float      == 3050.0f);
+        TEST(alltypes.opt_fixed64 && *alltypes.opt_fixed64  == 3051);
+        TEST(alltypes.opt_sfixed64 && *alltypes.opt_sfixed64== 3052);
+        TEST(alltypes.opt_double && *alltypes.opt_double    == 3053.0);
+        
+        TEST(alltypes.opt_string && strcmp(alltypes.opt_string, "3054") == 0);
+        TEST(alltypes.opt_bytes && alltypes.opt_bytes->size == 4);
+        TEST(alltypes.opt_bytes && memcmp(&alltypes.opt_bytes->bytes, "3055", 4) == 0);
+        TEST(alltypes.opt_submsg && strcmp(alltypes.opt_submsg->substuff1, "3056") == 0);
+        TEST(alltypes.opt_submsg && *alltypes.opt_submsg->substuff2 == 3056);
+        TEST(alltypes.opt_enum && *alltypes.opt_enum == MyEnum_Truth);
+        TEST(alltypes.opt_emptymsg);
+
+        TEST(alltypes.which_oneof == AllTypes_oneof_msg1_tag);
+        TEST(alltypes.oneof.oneof_msg1 && strcmp(alltypes.oneof.oneof_msg1->substuff1, "4059") == 0);
+        TEST(alltypes.oneof.oneof_msg1->substuff2 && *alltypes.oneof.oneof_msg1->substuff2 == 4059);
+    }
+    
+    TEST(alltypes.req_limits->int32_min && *alltypes.req_limits->int32_min   == INT32_MIN);
+    TEST(alltypes.req_limits->int32_max && *alltypes.req_limits->int32_max   == INT32_MAX);
+    TEST(alltypes.req_limits->uint32_min && *alltypes.req_limits->uint32_min == 0);
+    TEST(alltypes.req_limits->uint32_max && *alltypes.req_limits->uint32_max == UINT32_MAX);
+    TEST(alltypes.req_limits->int64_min && *alltypes.req_limits->int64_min   == INT64_MIN);
+    TEST(alltypes.req_limits->int64_max && *alltypes.req_limits->int64_max   == INT64_MAX);
+    TEST(alltypes.req_limits->uint64_min && *alltypes.req_limits->uint64_min == 0);
+    TEST(alltypes.req_limits->uint64_max && *alltypes.req_limits->uint64_max == UINT64_MAX);
+    TEST(alltypes.req_limits->enum_min && *alltypes.req_limits->enum_min     == HugeEnum_Negative);
+    TEST(alltypes.req_limits->enum_max && *alltypes.req_limits->enum_max     == HugeEnum_Positive);
+    
+    TEST(alltypes.end && *alltypes.end == 1099);
+
+    pb_release(AllTypes_fields, &alltypes);
+
+    return status;
+}
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[1024];
+    size_t count;
+    pb_istream_t stream;
+    
+    /* Whether to expect the optional values or the default values. */
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Read the data into buffer */
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+    
+    /* Construct a pb_istream_t for reading from the buffer */
+    stream = pb_istream_from_buffer(buffer, count);
+    
+    /* Decode and verify the message */
+    if (!check_alltypes(&stream, mode))
+    {
+        fprintf(stderr, "Test failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    }
+    else
+    {
+        return 0;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/alltypes_pointer/encode_alltypes_pointer.c
@@ -0,0 +1,194 @@
+/* Attempts to test all the datatypes supported by ProtoBuf.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+int main(int argc, char **argv)
+{
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Values for required fields */
+    int32_t     req_int32         = -1001;
+    int64_t     req_int64         = -1002;
+    uint32_t    req_uint32        = 1003;
+    uint64_t    req_uint64        = 1004;
+    int32_t     req_sint32        = -1005;
+    int64_t     req_sint64        = -1006;
+    bool        req_bool          = true;
+    uint32_t    req_fixed32       = 1008;
+    int32_t     req_sfixed32      = -1009;
+    float       req_float         = 1010.0f;
+    uint64_t    req_fixed64       = 1011;
+    int64_t     req_sfixed64      = -1012;
+    double      req_double        = 1013.0;
+    char*       req_string        = "1014";
+    PB_BYTES_ARRAY_T(4) req_bytes = {4, {'1', '0', '1', '5'}};
+    static int32_t req_substuff   = 1016;
+    SubMessage  req_submsg        = {"1016", &req_substuff};
+    MyEnum      req_enum          = MyEnum_Truth;
+    EmptyMessage req_emptymsg     = {0};
+    
+    int32_t     end               = 1099;
+
+    /* Values for repeated fields */
+    int32_t     rep_int32[5]      = {0, 0, 0, 0, -2001};
+    int64_t     rep_int64[5]      = {0, 0, 0, 0, -2002};
+    uint32_t    rep_uint32[5]     = {0, 0, 0, 0, 2003};
+    uint64_t    rep_uint64[5]     = {0, 0, 0, 0, 2004};
+    int32_t     rep_sint32[5]     = {0, 0, 0, 0, -2005};
+    int64_t     rep_sint64[5]     = {0, 0, 0, 0, -2006};
+    bool        rep_bool[5]       = {false, false, false, false, true};
+    uint32_t    rep_fixed32[5]    = {0, 0, 0, 0, 2008};
+    int32_t     rep_sfixed32[5]   = {0, 0, 0, 0, -2009};
+    float       rep_float[5]      = {0, 0, 0, 0, 2010.0f};
+    uint64_t    rep_fixed64[5]    = {0, 0, 0, 0, 2011};
+    int64_t     rep_sfixed64[5]   = {0, 0, 0, 0, -2012};
+    double      rep_double[5]     = {0, 0, 0, 0, 2013.0f};
+    char*       rep_string[5]     = {"", "", "", "", "2014"};
+    static PB_BYTES_ARRAY_T(4) rep_bytes_4 = {4, {'2', '0', '1', '5'}};
+    pb_bytes_array_t *rep_bytes[5]= {NULL, NULL, NULL, NULL, (pb_bytes_array_t*)&rep_bytes_4};
+    static int32_t rep_sub2zero   = 0;
+    static int32_t rep_substuff2  = 2016;
+    static uint32_t rep_substuff3 = 2016;
+    SubMessage  rep_submsg[5]     = {{"", &rep_sub2zero},
+                                     {"", &rep_sub2zero},
+                                     {"", &rep_sub2zero},
+                                     {"", &rep_sub2zero},
+                                     {"2016", &rep_substuff2, &rep_substuff3}};
+    MyEnum      rep_enum[5]       = {0, 0, 0, 0, MyEnum_Truth};
+    EmptyMessage rep_emptymsg[5]  = {{0}, {0}, {0}, {0}, {0}};
+
+    /* Values for optional fields */
+    int32_t     opt_int32         = 3041;
+    int64_t     opt_int64         = 3042;
+    uint32_t    opt_uint32        = 3043;
+    uint64_t    opt_uint64        = 3044;
+    int32_t     opt_sint32        = 3045;
+    int64_t     opt_sint64        = 3046;
+    bool        opt_bool          = true;
+    uint32_t    opt_fixed32       = 3048;
+    int32_t     opt_sfixed32      = 3049;
+    float       opt_float         = 3050.0f;
+    uint64_t    opt_fixed64       = 3051;
+    int64_t     opt_sfixed64      = 3052;
+    double      opt_double        = 3053.0;
+    char*       opt_string        = "3054";
+    PB_BYTES_ARRAY_T(4) opt_bytes = {4, {'3', '0', '5', '5'}};
+    static int32_t opt_substuff   = 3056;
+    SubMessage  opt_submsg        = {"3056", &opt_substuff};
+    MyEnum      opt_enum          = MyEnum_Truth;
+    EmptyMessage opt_emptymsg     = {0};
+
+    static int32_t oneof_substuff = 4059;
+    SubMessage  oneof_msg1        = {"4059", &oneof_substuff};
+
+    /* Values for the Limits message. */
+    static int32_t  int32_min  = INT32_MIN;
+    static int32_t  int32_max  = INT32_MAX;
+    static uint32_t uint32_min = 0;
+    static uint32_t uint32_max = UINT32_MAX;
+    static int64_t  int64_min  = INT64_MIN;
+    static int64_t  int64_max  = INT64_MAX;
+    static uint64_t uint64_min = 0;
+    static uint64_t uint64_max = UINT64_MAX;
+    static HugeEnum enum_min   = HugeEnum_Negative;
+    static HugeEnum enum_max   = HugeEnum_Positive;
+    Limits req_limits = {&int32_min,    &int32_max,
+                         &uint32_min,   &uint32_max,
+                         &int64_min,    &int64_max,
+                         &uint64_min,   &uint64_max,
+                         &enum_min,     &enum_max};
+
+    /* Initialize the message struct with pointers to the fields. */
+    AllTypes alltypes = {0};
+
+    alltypes.req_int32         = &req_int32;
+    alltypes.req_int64         = &req_int64;
+    alltypes.req_uint32        = &req_uint32;
+    alltypes.req_uint64        = &req_uint64;
+    alltypes.req_sint32        = &req_sint32;
+    alltypes.req_sint64        = &req_sint64;
+    alltypes.req_bool          = &req_bool;
+    alltypes.req_fixed32       = &req_fixed32;
+    alltypes.req_sfixed32      = &req_sfixed32;
+    alltypes.req_float         = &req_float;
+    alltypes.req_fixed64       = &req_fixed64;
+    alltypes.req_sfixed64      = &req_sfixed64;
+    alltypes.req_double        = &req_double;
+    alltypes.req_string        = req_string;
+    alltypes.req_bytes         = (pb_bytes_array_t*)&req_bytes;
+    alltypes.req_submsg        = &req_submsg;
+    alltypes.req_enum          = &req_enum;
+    alltypes.req_emptymsg      = &req_emptymsg;
+    alltypes.req_limits        = &req_limits;
+    
+    alltypes.rep_int32_count    = 5; alltypes.rep_int32     = rep_int32;
+    alltypes.rep_int64_count    = 5; alltypes.rep_int64     = rep_int64;
+    alltypes.rep_uint32_count   = 5; alltypes.rep_uint32    = rep_uint32;
+    alltypes.rep_uint64_count   = 5; alltypes.rep_uint64    = rep_uint64;
+    alltypes.rep_sint32_count   = 5; alltypes.rep_sint32    = rep_sint32;
+    alltypes.rep_sint64_count   = 5; alltypes.rep_sint64    = rep_sint64;
+    alltypes.rep_bool_count     = 5; alltypes.rep_bool      = rep_bool;
+    alltypes.rep_fixed32_count  = 5; alltypes.rep_fixed32   = rep_fixed32;
+    alltypes.rep_sfixed32_count = 5; alltypes.rep_sfixed32  = rep_sfixed32;
+    alltypes.rep_float_count    = 5; alltypes.rep_float     = rep_float;
+    alltypes.rep_fixed64_count  = 5; alltypes.rep_fixed64   = rep_fixed64;
+    alltypes.rep_sfixed64_count = 5; alltypes.rep_sfixed64  = rep_sfixed64;
+    alltypes.rep_double_count   = 5; alltypes.rep_double    = rep_double;
+    alltypes.rep_string_count   = 5; alltypes.rep_string    = rep_string;
+    alltypes.rep_bytes_count    = 5; alltypes.rep_bytes     = rep_bytes;
+    alltypes.rep_submsg_count   = 5; alltypes.rep_submsg    = rep_submsg;
+    alltypes.rep_enum_count     = 5; alltypes.rep_enum      = rep_enum;
+    alltypes.rep_emptymsg_count = 5; alltypes.rep_emptymsg  = rep_emptymsg;
+    
+    if (mode != 0)
+    {
+        /* Fill in values for optional fields */
+        alltypes.opt_int32         = &opt_int32;
+        alltypes.opt_int64         = &opt_int64;
+        alltypes.opt_uint32        = &opt_uint32;
+        alltypes.opt_uint64        = &opt_uint64;
+        alltypes.opt_sint32        = &opt_sint32;
+        alltypes.opt_sint64        = &opt_sint64;
+        alltypes.opt_bool          = &opt_bool;
+        alltypes.opt_fixed32       = &opt_fixed32;
+        alltypes.opt_sfixed32      = &opt_sfixed32;
+        alltypes.opt_float         = &opt_float;
+        alltypes.opt_fixed64       = &opt_fixed64;
+        alltypes.opt_sfixed64      = &opt_sfixed64;
+        alltypes.opt_double        = &opt_double;
+        alltypes.opt_string        = opt_string;
+        alltypes.opt_bytes         = (pb_bytes_array_t*)&opt_bytes;
+        alltypes.opt_submsg        = &opt_submsg;
+        alltypes.opt_enum          = &opt_enum;
+        alltypes.opt_emptymsg      = &opt_emptymsg;
+
+        alltypes.which_oneof = AllTypes_oneof_msg1_tag;
+        alltypes.oneof.oneof_msg1 = &oneof_msg1;
+    }
+    
+    alltypes.end = &end;
+    
+    {
+        uint8_t buffer[4096];
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        /* Now encode it and check if we succeeded. */
+        if (pb_encode(&stream, AllTypes_fields, &alltypes))
+        {
+            SET_BINARY_MODE(stdout);
+            fwrite(buffer, 1, stream.bytes_written, stdout);
+            return 0; /* Success */
+        }
+        else
+        {
+            fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+            return 1; /* Failure */
+        }
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/anonymous_oneof/SConscript
@@ -0,0 +1,30 @@
+# Test anonymous_oneof generator option
+
+Import('env')
+
+import re
+
+match = None
+if 'PROTOC_VERSION' in env:
+    match = re.search('([0-9]+).([0-9]+).([0-9]+)', env['PROTOC_VERSION'])
+
+if match:
+    version = map(int, match.groups())
+
+# Oneof is supported by protoc >= 2.6.0
+if env.GetOption('clean') or (match and (version[0] > 2 or (version[0] == 2 and version[1] >= 6))):
+    # Anonymous oneofs are supported by clang and gcc
+    if 'clang' in env['CC'] or 'gcc' in env['CC']:
+        env2 = env.Clone()
+        if '-pedantic' in env2['CFLAGS']:
+            env2['CFLAGS'].remove('-pedantic')
+        env2.NanopbProto('oneof')
+
+        dec = env2.Program(['decode_oneof.c',
+                            'oneof.pb.c',
+                            '$COMMON/pb_decode.o',
+                            '$COMMON/pb_common.o'])
+
+        env2.RunTest("message1.txt", [dec, '$BUILD/oneof/message1.pb'], ARGS = ['1'])
+        env2.RunTest("message2.txt", [dec, '$BUILD/oneof/message2.pb'], ARGS = ['2'])
+        env2.RunTest("message3.txt", [dec, '$BUILD/oneof/message3.pb'], ARGS = ['3'])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/anonymous_oneof/decode_oneof.c
@@ -0,0 +1,88 @@
+/* Decode a message using oneof fields */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_decode.h>
+#include "oneof.pb.h"
+#include "test_helpers.h"
+#include "unittests.h"
+
+/* Test the 'AnonymousOneOfMessage' */
+int test_oneof_1(pb_istream_t *stream, int option)
+{
+    AnonymousOneOfMessage msg;
+    int status = 0;
+
+    /* To better catch initialization errors */
+    memset(&msg, 0xAA, sizeof(msg));
+
+    if (!pb_decode(stream, AnonymousOneOfMessage_fields, &msg))
+    {
+        printf("Decoding failed: %s\n", PB_GET_ERROR(stream));
+        return 1;
+    }
+
+    /* Check that the basic fields work normally */
+    TEST(msg.prefix == 123);
+    TEST(msg.suffix == 321);
+
+    /* Check that we got the right oneof according to command line */
+    if (option == 1)
+    {
+        TEST(msg.which_values == AnonymousOneOfMessage_first_tag);
+        TEST(msg.first == 999);
+    }
+    else if (option == 2)
+    {
+        TEST(msg.which_values == AnonymousOneOfMessage_second_tag);
+        TEST(strcmp(msg.second, "abcd") == 0);
+    }
+    else if (option == 3)
+    {
+        TEST(msg.which_values == AnonymousOneOfMessage_third_tag);
+        TEST(msg.third.array[0] == 1);
+        TEST(msg.third.array[1] == 2);
+        TEST(msg.third.array[2] == 3);
+        TEST(msg.third.array[3] == 4);
+        TEST(msg.third.array[4] == 5);
+    }
+
+    return status;
+}
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[AnonymousOneOfMessage_size];
+    size_t count;
+    int option;
+
+    if (argc != 2)
+    {
+        fprintf(stderr, "Usage: decode_oneof [number]\n");
+        return 1;
+    }
+    option = atoi(argv[1]);
+
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+
+    if (!feof(stdin))
+    {
+        printf("Message does not fit in buffer\n");
+        return 1;
+    }
+
+    {
+        int status = 0;
+        pb_istream_t stream;
+
+        stream = pb_istream_from_buffer(buffer, count);
+        status = test_oneof_1(&stream, option);
+
+        if (status != 0)
+            return status;
+    }
+
+    return 0;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/anonymous_oneof/oneof.proto
@@ -0,0 +1,23 @@
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+message SubMessage
+{
+    repeated int32 array = 1 [(nanopb).max_count = 8];
+}
+
+/* Oneof in a message with other fields */
+message AnonymousOneOfMessage
+{
+    option (nanopb_msgopt).anonymous_oneof = true;
+    required int32 prefix = 1;
+    oneof values
+    {
+        int32 first = 5;
+        string second = 6 [(nanopb).max_size = 8];
+        SubMessage third = 7;
+    }
+    required int32 suffix = 99;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/SConscript
@@ -0,0 +1,11 @@
+# Check that the old generated .pb.c/.pb.h files are still compatible with the
+# current version of nanopb.
+
+Import("env")
+
+enc = env.Program(["encode_legacy.c", "alltypes_legacy.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = env.Program(["decode_legacy.c", "alltypes_legacy.c", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_legacy.output"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/alltypes_legacy.c
@@ -0,0 +1,153 @@
+/* Automatically generated nanopb constant definitions */
+/* Generated by nanopb-0.3.0-dev at Tue Aug 19 17:53:24 2014. */
+
+#include "alltypes_legacy.h"
+
+#if PB_PROTO_HEADER_VERSION != 30
+#error Regenerate this file with the current version of nanopb generator.
+#endif
+
+const char SubMessage_substuff1_default[16] = "1";
+const int32_t SubMessage_substuff2_default = 2;
+const uint32_t SubMessage_substuff3_default = 3u;
+const int32_t Limits_int32_min_default = 2147483647;
+const int32_t Limits_int32_max_default = -2147483647;
+const uint32_t Limits_uint32_min_default = 4294967295u;
+const uint32_t Limits_uint32_max_default = 0u;
+const int64_t Limits_int64_min_default = 9223372036854775807ll;
+const int64_t Limits_int64_max_default = -9223372036854775807ll;
+const uint64_t Limits_uint64_min_default = 18446744073709551615ull;
+const uint64_t Limits_uint64_max_default = 0ull;
+const HugeEnum Limits_enum_min_default = HugeEnum_Positive;
+const HugeEnum Limits_enum_max_default = HugeEnum_Negative;
+const int32_t AllTypes_opt_int32_default = 4041;
+const int64_t AllTypes_opt_int64_default = 4042ll;
+const uint32_t AllTypes_opt_uint32_default = 4043u;
+const uint64_t AllTypes_opt_uint64_default = 4044ull;
+const int32_t AllTypes_opt_sint32_default = 4045;
+const int64_t AllTypes_opt_sint64_default = 4046;
+const bool AllTypes_opt_bool_default = false;
+const uint32_t AllTypes_opt_fixed32_default = 4048u;
+const int32_t AllTypes_opt_sfixed32_default = 4049;
+const float AllTypes_opt_float_default = 4050;
+const uint64_t AllTypes_opt_fixed64_default = 4051ull;
+const int64_t AllTypes_opt_sfixed64_default = 4052ll;
+const double AllTypes_opt_double_default = 4053;
+const char AllTypes_opt_string_default[16] = "4054";
+const AllTypes_opt_bytes_t AllTypes_opt_bytes_default = {4, {0x34,0x30,0x35,0x35}};
+const MyEnum AllTypes_opt_enum_default = MyEnum_Second;
+
+
+const pb_field_t SubMessage_fields[4] = {
+    PB_FIELD(  1, STRING  , REQUIRED, STATIC  , FIRST, SubMessage, substuff1, substuff1, &SubMessage_substuff1_default),
+    PB_FIELD(  2, INT32   , REQUIRED, STATIC  , OTHER, SubMessage, substuff2, substuff1, &SubMessage_substuff2_default),
+    PB_FIELD(  3, FIXED32 , OPTIONAL, STATIC  , OTHER, SubMessage, substuff3, substuff2, &SubMessage_substuff3_default),
+    PB_LAST_FIELD
+};
+
+const pb_field_t EmptyMessage_fields[1] = {
+    PB_LAST_FIELD
+};
+
+const pb_field_t Limits_fields[11] = {
+    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, Limits, int32_min, int32_min, &Limits_int32_min_default),
+    PB_FIELD(  2, INT32   , REQUIRED, STATIC  , OTHER, Limits, int32_max, int32_min, &Limits_int32_max_default),
+    PB_FIELD(  3, UINT32  , REQUIRED, STATIC  , OTHER, Limits, uint32_min, int32_max, &Limits_uint32_min_default),
+    PB_FIELD(  4, UINT32  , REQUIRED, STATIC  , OTHER, Limits, uint32_max, uint32_min, &Limits_uint32_max_default),
+    PB_FIELD(  5, INT64   , REQUIRED, STATIC  , OTHER, Limits, int64_min, uint32_max, &Limits_int64_min_default),
+    PB_FIELD(  6, INT64   , REQUIRED, STATIC  , OTHER, Limits, int64_max, int64_min, &Limits_int64_max_default),
+    PB_FIELD(  7, UINT64  , REQUIRED, STATIC  , OTHER, Limits, uint64_min, int64_max, &Limits_uint64_min_default),
+    PB_FIELD(  8, UINT64  , REQUIRED, STATIC  , OTHER, Limits, uint64_max, uint64_min, &Limits_uint64_max_default),
+    PB_FIELD(  9, ENUM    , REQUIRED, STATIC  , OTHER, Limits, enum_min, uint64_max, &Limits_enum_min_default),
+    PB_FIELD( 10, ENUM    , REQUIRED, STATIC  , OTHER, Limits, enum_max, enum_min, &Limits_enum_max_default),
+    PB_LAST_FIELD
+};
+
+const pb_field_t AllTypes_fields[54] = {
+    PB_FIELD(  1, INT32   , REQUIRED, STATIC  , FIRST, AllTypes, req_int32, req_int32, 0),
+    PB_FIELD(  2, INT64   , REQUIRED, STATIC  , OTHER, AllTypes, req_int64, req_int32, 0),
+    PB_FIELD(  3, UINT32  , REQUIRED, STATIC  , OTHER, AllTypes, req_uint32, req_int64, 0),
+    PB_FIELD(  4, UINT64  , REQUIRED, STATIC  , OTHER, AllTypes, req_uint64, req_uint32, 0),
+    PB_FIELD(  5, SINT32  , REQUIRED, STATIC  , OTHER, AllTypes, req_sint32, req_uint64, 0),
+    PB_FIELD(  6, SINT64  , REQUIRED, STATIC  , OTHER, AllTypes, req_sint64, req_sint32, 0),
+    PB_FIELD(  7, BOOL    , REQUIRED, STATIC  , OTHER, AllTypes, req_bool, req_sint64, 0),
+    PB_FIELD(  8, FIXED32 , REQUIRED, STATIC  , OTHER, AllTypes, req_fixed32, req_bool, 0),
+    PB_FIELD(  9, SFIXED32, REQUIRED, STATIC  , OTHER, AllTypes, req_sfixed32, req_fixed32, 0),
+    PB_FIELD( 10, FLOAT   , REQUIRED, STATIC  , OTHER, AllTypes, req_float, req_sfixed32, 0),
+    PB_FIELD( 11, FIXED64 , REQUIRED, STATIC  , OTHER, AllTypes, req_fixed64, req_float, 0),
+    PB_FIELD( 12, SFIXED64, REQUIRED, STATIC  , OTHER, AllTypes, req_sfixed64, req_fixed64, 0),
+    PB_FIELD( 13, DOUBLE  , REQUIRED, STATIC  , OTHER, AllTypes, req_double, req_sfixed64, 0),
+    PB_FIELD( 14, STRING  , REQUIRED, STATIC  , OTHER, AllTypes, req_string, req_double, 0),
+    PB_FIELD( 15, BYTES   , REQUIRED, STATIC  , OTHER, AllTypes, req_bytes, req_string, 0),
+    PB_FIELD( 16, MESSAGE , REQUIRED, STATIC  , OTHER, AllTypes, req_submsg, req_bytes, &SubMessage_fields),
+    PB_FIELD( 17, ENUM    , REQUIRED, STATIC  , OTHER, AllTypes, req_enum, req_submsg, 0),
+    PB_FIELD( 21, INT32   , REPEATED, STATIC  , OTHER, AllTypes, rep_int32, req_enum, 0),
+    PB_FIELD( 22, INT64   , REPEATED, STATIC  , OTHER, AllTypes, rep_int64, rep_int32, 0),
+    PB_FIELD( 23, UINT32  , REPEATED, STATIC  , OTHER, AllTypes, rep_uint32, rep_int64, 0),
+    PB_FIELD( 24, UINT64  , REPEATED, STATIC  , OTHER, AllTypes, rep_uint64, rep_uint32, 0),
+    PB_FIELD( 25, SINT32  , REPEATED, STATIC  , OTHER, AllTypes, rep_sint32, rep_uint64, 0),
+    PB_FIELD( 26, SINT64  , REPEATED, STATIC  , OTHER, AllTypes, rep_sint64, rep_sint32, 0),
+    PB_FIELD( 27, BOOL    , REPEATED, STATIC  , OTHER, AllTypes, rep_bool, rep_sint64, 0),
+    PB_FIELD( 28, FIXED32 , REPEATED, STATIC  , OTHER, AllTypes, rep_fixed32, rep_bool, 0),
+    PB_FIELD( 29, SFIXED32, REPEATED, STATIC  , OTHER, AllTypes, rep_sfixed32, rep_fixed32, 0),
+    PB_FIELD( 30, FLOAT   , REPEATED, STATIC  , OTHER, AllTypes, rep_float, rep_sfixed32, 0),
+    PB_FIELD( 31, FIXED64 , REPEATED, STATIC  , OTHER, AllTypes, rep_fixed64, rep_float, 0),
+    PB_FIELD( 32, SFIXED64, REPEATED, STATIC  , OTHER, AllTypes, rep_sfixed64, rep_fixed64, 0),
+    PB_FIELD( 33, DOUBLE  , REPEATED, STATIC  , OTHER, AllTypes, rep_double, rep_sfixed64, 0),
+    PB_FIELD( 34, STRING  , REPEATED, STATIC  , OTHER, AllTypes, rep_string, rep_double, 0),
+    PB_FIELD( 35, BYTES   , REPEATED, STATIC  , OTHER, AllTypes, rep_bytes, rep_string, 0),
+    PB_FIELD( 36, MESSAGE , REPEATED, STATIC  , OTHER, AllTypes, rep_submsg, rep_bytes, &SubMessage_fields),
+    PB_FIELD( 37, ENUM    , REPEATED, STATIC  , OTHER, AllTypes, rep_enum, rep_submsg, 0),
+    PB_FIELD( 41, INT32   , OPTIONAL, STATIC  , OTHER, AllTypes, opt_int32, rep_enum, &AllTypes_opt_int32_default),
+    PB_FIELD( 42, INT64   , OPTIONAL, STATIC  , OTHER, AllTypes, opt_int64, opt_int32, &AllTypes_opt_int64_default),
+    PB_FIELD( 43, UINT32  , OPTIONAL, STATIC  , OTHER, AllTypes, opt_uint32, opt_int64, &AllTypes_opt_uint32_default),
+    PB_FIELD( 44, UINT64  , OPTIONAL, STATIC  , OTHER, AllTypes, opt_uint64, opt_uint32, &AllTypes_opt_uint64_default),
+    PB_FIELD( 45, SINT32  , OPTIONAL, STATIC  , OTHER, AllTypes, opt_sint32, opt_uint64, &AllTypes_opt_sint32_default),
+    PB_FIELD( 46, SINT64  , OPTIONAL, STATIC  , OTHER, AllTypes, opt_sint64, opt_sint32, &AllTypes_opt_sint64_default),
+    PB_FIELD( 47, BOOL    , OPTIONAL, STATIC  , OTHER, AllTypes, opt_bool, opt_sint64, &AllTypes_opt_bool_default),
+    PB_FIELD( 48, FIXED32 , OPTIONAL, STATIC  , OTHER, AllTypes, opt_fixed32, opt_bool, &AllTypes_opt_fixed32_default),
+    PB_FIELD( 49, SFIXED32, OPTIONAL, STATIC  , OTHER, AllTypes, opt_sfixed32, opt_fixed32, &AllTypes_opt_sfixed32_default),
+    PB_FIELD( 50, FLOAT   , OPTIONAL, STATIC  , OTHER, AllTypes, opt_float, opt_sfixed32, &AllTypes_opt_float_default),
+    PB_FIELD( 51, FIXED64 , OPTIONAL, STATIC  , OTHER, AllTypes, opt_fixed64, opt_float, &AllTypes_opt_fixed64_default),
+    PB_FIELD( 52, SFIXED64, OPTIONAL, STATIC  , OTHER, AllTypes, opt_sfixed64, opt_fixed64, &AllTypes_opt_sfixed64_default),
+    PB_FIELD( 53, DOUBLE  , OPTIONAL, STATIC  , OTHER, AllTypes, opt_double, opt_sfixed64, &AllTypes_opt_double_default),
+    PB_FIELD( 54, STRING  , OPTIONAL, STATIC  , OTHER, AllTypes, opt_string, opt_double, &AllTypes_opt_string_default),
+    PB_FIELD( 55, BYTES   , OPTIONAL, STATIC  , OTHER, AllTypes, opt_bytes, opt_string, &AllTypes_opt_bytes_default),
+    PB_FIELD( 56, MESSAGE , OPTIONAL, STATIC  , OTHER, AllTypes, opt_submsg, opt_bytes, &SubMessage_fields),
+    PB_FIELD( 57, ENUM    , OPTIONAL, STATIC  , OTHER, AllTypes, opt_enum, opt_submsg, &AllTypes_opt_enum_default),
+    PB_FIELD( 99, INT32   , REQUIRED, STATIC  , OTHER, AllTypes, end, opt_enum, 0),
+    PB_FIELD(200, EXTENSION, OPTIONAL, CALLBACK, OTHER, AllTypes, extensions, end, 0),
+    PB_LAST_FIELD
+};
+
+
+/* Check that field information fits in pb_field_t */
+#if !defined(PB_FIELD_32BIT)
+/* If you get an error here, it means that you need to define PB_FIELD_32BIT
+ * compile-time option. You can do that in pb.h or on compiler command line.
+ * 
+ * The reason you need to do this is that some of your messages contain tag
+ * numbers or field sizes that are larger than what can fit in 8 or 16 bit
+ * field descriptors.
+ */
+PB_STATIC_ASSERT((pb_membersize(AllTypes, req_submsg) < 65536 && pb_membersize(AllTypes, rep_submsg[0]) < 65536 && pb_membersize(AllTypes, opt_submsg) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_SubMessage_EmptyMessage_Limits_AllTypes)
+#endif
+
+#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
+/* If you get an error here, it means that you need to define PB_FIELD_16BIT
+ * compile-time option. You can do that in pb.h or on compiler command line.
+ * 
+ * The reason you need to do this is that some of your messages contain tag
+ * numbers or field sizes that are larger than what can fit in the default
+ * 8 bit descriptors.
+ */
+PB_STATIC_ASSERT((pb_membersize(AllTypes, req_submsg) < 256 && pb_membersize(AllTypes, rep_submsg[0]) < 256 && pb_membersize(AllTypes, opt_submsg) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_SubMessage_EmptyMessage_Limits_AllTypes)
+#endif
+
+
+/* On some platforms (such as AVR), double is really float.
+ * These are not directly supported by nanopb, but see example_avr_double.
+ * To get rid of this error, remove any double fields from your .proto.
+ */
+PB_STATIC_ASSERT(sizeof(double) == 8, DOUBLE_MUST_BE_8_BYTES)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/alltypes_legacy.h
@@ -0,0 +1,274 @@
+/* Automatically generated nanopb header */
+/* Generated by nanopb-0.3.0-dev at Tue Aug 19 17:53:24 2014. */
+
+#ifndef PB_ALLTYPES_LEGACY_H_INCLUDED
+#define PB_ALLTYPES_LEGACY_H_INCLUDED
+#include <pb.h>
+
+#if PB_PROTO_HEADER_VERSION != 30
+#error Regenerate this file with the current version of nanopb generator.
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Enum definitions */
+typedef enum _HugeEnum {
+    HugeEnum_Negative = -2147483647,
+    HugeEnum_Positive = 2147483647
+} HugeEnum;
+
+typedef enum _MyEnum {
+    MyEnum_Zero = 0,
+    MyEnum_First = 1,
+    MyEnum_Second = 2,
+    MyEnum_Truth = 42
+} MyEnum;
+
+/* Struct definitions */
+typedef struct _EmptyMessage {
+    uint8_t dummy_field;
+} EmptyMessage;
+
+typedef struct _Limits {
+    int32_t int32_min;
+    int32_t int32_max;
+    uint32_t uint32_min;
+    uint32_t uint32_max;
+    int64_t int64_min;
+    int64_t int64_max;
+    uint64_t uint64_min;
+    uint64_t uint64_max;
+    HugeEnum enum_min;
+    HugeEnum enum_max;
+} Limits;
+
+typedef struct _SubMessage {
+    char substuff1[16];
+    int32_t substuff2;
+    bool has_substuff3;
+    uint32_t substuff3;
+} SubMessage;
+
+typedef PB_BYTES_ARRAY_T(16) AllTypes_req_bytes_t;
+
+typedef PB_BYTES_ARRAY_T(16) AllTypes_rep_bytes_t;
+
+typedef PB_BYTES_ARRAY_T(16) AllTypes_opt_bytes_t;
+
+typedef struct _AllTypes {
+    int32_t req_int32;
+    int64_t req_int64;
+    uint32_t req_uint32;
+    uint64_t req_uint64;
+    int32_t req_sint32;
+    int64_t req_sint64;
+    bool req_bool;
+    uint32_t req_fixed32;
+    int32_t req_sfixed32;
+    float req_float;
+    uint64_t req_fixed64;
+    int64_t req_sfixed64;
+    double req_double;
+    char req_string[16];
+    AllTypes_req_bytes_t req_bytes;
+    SubMessage req_submsg;
+    MyEnum req_enum;
+    pb_size_t rep_int32_count;
+    int32_t rep_int32[5];
+    pb_size_t rep_int64_count;
+    int64_t rep_int64[5];
+    pb_size_t rep_uint32_count;
+    uint32_t rep_uint32[5];
+    pb_size_t rep_uint64_count;
+    uint64_t rep_uint64[5];
+    pb_size_t rep_sint32_count;
+    int32_t rep_sint32[5];
+    pb_size_t rep_sint64_count;
+    int64_t rep_sint64[5];
+    pb_size_t rep_bool_count;
+    bool rep_bool[5];
+    pb_size_t rep_fixed32_count;
+    uint32_t rep_fixed32[5];
+    pb_size_t rep_sfixed32_count;
+    int32_t rep_sfixed32[5];
+    pb_size_t rep_float_count;
+    float rep_float[5];
+    pb_size_t rep_fixed64_count;
+    uint64_t rep_fixed64[5];
+    pb_size_t rep_sfixed64_count;
+    int64_t rep_sfixed64[5];
+    pb_size_t rep_double_count;
+    double rep_double[5];
+    pb_size_t rep_string_count;
+    char rep_string[5][16];
+    pb_size_t rep_bytes_count;
+    AllTypes_rep_bytes_t rep_bytes[5];
+    pb_size_t rep_submsg_count;
+    SubMessage rep_submsg[5];
+    pb_size_t rep_enum_count;
+    MyEnum rep_enum[5];
+    bool has_opt_int32;
+    int32_t opt_int32;
+    bool has_opt_int64;
+    int64_t opt_int64;
+    bool has_opt_uint32;
+    uint32_t opt_uint32;
+    bool has_opt_uint64;
+    uint64_t opt_uint64;
+    bool has_opt_sint32;
+    int32_t opt_sint32;
+    bool has_opt_sint64;
+    int64_t opt_sint64;
+    bool has_opt_bool;
+    bool opt_bool;
+    bool has_opt_fixed32;
+    uint32_t opt_fixed32;
+    bool has_opt_sfixed32;
+    int32_t opt_sfixed32;
+    bool has_opt_float;
+    float opt_float;
+    bool has_opt_fixed64;
+    uint64_t opt_fixed64;
+    bool has_opt_sfixed64;
+    int64_t opt_sfixed64;
+    bool has_opt_double;
+    double opt_double;
+    bool has_opt_string;
+    char opt_string[16];
+    bool has_opt_bytes;
+    AllTypes_opt_bytes_t opt_bytes;
+    bool has_opt_submsg;
+    SubMessage opt_submsg;
+    bool has_opt_enum;
+    MyEnum opt_enum;
+    int32_t end;
+    pb_extension_t *extensions;
+} AllTypes;
+
+/* Default values for struct fields */
+extern const char SubMessage_substuff1_default[16];
+extern const int32_t SubMessage_substuff2_default;
+extern const uint32_t SubMessage_substuff3_default;
+extern const int32_t Limits_int32_min_default;
+extern const int32_t Limits_int32_max_default;
+extern const uint32_t Limits_uint32_min_default;
+extern const uint32_t Limits_uint32_max_default;
+extern const int64_t Limits_int64_min_default;
+extern const int64_t Limits_int64_max_default;
+extern const uint64_t Limits_uint64_min_default;
+extern const uint64_t Limits_uint64_max_default;
+extern const HugeEnum Limits_enum_min_default;
+extern const HugeEnum Limits_enum_max_default;
+extern const int32_t AllTypes_opt_int32_default;
+extern const int64_t AllTypes_opt_int64_default;
+extern const uint32_t AllTypes_opt_uint32_default;
+extern const uint64_t AllTypes_opt_uint64_default;
+extern const int32_t AllTypes_opt_sint32_default;
+extern const int64_t AllTypes_opt_sint64_default;
+extern const bool AllTypes_opt_bool_default;
+extern const uint32_t AllTypes_opt_fixed32_default;
+extern const int32_t AllTypes_opt_sfixed32_default;
+extern const float AllTypes_opt_float_default;
+extern const uint64_t AllTypes_opt_fixed64_default;
+extern const int64_t AllTypes_opt_sfixed64_default;
+extern const double AllTypes_opt_double_default;
+extern const char AllTypes_opt_string_default[16];
+extern const AllTypes_opt_bytes_t AllTypes_opt_bytes_default;
+extern const MyEnum AllTypes_opt_enum_default;
+
+/* Initializer values for message structs */
+#define SubMessage_init_default                  {"1", 2, false, 3u}
+#define EmptyMessage_init_default                {0}
+#define Limits_init_default                      {2147483647, -2147483647, 4294967295u, 0u, 9223372036854775807ll, -9223372036854775807ll, 18446744073709551615ull, 0ull, HugeEnum_Positive, HugeEnum_Negative}
+#define AllTypes_init_default                    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", {0, {0}}, SubMessage_init_default, (MyEnum)0, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {"", "", "", "", ""}, 0, {{0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}}, 0, {SubMessage_init_default, SubMessage_init_default, SubMessage_init_default, SubMessage_init_default, SubMessage_init_default}, 0, {(MyEnum)0, (MyEnum)0, (MyEnum)0, (MyEnum)0, (MyEnum)0}, false, 4041, false, 4042ll, false, 4043u, false, 4044ull, false, 4045, false, 4046, false, false, false, 4048u, false, 4049, false, 4050, false, 4051ull, false, 4052ll, false, 4053, false, "4054", false, {4, {0x34,0x30,0x35,0x35}}, false, SubMessage_init_default, false, MyEnum_Second, 0, NULL}
+#define SubMessage_init_zero                     {"", 0, false, 0}
+#define EmptyMessage_init_zero                   {0}
+#define Limits_init_zero                         {0, 0, 0, 0, 0, 0, 0, 0, (HugeEnum)0, (HugeEnum)0}
+#define AllTypes_init_zero                       {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", {0, {0}}, SubMessage_init_zero, (MyEnum)0, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {0, 0, 0, 0, 0}, 0, {"", "", "", "", ""}, 0, {{0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}, {0, {0}}}, 0, {SubMessage_init_zero, SubMessage_init_zero, SubMessage_init_zero, SubMessage_init_zero, SubMessage_init_zero}, 0, {(MyEnum)0, (MyEnum)0, (MyEnum)0, (MyEnum)0, (MyEnum)0}, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, 0, false, "", false, {0, {0}}, false, SubMessage_init_zero, false, (MyEnum)0, 0, NULL}
+
+/* Field tags (for use in manual encoding/decoding) */
+#define Limits_int32_min_tag                     1
+#define Limits_int32_max_tag                     2
+#define Limits_uint32_min_tag                    3
+#define Limits_uint32_max_tag                    4
+#define Limits_int64_min_tag                     5
+#define Limits_int64_max_tag                     6
+#define Limits_uint64_min_tag                    7
+#define Limits_uint64_max_tag                    8
+#define Limits_enum_min_tag                      9
+#define Limits_enum_max_tag                      10
+#define SubMessage_substuff1_tag                 1
+#define SubMessage_substuff2_tag                 2
+#define SubMessage_substuff3_tag                 3
+#define AllTypes_req_int32_tag                   1
+#define AllTypes_req_int64_tag                   2
+#define AllTypes_req_uint32_tag                  3
+#define AllTypes_req_uint64_tag                  4
+#define AllTypes_req_sint32_tag                  5
+#define AllTypes_req_sint64_tag                  6
+#define AllTypes_req_bool_tag                    7
+#define AllTypes_req_fixed32_tag                 8
+#define AllTypes_req_sfixed32_tag                9
+#define AllTypes_req_float_tag                   10
+#define AllTypes_req_fixed64_tag                 11
+#define AllTypes_req_sfixed64_tag                12
+#define AllTypes_req_double_tag                  13
+#define AllTypes_req_string_tag                  14
+#define AllTypes_req_bytes_tag                   15
+#define AllTypes_req_submsg_tag                  16
+#define AllTypes_req_enum_tag                    17
+#define AllTypes_rep_int32_tag                   21
+#define AllTypes_rep_int64_tag                   22
+#define AllTypes_rep_uint32_tag                  23
+#define AllTypes_rep_uint64_tag                  24
+#define AllTypes_rep_sint32_tag                  25
+#define AllTypes_rep_sint64_tag                  26
+#define AllTypes_rep_bool_tag                    27
+#define AllTypes_rep_fixed32_tag                 28
+#define AllTypes_rep_sfixed32_tag                29
+#define AllTypes_rep_float_tag                   30
+#define AllTypes_rep_fixed64_tag                 31
+#define AllTypes_rep_sfixed64_tag                32
+#define AllTypes_rep_double_tag                  33
+#define AllTypes_rep_string_tag                  34
+#define AllTypes_rep_bytes_tag                   35
+#define AllTypes_rep_submsg_tag                  36
+#define AllTypes_rep_enum_tag                    37
+#define AllTypes_opt_int32_tag                   41
+#define AllTypes_opt_int64_tag                   42
+#define AllTypes_opt_uint32_tag                  43
+#define AllTypes_opt_uint64_tag                  44
+#define AllTypes_opt_sint32_tag                  45
+#define AllTypes_opt_sint64_tag                  46
+#define AllTypes_opt_bool_tag                    47
+#define AllTypes_opt_fixed32_tag                 48
+#define AllTypes_opt_sfixed32_tag                49
+#define AllTypes_opt_float_tag                   50
+#define AllTypes_opt_fixed64_tag                 51
+#define AllTypes_opt_sfixed64_tag                52
+#define AllTypes_opt_double_tag                  53
+#define AllTypes_opt_string_tag                  54
+#define AllTypes_opt_bytes_tag                   55
+#define AllTypes_opt_submsg_tag                  56
+#define AllTypes_opt_enum_tag                    57
+#define AllTypes_end_tag                         99
+
+/* Struct field encoding specification for nanopb */
+extern const pb_field_t SubMessage_fields[4];
+extern const pb_field_t EmptyMessage_fields[1];
+extern const pb_field_t Limits_fields[11];
+extern const pb_field_t AllTypes_fields[54];
+
+/* Maximum encoded size of messages (where known) */
+#define SubMessage_size                          34
+#define EmptyMessage_size                        0
+#define Limits_size                              90
+#define AllTypes_size                            1362
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/alltypes_legacy.options
@@ -0,0 +1,3 @@
+* max_size:16
+* max_count:5
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/alltypes_legacy.proto
@@ -0,0 +1,110 @@
+syntax = "proto2";
+
+message SubMessage {
+    required string substuff1 = 1 [default = "1"];
+    required int32 substuff2 = 2 [default = 2];
+    optional fixed32 substuff3 = 3 [default = 3];
+}
+
+message EmptyMessage {
+
+}
+
+enum HugeEnum {
+    Negative = -2147483647; /* protoc doesn't accept -2147483648 here */
+    Positive =  2147483647;
+}
+
+message Limits {
+    required int32      int32_min  =  1 [default = 2147483647];
+    required int32      int32_max  =  2 [default = -2147483647];
+    required uint32     uint32_min =  3 [default = 4294967295];
+    required uint32     uint32_max =  4 [default = 0];
+    required int64      int64_min  =  5 [default = 9223372036854775807];
+    required int64      int64_max  =  6 [default = -9223372036854775807];
+    required uint64     uint64_min =  7 [default = 18446744073709551615];
+    required uint64     uint64_max =  8 [default = 0];
+    required HugeEnum   enum_min   =  9 [default = Positive];
+    required HugeEnum   enum_max   = 10 [default = Negative];
+}
+
+enum MyEnum {
+    Zero = 0;
+    First = 1;
+    Second = 2;
+    Truth = 42;
+}
+
+message AllTypes {
+    required int32      req_int32   = 1;
+    required int64      req_int64   = 2;
+    required uint32     req_uint32  = 3;
+    required uint64     req_uint64  = 4;
+    required sint32     req_sint32  = 5;
+    required sint64     req_sint64  = 6;
+    required bool       req_bool    = 7;
+    
+    required fixed32    req_fixed32 = 8;
+    required sfixed32   req_sfixed32= 9;
+    required float      req_float   = 10;
+    
+    required fixed64    req_fixed64 = 11;
+    required sfixed64   req_sfixed64= 12;
+    required double     req_double  = 13;
+    
+    required string     req_string  = 14;
+    required bytes      req_bytes   = 15;
+    required SubMessage req_submsg  = 16;
+    required MyEnum     req_enum    = 17;
+    
+    
+    repeated int32      rep_int32   = 21 [packed = true];
+    repeated int64      rep_int64   = 22 [packed = true];
+    repeated uint32     rep_uint32  = 23 [packed = true];
+    repeated uint64     rep_uint64  = 24 [packed = true];
+    repeated sint32     rep_sint32  = 25 [packed = true];
+    repeated sint64     rep_sint64  = 26 [packed = true];
+    repeated bool       rep_bool    = 27 [packed = true];
+    
+    repeated fixed32    rep_fixed32 = 28 [packed = true];
+    repeated sfixed32   rep_sfixed32= 29 [packed = true];
+    repeated float      rep_float   = 30 [packed = true];
+    
+    repeated fixed64    rep_fixed64 = 31 [packed = true];
+    repeated sfixed64   rep_sfixed64= 32 [packed = true];
+    repeated double     rep_double  = 33 [packed = true];
+    
+    repeated string     rep_string  = 34;
+    repeated bytes      rep_bytes   = 35;
+    repeated SubMessage rep_submsg  = 36;
+    repeated MyEnum     rep_enum    = 37 [packed = true];
+    
+    optional int32      opt_int32   = 41 [default = 4041];
+    optional int64      opt_int64   = 42 [default = 4042];
+    optional uint32     opt_uint32  = 43 [default = 4043];
+    optional uint64     opt_uint64  = 44 [default = 4044];
+    optional sint32     opt_sint32  = 45 [default = 4045];
+    optional sint64     opt_sint64  = 46 [default = 4046];
+    optional bool       opt_bool    = 47 [default = false];
+    
+    optional fixed32    opt_fixed32 = 48 [default = 4048];
+    optional sfixed32   opt_sfixed32= 49 [default = 4049];
+    optional float      opt_float   = 50 [default = 4050];
+    
+    optional fixed64    opt_fixed64 = 51 [default = 4051];
+    optional sfixed64   opt_sfixed64= 52 [default = 4052];
+    optional double     opt_double  = 53 [default = 4053];
+    
+    optional string     opt_string  = 54 [default = "4054"];
+    optional bytes      opt_bytes   = 55 [default = "4055"];
+    optional SubMessage opt_submsg  = 56;
+    optional MyEnum     opt_enum    = 57 [default = Second];
+
+    // Just to make sure that the size of the fields has been calculated
+    // properly, i.e. otherwise a bug in last field might not be detected.
+    required int32      end = 99;
+
+
+    extensions 200 to 255;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/decode_legacy.c
@@ -0,0 +1,199 @@
+/* Tests the decoding of all types.
+ * This is a backwards-compatibility test, using alltypes_legacy.h.
+ * It is similar to decode_alltypes, but duplicated in order to allow
+ * decode_alltypes to test any new features introduced later.
+ *
+ * Run e.g. ./encode_legacy | ./decode_legacy
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pb_decode.h>
+#include "alltypes_legacy.h"
+#include "test_helpers.h"
+
+#define TEST(x) if (!(x)) { \
+    printf("Test " #x " failed.\n"); \
+    return false; \
+    }
+
+/* This function is called once from main(), it handles
+   the decoding and checks the fields. */
+bool check_alltypes(pb_istream_t *stream, int mode)
+{
+    AllTypes alltypes = {0};
+    
+    if (!pb_decode(stream, AllTypes_fields, &alltypes))
+        return false;
+    
+    TEST(alltypes.req_int32         == -1001);
+    TEST(alltypes.req_int64         == -1002);
+    TEST(alltypes.req_uint32        == 1003);
+    TEST(alltypes.req_uint64        == 1004);
+    TEST(alltypes.req_sint32        == -1005);
+    TEST(alltypes.req_sint64        == -1006);
+    TEST(alltypes.req_bool          == true);
+    
+    TEST(alltypes.req_fixed32       == 1008);
+    TEST(alltypes.req_sfixed32      == -1009);
+    TEST(alltypes.req_float         == 1010.0f);
+    
+    TEST(alltypes.req_fixed64       == 1011);
+    TEST(alltypes.req_sfixed64      == -1012);
+    TEST(alltypes.req_double        == 1013.0f);
+    
+    TEST(strcmp(alltypes.req_string, "1014") == 0);
+    TEST(alltypes.req_bytes.size == 4);
+    TEST(memcmp(alltypes.req_bytes.bytes, "1015", 4) == 0);
+    TEST(strcmp(alltypes.req_submsg.substuff1, "1016") == 0);
+    TEST(alltypes.req_submsg.substuff2 == 1016);
+    TEST(alltypes.req_submsg.substuff3 == 3);
+    TEST(alltypes.req_enum == MyEnum_Truth);
+    
+    TEST(alltypes.rep_int32_count == 5 && alltypes.rep_int32[4] == -2001 && alltypes.rep_int32[0] == 0);
+    TEST(alltypes.rep_int64_count == 5 && alltypes.rep_int64[4] == -2002 && alltypes.rep_int64[0] == 0);
+    TEST(alltypes.rep_uint32_count == 5 && alltypes.rep_uint32[4] == 2003 && alltypes.rep_uint32[0] == 0);
+    TEST(alltypes.rep_uint64_count == 5 && alltypes.rep_uint64[4] == 2004 && alltypes.rep_uint64[0] == 0);
+    TEST(alltypes.rep_sint32_count == 5 && alltypes.rep_sint32[4] == -2005 && alltypes.rep_sint32[0] == 0);
+    TEST(alltypes.rep_sint64_count == 5 && alltypes.rep_sint64[4] == -2006 && alltypes.rep_sint64[0] == 0);
+    TEST(alltypes.rep_bool_count == 5 && alltypes.rep_bool[4] == true && alltypes.rep_bool[0] == false);
+    
+    TEST(alltypes.rep_fixed32_count == 5 && alltypes.rep_fixed32[4] == 2008 && alltypes.rep_fixed32[0] == 0);
+    TEST(alltypes.rep_sfixed32_count == 5 && alltypes.rep_sfixed32[4] == -2009 && alltypes.rep_sfixed32[0] == 0);
+    TEST(alltypes.rep_float_count == 5 && alltypes.rep_float[4] == 2010.0f && alltypes.rep_float[0] == 0.0f);
+    
+    TEST(alltypes.rep_fixed64_count == 5 && alltypes.rep_fixed64[4] == 2011 && alltypes.rep_fixed64[0] == 0);
+    TEST(alltypes.rep_sfixed64_count == 5 && alltypes.rep_sfixed64[4] == -2012 && alltypes.rep_sfixed64[0] == 0);
+    TEST(alltypes.rep_double_count == 5 && alltypes.rep_double[4] == 2013.0 && alltypes.rep_double[0] == 0.0);
+    
+    TEST(alltypes.rep_string_count == 5 && strcmp(alltypes.rep_string[4], "2014") == 0 && alltypes.rep_string[0][0] == '\0');
+    TEST(alltypes.rep_bytes_count == 5 && alltypes.rep_bytes[4].size == 4 && alltypes.rep_bytes[0].size == 0);
+    TEST(memcmp(alltypes.rep_bytes[4].bytes, "2015", 4) == 0);
+
+    TEST(alltypes.rep_submsg_count == 5);
+    TEST(strcmp(alltypes.rep_submsg[4].substuff1, "2016") == 0 && alltypes.rep_submsg[0].substuff1[0] == '\0');
+    TEST(alltypes.rep_submsg[4].substuff2 == 2016 && alltypes.rep_submsg[0].substuff2 == 0);
+    TEST(alltypes.rep_submsg[4].substuff3 == 2016 && alltypes.rep_submsg[0].substuff3 == 3);
+    
+    TEST(alltypes.rep_enum_count == 5 && alltypes.rep_enum[4] == MyEnum_Truth && alltypes.rep_enum[0] == MyEnum_Zero);
+    
+    if (mode == 0)
+    {
+        /* Expect default values */
+        TEST(alltypes.has_opt_int32     == false);
+        TEST(alltypes.opt_int32         == 4041);
+        TEST(alltypes.has_opt_int64     == false);
+        TEST(alltypes.opt_int64         == 4042);
+        TEST(alltypes.has_opt_uint32    == false);
+        TEST(alltypes.opt_uint32        == 4043);
+        TEST(alltypes.has_opt_uint64    == false);
+        TEST(alltypes.opt_uint64        == 4044);
+        TEST(alltypes.has_opt_sint32    == false);
+        TEST(alltypes.opt_sint32        == 4045);
+        TEST(alltypes.has_opt_sint64    == false);
+        TEST(alltypes.opt_sint64        == 4046);
+        TEST(alltypes.has_opt_bool      == false);
+        TEST(alltypes.opt_bool          == false);
+        
+        TEST(alltypes.has_opt_fixed32   == false);
+        TEST(alltypes.opt_fixed32       == 4048);
+        TEST(alltypes.has_opt_sfixed32  == false);
+        TEST(alltypes.opt_sfixed32      == 4049);
+        TEST(alltypes.has_opt_float     == false);
+        TEST(alltypes.opt_float         == 4050.0f);
+        
+        TEST(alltypes.has_opt_fixed64   == false);
+        TEST(alltypes.opt_fixed64       == 4051);
+        TEST(alltypes.has_opt_sfixed64  == false);
+        TEST(alltypes.opt_sfixed64      == 4052);
+        TEST(alltypes.has_opt_double    == false);
+        TEST(alltypes.opt_double        == 4053.0);
+        
+        TEST(alltypes.has_opt_string    == false);
+        TEST(strcmp(alltypes.opt_string, "4054") == 0);
+        TEST(alltypes.has_opt_bytes     == false);
+        TEST(alltypes.opt_bytes.size == 4);
+        TEST(memcmp(alltypes.opt_bytes.bytes, "4055", 4) == 0);
+        TEST(alltypes.has_opt_submsg    == false);
+        TEST(strcmp(alltypes.opt_submsg.substuff1, "1") == 0);
+        TEST(alltypes.opt_submsg.substuff2 == 2);
+        TEST(alltypes.opt_submsg.substuff3 == 3);
+        TEST(alltypes.has_opt_enum     == false);
+        TEST(alltypes.opt_enum == MyEnum_Second);
+    }
+    else
+    {
+        /* Expect filled-in values */
+        TEST(alltypes.has_opt_int32     == true);
+        TEST(alltypes.opt_int32         == 3041);
+        TEST(alltypes.has_opt_int64     == true);
+        TEST(alltypes.opt_int64         == 3042);
+        TEST(alltypes.has_opt_uint32    == true);
+        TEST(alltypes.opt_uint32        == 3043);
+        TEST(alltypes.has_opt_uint64    == true);
+        TEST(alltypes.opt_uint64        == 3044);
+        TEST(alltypes.has_opt_sint32    == true);
+        TEST(alltypes.opt_sint32        == 3045);
+        TEST(alltypes.has_opt_sint64    == true);
+        TEST(alltypes.opt_sint64        == 3046);
+        TEST(alltypes.has_opt_bool      == true);
+        TEST(alltypes.opt_bool          == true);
+        
+        TEST(alltypes.has_opt_fixed32   == true);
+        TEST(alltypes.opt_fixed32       == 3048);
+        TEST(alltypes.has_opt_sfixed32  == true);
+        TEST(alltypes.opt_sfixed32      == 3049);
+        TEST(alltypes.has_opt_float     == true);
+        TEST(alltypes.opt_float         == 3050.0f);
+        
+        TEST(alltypes.has_opt_fixed64   == true);
+        TEST(alltypes.opt_fixed64       == 3051);
+        TEST(alltypes.has_opt_sfixed64  == true);
+        TEST(alltypes.opt_sfixed64      == 3052);
+        TEST(alltypes.has_opt_double    == true);
+        TEST(alltypes.opt_double        == 3053.0);
+        
+        TEST(alltypes.has_opt_string    == true);
+        TEST(strcmp(alltypes.opt_string, "3054") == 0);
+        TEST(alltypes.has_opt_bytes     == true);
+        TEST(alltypes.opt_bytes.size == 4);
+        TEST(memcmp(alltypes.opt_bytes.bytes, "3055", 4) == 0);
+        TEST(alltypes.has_opt_submsg    == true);
+        TEST(strcmp(alltypes.opt_submsg.substuff1, "3056") == 0);
+        TEST(alltypes.opt_submsg.substuff2 == 3056);
+        TEST(alltypes.opt_submsg.substuff3 == 3);
+        TEST(alltypes.has_opt_enum      == true);
+        TEST(alltypes.opt_enum == MyEnum_Truth);
+    }
+    
+    TEST(alltypes.end == 1099);
+    
+    return true;
+}
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[1024];
+    size_t count;
+    pb_istream_t stream;
+
+    /* Whether to expect the optional values or the default values. */
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Read the data into buffer */
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+    
+    /* Construct a pb_istream_t for reading from the buffer */
+    stream = pb_istream_from_buffer(buffer, count);
+    
+    /* Decode and print out the stuff */
+    if (!check_alltypes(&stream, mode))
+    {
+        printf("Parsing failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    } else {
+        return 0;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/backwards_compatibility/encode_legacy.c
@@ -0,0 +1,135 @@
+/* Attempts to test all the datatypes supported by ProtoBuf.
+ * This is a backwards-compatibility test, using alltypes_legacy.h.
+ * It is similar to encode_alltypes, but duplicated in order to allow
+ * encode_alltypes to test any new features introduced later.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "alltypes_legacy.h"
+#include "test_helpers.h"
+
+int main(int argc, char **argv)
+{
+    int mode = (argc > 1) ? atoi(argv[1]) : 0;
+    
+    /* Initialize the structure with constants */
+    AllTypes alltypes = {0};
+    
+    alltypes.req_int32         = -1001;
+    alltypes.req_int64         = -1002;
+    alltypes.req_uint32        = 1003;
+    alltypes.req_uint64        = 1004;
+    alltypes.req_sint32        = -1005;
+    alltypes.req_sint64        = -1006;
+    alltypes.req_bool          = true;
+    
+    alltypes.req_fixed32       = 1008;
+    alltypes.req_sfixed32      = -1009;
+    alltypes.req_float         = 1010.0f;
+    
+    alltypes.req_fixed64       = 1011;
+    alltypes.req_sfixed64      = -1012;
+    alltypes.req_double        = 1013.0;
+    
+    strcpy(alltypes.req_string, "1014");
+    alltypes.req_bytes.size = 4;
+    memcpy(alltypes.req_bytes.bytes, "1015", 4);
+    strcpy(alltypes.req_submsg.substuff1, "1016");
+    alltypes.req_submsg.substuff2 = 1016;
+    alltypes.req_enum = MyEnum_Truth;
+    
+    alltypes.rep_int32_count = 5; alltypes.rep_int32[4] = -2001;
+    alltypes.rep_int64_count = 5; alltypes.rep_int64[4] = -2002;
+    alltypes.rep_uint32_count = 5; alltypes.rep_uint32[4] = 2003;
+    alltypes.rep_uint64_count = 5; alltypes.rep_uint64[4] = 2004;
+    alltypes.rep_sint32_count = 5; alltypes.rep_sint32[4] = -2005;
+    alltypes.rep_sint64_count = 5; alltypes.rep_sint64[4] = -2006;
+    alltypes.rep_bool_count = 5; alltypes.rep_bool[4] = true;
+    
+    alltypes.rep_fixed32_count = 5; alltypes.rep_fixed32[4] = 2008;
+    alltypes.rep_sfixed32_count = 5; alltypes.rep_sfixed32[4] = -2009;
+    alltypes.rep_float_count = 5; alltypes.rep_float[4] = 2010.0f;
+    
+    alltypes.rep_fixed64_count = 5; alltypes.rep_fixed64[4] = 2011;
+    alltypes.rep_sfixed64_count = 5; alltypes.rep_sfixed64[4] = -2012;
+    alltypes.rep_double_count = 5; alltypes.rep_double[4] = 2013.0;
+    
+    alltypes.rep_string_count = 5; strcpy(alltypes.rep_string[4], "2014");
+    alltypes.rep_bytes_count = 5; alltypes.rep_bytes[4].size = 4;
+    memcpy(alltypes.rep_bytes[4].bytes, "2015", 4);
+
+    alltypes.rep_submsg_count = 5;
+    strcpy(alltypes.rep_submsg[4].substuff1, "2016");
+    alltypes.rep_submsg[4].substuff2 = 2016;
+    alltypes.rep_submsg[4].has_substuff3 = true;
+    alltypes.rep_submsg[4].substuff3 = 2016;
+    
+    alltypes.rep_enum_count = 5; alltypes.rep_enum[4] = MyEnum_Truth;
+    
+    if (mode != 0)
+    {
+        /* Fill in values for optional fields */
+        alltypes.has_opt_int32 = true;
+        alltypes.opt_int32         = 3041;
+        alltypes.has_opt_int64 = true;
+        alltypes.opt_int64         = 3042;
+        alltypes.has_opt_uint32 = true;
+        alltypes.opt_uint32        = 3043;
+        alltypes.has_opt_uint64 = true;
+        alltypes.opt_uint64        = 3044;
+        alltypes.has_opt_sint32 = true;
+        alltypes.opt_sint32        = 3045;
+        alltypes.has_opt_sint64 = true;
+        alltypes.opt_sint64        = 3046;
+        alltypes.has_opt_bool = true;
+        alltypes.opt_bool          = true;
+        
+        alltypes.has_opt_fixed32 = true;
+        alltypes.opt_fixed32       = 3048;
+        alltypes.has_opt_sfixed32 = true;
+        alltypes.opt_sfixed32      = 3049;
+        alltypes.has_opt_float = true;
+        alltypes.opt_float         = 3050.0f;
+        
+        alltypes.has_opt_fixed64 = true;
+        alltypes.opt_fixed64       = 3051;
+        alltypes.has_opt_sfixed64 = true;
+        alltypes.opt_sfixed64      = 3052;
+        alltypes.has_opt_double = true;
+        alltypes.opt_double        = 3053.0;
+        
+        alltypes.has_opt_string = true;
+        strcpy(alltypes.opt_string, "3054");
+        alltypes.has_opt_bytes = true;
+        alltypes.opt_bytes.size = 4;
+        memcpy(alltypes.opt_bytes.bytes, "3055", 4);
+        alltypes.has_opt_submsg = true;
+        strcpy(alltypes.opt_submsg.substuff1, "3056");
+        alltypes.opt_submsg.substuff2 = 3056;
+        alltypes.has_opt_enum = true;
+        alltypes.opt_enum = MyEnum_Truth;
+    }
+    
+    alltypes.end = 1099;
+
+    {    
+        uint8_t buffer[1024];
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        /* Now encode it and check if we succeeded. */
+        if (pb_encode(&stream, AllTypes_fields, &alltypes))
+        {
+            SET_BINARY_MODE(stdout);
+            fwrite(buffer, 1, stream.bytes_written, stdout);
+            return 0; /* Success */
+        }
+        else
+        {
+            fprintf(stderr, "Encoding failed!\n");
+            return 1; /* Failure */
+        }
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/basic_buffer/SConscript
@@ -0,0 +1,12 @@
+# Build and run a basic round-trip test using memory buffer encoding.
+
+Import("env")
+
+enc = env.Program(["encode_buffer.c", "$COMMON/person.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = env.Program(["decode_buffer.c", "$COMMON/person.pb.c", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_buffer.output"])
+env.Decode(["encode_buffer.output", "$COMMON/person.proto"], MESSAGE = "Person")
+env.Compare(["decode_buffer.output", "encode_buffer.decoded"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/basic_buffer/decode_buffer.c
@@ -0,0 +1,88 @@
+/* A very simple decoding test case, using person.proto.
+ * Produces output compatible with protoc --decode.
+ * Reads the encoded data from stdin and prints the values
+ * to stdout as text.
+ *
+ * Run e.g. ./test_encode1 | ./test_decode1
+ */
+
+#include <stdio.h>
+#include <pb_decode.h>
+#include "person.pb.h"
+#include "test_helpers.h"
+
+/* This function is called once from main(), it handles
+   the decoding and printing. */
+bool print_person(pb_istream_t *stream)
+{
+    int i;
+    Person person = Person_init_zero;
+    
+    if (!pb_decode(stream, Person_fields, &person))
+        return false;
+    
+    /* Now the decoding is done, rest is just to print stuff out. */
+
+    printf("name: \"%s\"\n", person.name);
+    printf("id: %ld\n", (long)person.id);
+    
+    if (person.has_email)
+        printf("email: \"%s\"\n", person.email);
+    
+    for (i = 0; i < person.phone_count; i++)
+    {
+        Person_PhoneNumber *phone = &person.phone[i];
+        printf("phone {\n");
+        printf("  number: \"%s\"\n", phone->number);
+        
+        if (phone->has_type)
+        {
+            switch (phone->type)
+            {
+                case Person_PhoneType_WORK:
+                    printf("  type: WORK\n");
+                    break;
+                
+                case Person_PhoneType_HOME:
+                    printf("  type: HOME\n");
+                    break;
+                
+                case Person_PhoneType_MOBILE:
+                    printf("  type: MOBILE\n");
+                    break;
+            }
+        }
+        printf("}\n");
+    }
+    
+    return true;
+}
+
+int main()
+{
+    uint8_t buffer[Person_size];
+    pb_istream_t stream;
+    size_t count;
+    
+    /* Read the data into buffer */
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+    
+    if (!feof(stdin))
+    {
+    	printf("Message does not fit in buffer\n");
+    	return 1;
+    }
+    
+    /* Construct a pb_istream_t for reading from the buffer */
+    stream = pb_istream_from_buffer(buffer, count);
+    
+    /* Decode and print out the stuff */
+    if (!print_person(&stream))
+    {
+        printf("Parsing failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    } else {
+        return 0;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/basic_buffer/encode_buffer.c
@@ -0,0 +1,38 @@
+/* A very simple encoding test case using person.proto.
+ * Just puts constant data in the fields and encodes into
+ * buffer, which is then written to stdout.
+ */
+
+#include <stdio.h>
+#include <pb_encode.h>
+#include "person.pb.h"
+#include "test_helpers.h"
+
+int main()
+{
+    uint8_t buffer[Person_size];
+    pb_ostream_t stream;
+    
+    /* Initialize the structure with constants */
+    Person person = {"Test Person 99", 99, true, "test@person.com",
+        3, {{"555-12345678", true, Person_PhoneType_MOBILE},
+            {"99-2342", false, 0},
+            {"1234-5678", true, Person_PhoneType_WORK},
+        }};
+
+    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+    
+    /* Now encode it and check if we succeeded. */
+    if (pb_encode(&stream, Person_fields, &person))
+    {    
+        /* Write the result data to stdout */
+        SET_BINARY_MODE(stdout);
+        fwrite(buffer, 1, stream.bytes_written, stdout);
+        return 0; /* Success */
+    }
+    else
+    {
+        fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+        return 1; /* Failure */
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/basic_stream/SConscript
@@ -0,0 +1,12 @@
+# Build and run a basic round-trip test using direct stream encoding.
+
+Import("env")
+
+enc = env.Program(["encode_stream.c", "$COMMON/person.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = env.Program(["decode_stream.c", "$COMMON/person.pb.c", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_stream.output"])
+env.Decode(["encode_stream.output", "$COMMON/person.proto"], MESSAGE = "Person")
+env.Compare(["decode_stream.output", "encode_stream.decoded"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/basic_stream/decode_stream.c
@@ -0,0 +1,84 @@
+/* Same as test_decode1 but reads from stdin directly.
+ */
+
+#include <stdio.h>
+#include <pb_decode.h>
+#include "person.pb.h"
+#include "test_helpers.h"
+
+/* This function is called once from main(), it handles
+   the decoding and printing.
+   Ugly copy-paste from test_decode1.c. */
+bool print_person(pb_istream_t *stream)
+{
+    int i;
+    Person person = Person_init_zero;
+    
+    if (!pb_decode(stream, Person_fields, &person))
+        return false;
+    
+    /* Now the decoding is done, rest is just to print stuff out. */
+
+    printf("name: \"%s\"\n", person.name);
+    printf("id: %ld\n", (long)person.id);
+    
+    if (person.has_email)
+        printf("email: \"%s\"\n", person.email);
+    
+    for (i = 0; i < person.phone_count; i++)
+    {
+        Person_PhoneNumber *phone = &person.phone[i];
+        printf("phone {\n");
+        printf("  number: \"%s\"\n", phone->number);
+        
+        if (phone->has_type)
+        {
+            switch (phone->type)
+            {
+                case Person_PhoneType_WORK:
+                    printf("  type: WORK\n");
+                    break;
+                
+                case Person_PhoneType_HOME:
+                    printf("  type: HOME\n");
+                    break;
+                
+                case Person_PhoneType_MOBILE:
+                    printf("  type: MOBILE\n");
+                    break;
+            }
+        }
+        printf("}\n");
+    }
+    
+    return true;
+}
+
+/* This binds the pb_istream_t to stdin */
+bool callback(pb_istream_t *stream, uint8_t *buf, size_t count)
+{
+    FILE *file = (FILE*)stream->state;
+    bool status;
+    
+    status = (fread(buf, 1, count, file) == count);
+    
+    if (feof(file))
+        stream->bytes_left = 0;
+    
+    return status;
+}
+
+int main()
+{
+    pb_istream_t stream = {&callback, NULL, SIZE_MAX};
+    stream.state = stdin;
+    SET_BINARY_MODE(stdin);
+
+    if (!print_person(&stream))
+    {
+        printf("Parsing failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    } else {
+        return 0;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/basic_stream/encode_stream.c
@@ -0,0 +1,40 @@
+/* Same as test_encode1.c, except writes directly to stdout.
+ */
+
+#include <stdio.h>
+#include <pb_encode.h>
+#include "person.pb.h"
+#include "test_helpers.h"
+
+/* This binds the pb_ostream_t into the stdout stream */
+bool streamcallback(pb_ostream_t *stream, const uint8_t *buf, size_t count)
+{
+    FILE *file = (FILE*) stream->state;
+    return fwrite(buf, 1, count, file) == count;
+}
+
+int main()
+{
+    /* Initialize the structure with constants */
+    Person person = {"Test Person 99", 99, true, "test@person.com",
+        3, {{"555-12345678", true, Person_PhoneType_MOBILE},
+            {"99-2342", false, 0},
+            {"1234-5678", true, Person_PhoneType_WORK},
+        }};
+    
+    /* Prepare the stream, output goes directly to stdout */
+    pb_ostream_t stream = {&streamcallback, NULL, SIZE_MAX, 0};
+    stream.state = stdout;
+    SET_BINARY_MODE(stdout);
+    
+    /* Now encode it and check if we succeeded. */
+    if (pb_encode(&stream, Person_fields, &person))
+    {
+        return 0; /* Success */
+    }
+    else
+    {
+        fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+        return 1; /* Failure */
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/buffer_only/SConscript
@@ -0,0 +1,28 @@
+# Run the alltypes test case, but compile with PB_BUFFER_ONLY=1
+
+Import("env")
+
+# Take copy of the files for custom build.
+c = Copy("$TARGET", "$SOURCE")
+env.Command("alltypes.pb.h", "$BUILD/alltypes/alltypes.pb.h", c)
+env.Command("alltypes.pb.c", "$BUILD/alltypes/alltypes.pb.c", c)
+env.Command("encode_alltypes.c", "$BUILD/alltypes/encode_alltypes.c", c)
+env.Command("decode_alltypes.c", "$BUILD/alltypes/decode_alltypes.c", c)
+
+# Define the compilation options
+opts = env.Clone()
+opts.Append(CPPDEFINES = {'PB_BUFFER_ONLY': 1})
+
+# Build new version of core
+strict = opts.Clone()
+strict.Append(CFLAGS = strict['CORECFLAGS'])
+strict.Object("pb_decode_bufonly.o", "$NANOPB/pb_decode.c")
+strict.Object("pb_encode_bufonly.o", "$NANOPB/pb_encode.c")
+strict.Object("pb_common_bufonly.o", "$NANOPB/pb_common.c")
+
+# Now build and run the test normally.
+enc = opts.Program(["encode_alltypes.c", "alltypes.pb.c", "pb_encode_bufonly.o", "pb_common_bufonly.o"])
+dec = opts.Program(["decode_alltypes.c", "alltypes.pb.c", "pb_decode_bufonly.o", "pb_common_bufonly.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_alltypes.output"])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/callbacks/SConscript
@@ -0,0 +1,14 @@
+# Test the functionality of the callback fields.
+
+Import("env")
+
+env.NanopbProto("callbacks")
+enc = env.Program(["encode_callbacks.c", "callbacks.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = env.Program(["decode_callbacks.c", "callbacks.pb.c", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_callbacks.output"])
+
+env.Decode(["encode_callbacks.output", "callbacks.proto"], MESSAGE = "TestMessage")
+env.Compare(["decode_callbacks.output", "encode_callbacks.decoded"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/callbacks/callbacks.proto
@@ -0,0 +1,18 @@
+syntax = "proto2";
+
+message SubMessage {
+    optional string stringvalue = 1;
+    repeated int32 int32value = 2;
+    repeated fixed32 fixed32value = 3;
+    repeated fixed64 fixed64value = 4;
+}
+
+message TestMessage {
+    optional string stringvalue = 1;
+    repeated int32 int32value = 2;
+    repeated fixed32 fixed32value = 3;
+    repeated fixed64 fixed64value = 4;
+    optional SubMessage submsg = 5;
+    repeated string repeatedstring = 6;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/callbacks/decode_callbacks.c
@@ -0,0 +1,97 @@
+/* Decoding testcase for callback fields.
+ * Run e.g. ./test_encode_callbacks | ./test_decode_callbacks
+ */
+
+#include <stdio.h>
+#include <pb_decode.h>
+#include "callbacks.pb.h"
+#include "test_helpers.h"
+
+bool print_string(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint8_t buffer[1024] = {0};
+    
+    /* We could read block-by-block to avoid the large buffer... */
+    if (stream->bytes_left > sizeof(buffer) - 1)
+        return false;
+    
+    if (!pb_read(stream, buffer, stream->bytes_left))
+        return false;
+    
+    /* Print the string, in format comparable with protoc --decode.
+     * Format comes from the arg defined in main().
+     */
+    printf((char*)*arg, buffer);
+    return true;
+}
+
+bool print_int32(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint64_t value;
+    if (!pb_decode_varint(stream, &value))
+        return false;
+    
+    printf((char*)*arg, (long)value);
+    return true;
+}
+
+bool print_fixed32(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint32_t value;
+    if (!pb_decode_fixed32(stream, &value))
+        return false;
+    
+    printf((char*)*arg, (long)value);
+    return true;
+}
+
+bool print_fixed64(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    uint64_t value;
+    if (!pb_decode_fixed64(stream, &value))
+        return false;
+    
+    printf((char*)*arg, (long)value);
+    return true;
+}
+
+int main()
+{
+    uint8_t buffer[1024];
+    size_t length;
+    pb_istream_t stream;
+    /* Note: empty initializer list initializes the struct with all-0.
+     * This is recommended so that unused callbacks are set to NULL instead
+     * of crashing at runtime.
+     */
+    TestMessage testmessage = {{{NULL}}};
+    
+    SET_BINARY_MODE(stdin);
+    length = fread(buffer, 1, 1024, stdin);
+    stream = pb_istream_from_buffer(buffer, length);    
+    
+    testmessage.submsg.stringvalue.funcs.decode = &print_string;
+    testmessage.submsg.stringvalue.arg = "submsg {\n  stringvalue: \"%s\"\n";
+    testmessage.submsg.int32value.funcs.decode = &print_int32;
+    testmessage.submsg.int32value.arg = "  int32value: %ld\n";
+    testmessage.submsg.fixed32value.funcs.decode = &print_fixed32;
+    testmessage.submsg.fixed32value.arg = "  fixed32value: %ld\n";
+    testmessage.submsg.fixed64value.funcs.decode = &print_fixed64;
+    testmessage.submsg.fixed64value.arg = "  fixed64value: %ld\n}\n";
+    
+    testmessage.stringvalue.funcs.decode = &print_string;
+    testmessage.stringvalue.arg = "stringvalue: \"%s\"\n";
+    testmessage.int32value.funcs.decode = &print_int32;
+    testmessage.int32value.arg = "int32value: %ld\n";
+    testmessage.fixed32value.funcs.decode = &print_fixed32;
+    testmessage.fixed32value.arg = "fixed32value: %ld\n";
+    testmessage.fixed64value.funcs.decode = &print_fixed64;
+    testmessage.fixed64value.arg = "fixed64value: %ld\n";
+    testmessage.repeatedstring.funcs.decode = &print_string;
+    testmessage.repeatedstring.arg = "repeatedstring: \"%s\"\n";
+    
+    if (!pb_decode(&stream, TestMessage_fields, &testmessage))
+        return 1;
+    
+    return 0;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/callbacks/encode_callbacks.c
@@ -0,0 +1,92 @@
+/* Encoding testcase for callback fields */
+
+#include <stdio.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "callbacks.pb.h"
+#include "test_helpers.h"
+
+bool encode_string(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    char *str = "Hello world!";
+    
+    if (!pb_encode_tag_for_field(stream, field))
+        return false;
+    
+    return pb_encode_string(stream, (uint8_t*)str, strlen(str));
+}
+
+bool encode_int32(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    if (!pb_encode_tag_for_field(stream, field))
+        return false;
+    
+    return pb_encode_varint(stream, 42);
+}
+
+bool encode_fixed32(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    uint32_t value = 42;
+
+    if (!pb_encode_tag_for_field(stream, field))
+        return false;
+    
+    return pb_encode_fixed32(stream, &value);
+}
+
+bool encode_fixed64(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    uint64_t value = 42;
+
+    if (!pb_encode_tag_for_field(stream, field))
+        return false;
+    
+    return pb_encode_fixed64(stream, &value);
+}
+
+bool encode_repeatedstring(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    char *str[4] = {"Hello world!", "", "Test", "Test2"};
+    int i;
+    
+    for (i = 0; i < 4; i++)
+    {
+        if (!pb_encode_tag_for_field(stream, field))
+            return false;
+        
+        if (!pb_encode_string(stream, (uint8_t*)str[i], strlen(str[i])))
+            return false;
+    }
+    return true;
+}
+
+int main()
+{
+    uint8_t buffer[1024];
+    pb_ostream_t stream;
+    TestMessage testmessage = {{{NULL}}};
+    
+    stream = pb_ostream_from_buffer(buffer, 1024);
+    
+    testmessage.stringvalue.funcs.encode = &encode_string;
+    testmessage.int32value.funcs.encode = &encode_int32;
+    testmessage.fixed32value.funcs.encode = &encode_fixed32;
+    testmessage.fixed64value.funcs.encode = &encode_fixed64;
+    
+    testmessage.has_submsg = true;
+    testmessage.submsg.stringvalue.funcs.encode = &encode_string;
+    testmessage.submsg.int32value.funcs.encode = &encode_int32;
+    testmessage.submsg.fixed32value.funcs.encode = &encode_fixed32;
+    testmessage.submsg.fixed64value.funcs.encode = &encode_fixed64;
+
+    testmessage.repeatedstring.funcs.encode = &encode_repeatedstring;
+    
+    if (!pb_encode(&stream, TestMessage_fields, &testmessage))
+        return 1;
+    
+    SET_BINARY_MODE(stdout);
+    if (fwrite(buffer, stream.bytes_written, 1, stdout) != 1)
+        return 2;
+    
+    return 0;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/SConscript
@@ -0,0 +1,48 @@
+# Build the common files needed by multiple test cases
+
+Import('env')
+
+# Protocol definitions for the encode/decode_unittests
+env.NanopbProto("unittestproto")
+
+# Protocol definitions for basic_buffer/stream tests
+env.NanopbProto("person")
+
+#--------------------------------------------
+# Binaries of the pb_decode.c and pb_encode.c
+# These are built using more strict warning flags.
+strict = env.Clone()
+strict.Append(CFLAGS = strict['CORECFLAGS'])
+strict.Object("pb_decode.o", "$NANOPB/pb_decode.c")
+strict.Object("pb_encode.o", "$NANOPB/pb_encode.c")
+strict.Object("pb_common.o", "$NANOPB/pb_common.c")
+
+#-----------------------------------------------
+# Binaries of pb_decode etc. with malloc support
+# Uses malloc_wrappers.c to count allocations.
+malloc_env = env.Clone()
+malloc_env.Append(CPPDEFINES = {'PB_ENABLE_MALLOC': 1,
+                                'PB_SYSTEM_HEADER': '\\"malloc_wrappers_syshdr.h\\"'})
+malloc_env.Append(CPPPATH = ["$COMMON"])
+
+if 'SYSHDR' in malloc_env:
+    malloc_env.Append(CPPDEFINES = {'PB_OLD_SYSHDR': malloc_env['SYSHDR']})
+
+# Disable libmudflap, because it will confuse valgrind
+# and other memory leak detection tools.
+if '-fmudflap' in env["CCFLAGS"]:
+    malloc_env["CCFLAGS"].remove("-fmudflap")
+    malloc_env["LINKFLAGS"].remove("-fmudflap")
+    malloc_env["LIBS"].remove("mudflap")
+
+malloc_strict = malloc_env.Clone()
+malloc_strict.Append(CFLAGS = malloc_strict['CORECFLAGS'])
+malloc_strict.Object("pb_decode_with_malloc.o", "$NANOPB/pb_decode.c")
+malloc_strict.Object("pb_encode_with_malloc.o", "$NANOPB/pb_encode.c")
+malloc_strict.Object("pb_common_with_malloc.o", "$NANOPB/pb_common.c")
+
+malloc_env.Object("malloc_wrappers.o", "malloc_wrappers.c")
+malloc_env.Depends("$NANOPB/pb.h", ["malloc_wrappers_syshdr.h", "malloc_wrappers.h"])
+
+Export("malloc_env")
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/malloc_wrappers.c
@@ -0,0 +1,54 @@
+#include "malloc_wrappers.h"
+#include <stdint.h>
+#include <assert.h>
+#include <string.h>
+
+static size_t alloc_count = 0;
+
+/* Allocate memory and place check values before and after. */
+void* malloc_with_check(size_t size)
+{
+    size_t size32 = (size + 3) / 4 + 3;
+    uint32_t *buf = malloc(size32 * sizeof(uint32_t));
+    buf[0] = size32;
+    buf[1] = 0xDEADBEEF;
+    buf[size32 - 1] = 0xBADBAD;
+    return buf + 2;
+}
+
+/* Free memory allocated with malloc_with_check() and do the checks. */
+void free_with_check(void *mem)
+{
+    uint32_t *buf = (uint32_t*)mem - 2;
+    assert(buf[1] == 0xDEADBEEF);
+    assert(buf[buf[0] - 1] == 0xBADBAD);
+    free(buf);
+}
+
+/* Track memory usage */
+void* counting_realloc(void *ptr, size_t size)
+{
+    /* Don't allocate crazy amounts of RAM when fuzzing */
+    if (size > 1000000)
+        return NULL;
+
+    if (!ptr && size)
+        alloc_count++;
+    
+    return realloc(ptr, size);
+}
+
+void counting_free(void *ptr)
+{
+    if (ptr)
+    {
+        assert(alloc_count > 0);
+        alloc_count--;
+        free(ptr);
+    }
+}
+
+size_t get_alloc_count()
+{
+    return alloc_count;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/malloc_wrappers.h
@@ -0,0 +1,7 @@
+#include <stdlib.h>
+
+void* malloc_with_check(size_t size);
+void free_with_check(void *mem);
+void* counting_realloc(void *ptr, size_t size);
+void counting_free(void *ptr);
+size_t get_alloc_count();
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/malloc_wrappers_syshdr.h
@@ -0,0 +1,15 @@
+/* This is just a wrapper in order to get our own malloc wrappers into nanopb core. */
+
+#define pb_realloc(ptr,size) counting_realloc(ptr,size)
+#define pb_free(ptr) counting_free(ptr)
+
+#ifdef PB_OLD_SYSHDR
+#include PB_OLD_SYSHDR
+#else
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+#include <string.h>
+#endif
+
+#include <malloc_wrappers.h>
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/person.proto
@@ -0,0 +1,22 @@
+syntax = "proto2";
+
+import "nanopb.proto";
+
+message Person {
+  required string name = 1 [(nanopb).max_size = 40];
+  required int32 id = 2;
+  optional string email = 3 [(nanopb).max_size = 40];
+  
+  enum PhoneType {
+    MOBILE = 0;
+    HOME = 1;
+    WORK = 2;
+  }
+
+  message PhoneNumber {
+    required string number = 1 [(nanopb).max_size = 40];
+    optional PhoneType type = 2 [default = HOME];
+  }
+
+  repeated PhoneNumber phone = 4 [(nanopb).max_count = 5];
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/test_helpers.h
@@ -0,0 +1,17 @@
+/* Compatibility helpers for the test programs. */
+
+#ifndef _TEST_HELPERS_H_
+#define _TEST_HELPERS_H_
+
+#ifdef _WIN32
+#include <io.h>
+#include <fcntl.h>
+#define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
+
+#else
+#define SET_BINARY_MODE(file)
+
+#endif
+
+
+#endif
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/unittestproto.proto
@@ -0,0 +1,43 @@
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+message IntegerArray {
+    repeated int32 data = 1 [(nanopb).max_count = 10];
+}
+
+message FloatArray {
+    repeated float data = 1 [(nanopb).max_count = 10];
+}
+
+message StringMessage {
+    required string data = 1 [(nanopb).max_size = 10];
+}
+
+message BytesMessage {
+    required bytes data = 1 [(nanopb).max_size = 16];
+}
+
+message CallbackArray {
+    // We cheat a bit and use this message for testing other types, too.
+    // Nanopb does not care about the actual defined data type for callback
+    // fields.
+    repeated int32 data = 1;
+}
+
+message IntegerContainer {
+    required IntegerArray submsg = 1;
+}
+
+message CallbackContainer {
+    required CallbackArray submsg = 1;
+}
+
+message CallbackContainerContainer {
+    required CallbackContainer submsg = 1;
+}
+
+message StringPointerContainer {
+    repeated string rep_str = 1 [(nanopb).type = FT_POINTER];
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/common/unittests.h
@@ -0,0 +1,14 @@
+#include <stdio.h>
+
+#define COMMENT(x) printf("\n----" x "----\n");
+#define STR(x) #x
+#define STR2(x) STR(x)
+#define TEST(x) \
+    if (!(x)) { \
+        fprintf(stderr, "\033[31;1mFAILED:\033[22;39m " __FILE__ ":" STR2(__LINE__) " " #x "\n"); \
+        status = 1; \
+    } else { \
+        printf("\033[32;1mOK:\033[22;39m " #x "\n"); \
+    }
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/cxx_main_program/SConscript
@@ -0,0 +1,25 @@
+# Run the alltypes test case, but compile it as C++ instead.
+# In fact, compile the entire nanopb using C++ compiler.
+
+Import("env")
+
+# This is needed to get INT32_MIN etc. macros defined
+env = env.Clone()
+env.Append(CPPDEFINES = ['__STDC_LIMIT_MACROS'])
+
+# Copy the files to .cxx extension in order to force C++ build.
+c = Copy("$TARGET", "$SOURCE")
+env.Command("pb_encode.cxx", "#../pb_encode.c", c)
+env.Command("pb_decode.cxx", "#../pb_decode.c", c)
+env.Command("pb_common.cxx", "#../pb_common.c", c)
+env.Command("alltypes.pb.h", "$BUILD/alltypes/alltypes.pb.h", c)
+env.Command("alltypes.pb.cxx", "$BUILD/alltypes/alltypes.pb.c", c)
+env.Command("encode_alltypes.cxx", "$BUILD/alltypes/encode_alltypes.c", c)
+env.Command("decode_alltypes.cxx", "$BUILD/alltypes/decode_alltypes.c", c)
+
+# Now build and run the test normally.
+enc = env.Program(["encode_alltypes.cxx", "alltypes.pb.cxx", "pb_encode.cxx", "pb_common.cxx"])
+dec = env.Program(["decode_alltypes.cxx", "alltypes.pb.cxx", "pb_decode.cxx", "pb_common.cxx"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_alltypes.output"])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/cyclic_messages/SConscript
@@ -0,0 +1,11 @@
+Import("env")
+
+# Encode cyclic messages with callback fields
+
+c = Copy("$TARGET", "$SOURCE")
+env.Command("cyclic_callback.proto", "cyclic.proto", c)
+env.NanopbProto(["cyclic_callback", "cyclic_callback.options"])
+
+enc_callback = env.Program(["encode_cyclic_callback.c", "cyclic_callback.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/cyclic_messages/cyclic.proto
@@ -0,0 +1,27 @@
+// Test structures with cyclic references.
+// These can only be handled in pointer/callback mode,
+// see associated .options files.
+
+syntax = "proto2";
+
+message TreeNode
+{
+    optional int32 leaf = 1;
+    optional TreeNode left = 2;
+    optional TreeNode right = 3;
+}
+
+message Dictionary
+{
+    repeated KeyValuePair dictItem = 1;
+}
+
+message KeyValuePair
+{
+    required string key = 1;
+    optional string stringValue = 2;
+    optional int32 intValue = 3;
+    optional Dictionary dictValue = 4;
+    optional TreeNode treeValue = 5;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/cyclic_messages/cyclic_callback.options
@@ -0,0 +1,7 @@
+TreeNode.left               type:FT_CALLBACK
+TreeNode.right              type:FT_CALLBACK
+
+Dictionary.data             type:FT_CALLBACK
+KeyValuePair.key            max_size:8
+KeyValuePair.stringValue    max_size:8
+KeyValuePair.treeValue      type:FT_CALLBACK
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/cyclic_messages/encode_cyclic_callback.c
@@ -0,0 +1,148 @@
+/* This program parses an input string in a format a bit like JSON:
+ * {'foobar': 1234, 'xyz': 'abc', 'tree': [[[1, 2], 3], [4, 5]]}
+ * and encodes it as protobuf
+ *
+ * Note: The string parsing here is not in any way intended to be robust
+ *       nor safe against buffer overflows. It is just for this test.
+ */
+
+#include <pb_encode.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "cyclic_callback.pb.h"
+
+static char *find_end_of_item(char *p)
+{
+    int depth = 0;
+    do {
+        if (*p == '[' || *p == '{') depth++;
+        if (*p == ']' || *p == '}') depth--;
+        p++;
+    } while (depth > 0 || (*p != ',' && *p != '}'));
+    
+    if (*p == '}')
+        return p; /* End of parent dict */
+    
+    p++;
+    while (*p == ' ') p++;
+    return p;
+}
+
+/* Parse a tree in format [[1 2] 3] and encode it directly to protobuf */
+static bool encode_tree(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    TreeNode tree = TreeNode_init_zero;
+    char *p = (char*)*arg;
+    
+    if (*p == '[')
+    {
+        /* This is a tree branch */
+        p++;
+        tree.left.funcs.encode = encode_tree;
+        tree.left.arg = p;
+        
+        p = find_end_of_item(p);
+        tree.right.funcs.encode = encode_tree;
+        tree.right.arg = p;
+    }
+    else
+    {
+        /* This is a leaf node */
+        tree.has_leaf = true;
+        tree.leaf = atoi(p);
+    }
+    
+    return pb_encode_tag_for_field(stream, field) &&
+           pb_encode_submessage(stream, TreeNode_fields, &tree);
+}
+
+/* Parse a dictionary in format {'name': value} and encode it directly to protobuf */
+static bool encode_dictionary(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    int textlen;
+    char *p = (char*)*arg;
+    if (*p == '{') p++;
+    while (*p != '}')
+    {
+        KeyValuePair pair = KeyValuePair_init_zero;
+        
+        if (*p != '\'')
+            PB_RETURN_ERROR(stream, "invalid key, missing quote");
+        
+        p++; /* Starting quote of key */
+        textlen = strchr(p, '\'') - p;
+        strncpy(pair.key, p, textlen);
+        pair.key[textlen] = 0;
+        p += textlen + 2;
+        
+        while (*p == ' ') p++;
+        
+        if (*p == '[')
+        {
+            /* Value is a tree */
+            pair.treeValue.funcs.encode = encode_tree;
+            pair.treeValue.arg = p;
+        }
+        else if (*p == '\'')
+        {
+            /* Value is a string */
+            pair.has_stringValue = true;
+            p++;
+            textlen = strchr(p, '\'') - p;
+            strncpy(pair.stringValue, p, textlen);
+            pair.stringValue[textlen] = 0;
+        }
+        else if (*p == '{')
+        {
+            /* Value is a dictionary */
+            pair.has_dictValue = true;
+            pair.dictValue.dictItem.funcs.encode = encode_dictionary;
+            pair.dictValue.dictItem.arg = p;
+        }
+        else
+        {
+            /* Value is integer */
+            pair.has_intValue = true;
+            pair.intValue = atoi(p);
+        }
+        
+        p = find_end_of_item(p);
+        
+        if (!pb_encode_tag_for_field(stream, field))
+            return false;
+        
+        if (!pb_encode_submessage(stream, KeyValuePair_fields, &pair))
+            return false;
+    }
+
+    return true;
+}
+
+
+int main(int argc, char *argv[])
+{
+    uint8_t buffer[256];
+    pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+    Dictionary dict = Dictionary_init_zero;
+    
+    if (argc <= 1)
+    {
+        fprintf(stderr, "Usage: %s \"{'foobar': 1234, ...}\"\n", argv[0]);
+        return 1;
+    }
+    
+    dict.dictItem.funcs.encode = encode_dictionary;
+    dict.dictItem.arg = argv[1];
+
+    if (!pb_encode(&stream, Dictionary_fields, &dict))
+    {
+        fprintf(stderr, "Encoding error: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    }
+    
+    fwrite(buffer, 1, stream.bytes_written, stdout);
+    return 0;
+}
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/decode_unittests/SConscript
@@ -0,0 +1,4 @@
+Import('env')
+p = env.Program(["decode_unittests.c", "$COMMON/unittestproto.pb.c"])
+env.RunTest(p)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/decode_unittests/decode_unittests.c
@@ -0,0 +1,344 @@
+/* This includes the whole .c file to get access to static functions. */
+#define PB_ENABLE_MALLOC
+#include "pb_common.c"
+#include "pb_decode.c"
+
+#include <stdio.h>
+#include <string.h>
+#include "unittests.h"
+#include "unittestproto.pb.h"
+
+#define S(x) pb_istream_from_buffer((uint8_t*)x, sizeof(x) - 1)
+
+bool stream_callback(pb_istream_t *stream, uint8_t *buf, size_t count)
+{
+    if (stream->state != NULL)
+        return false; /* Simulate error */
+    
+    if (buf != NULL)
+        memset(buf, 'x', count);
+    return true;
+}
+
+/* Verifies that the stream passed to callback matches the byte array pointed to by arg. */
+bool callback_check(pb_istream_t *stream, const pb_field_t *field, void **arg)
+{
+    int i;
+    uint8_t byte;
+    pb_bytes_array_t *ref = (pb_bytes_array_t*) *arg;
+    
+    for (i = 0; i < ref->size; i++)
+    {
+        if (!pb_read(stream, &byte, 1))
+            return false;
+        
+        if (byte != ref->bytes[i])
+            return false;
+    }
+    
+    return true;
+}
+
+int main()
+{
+    int status = 0;
+    
+    {
+        uint8_t buffer1[] = "foobartest1234";
+        uint8_t buffer2[sizeof(buffer1)];
+        pb_istream_t stream = pb_istream_from_buffer(buffer1, sizeof(buffer1));
+        
+        COMMENT("Test pb_read and pb_istream_t");
+        TEST(pb_read(&stream, buffer2, 6))
+        TEST(memcmp(buffer2, "foobar", 6) == 0)
+        TEST(stream.bytes_left == sizeof(buffer1) - 6)
+        TEST(pb_read(&stream, buffer2 + 6, stream.bytes_left))
+        TEST(memcmp(buffer1, buffer2, sizeof(buffer1)) == 0)
+        TEST(stream.bytes_left == 0)
+        TEST(!pb_read(&stream, buffer2, 1))
+    }
+    
+    {
+        uint8_t buffer[20];
+        pb_istream_t stream = {&stream_callback, NULL, 20};
+        
+        COMMENT("Test pb_read with custom callback");
+        TEST(pb_read(&stream, buffer, 5))
+        TEST(memcmp(buffer, "xxxxx", 5) == 0)
+        TEST(!pb_read(&stream, buffer, 50))
+        stream.state = (void*)1; /* Simulated error return from callback */
+        TEST(!pb_read(&stream, buffer, 5))
+        stream.state = NULL;
+        TEST(pb_read(&stream, buffer, 15))
+    }
+    
+    {
+        pb_istream_t s;
+        uint64_t u;
+        int64_t i;
+        
+        COMMENT("Test pb_decode_varint");
+        TEST((s = S("\x00"), pb_decode_varint(&s, &u) && u == 0));
+        TEST((s = S("\x01"), pb_decode_varint(&s, &u) && u == 1));
+        TEST((s = S("\xAC\x02"), pb_decode_varint(&s, &u) && u == 300));
+        TEST((s = S("\xFF\xFF\xFF\xFF\x0F"), pb_decode_varint(&s, &u) && u == UINT32_MAX));
+        TEST((s = S("\xFF\xFF\xFF\xFF\x0F"), pb_decode_varint(&s, (uint64_t*)&i) && i == UINT32_MAX));
+        TEST((s = S("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"),
+              pb_decode_varint(&s, (uint64_t*)&i) && i == -1));
+        TEST((s = S("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"),
+              pb_decode_varint(&s, &u) && u == UINT64_MAX));
+        TEST((s = S("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"),
+              !pb_decode_varint(&s, &u)));
+    }
+    
+    {
+        pb_istream_t s;
+        uint32_t u;
+        
+        COMMENT("Test pb_decode_varint32");
+        TEST((s = S("\x00"), pb_decode_varint32(&s, &u) && u == 0));
+        TEST((s = S("\x01"), pb_decode_varint32(&s, &u) && u == 1));
+        TEST((s = S("\xAC\x02"), pb_decode_varint32(&s, &u) && u == 300));
+        TEST((s = S("\xFF\xFF\xFF\xFF\x0F"), pb_decode_varint32(&s, &u) && u == UINT32_MAX));
+        TEST((s = S("\xFF\xFF\xFF\xFF\xFF\x01"), !pb_decode_varint32(&s, &u)));
+    }
+    
+    {
+        pb_istream_t s;
+        COMMENT("Test pb_skip_varint");
+        TEST((s = S("\x00""foobar"), pb_skip_varint(&s) && s.bytes_left == 6))
+        TEST((s = S("\xAC\x02""foobar"), pb_skip_varint(&s) && s.bytes_left == 6))
+        TEST((s = S("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01""foobar"),
+              pb_skip_varint(&s) && s.bytes_left == 6))
+        TEST((s = S("\xFF"), !pb_skip_varint(&s)))
+    }
+    
+    {
+        pb_istream_t s;
+        COMMENT("Test pb_skip_string")
+        TEST((s = S("\x00""foobar"), pb_skip_string(&s) && s.bytes_left == 6))
+        TEST((s = S("\x04""testfoobar"), pb_skip_string(&s) && s.bytes_left == 6))
+        TEST((s = S("\x04"), !pb_skip_string(&s)))
+        TEST((s = S("\xFF"), !pb_skip_string(&s)))
+    }
+    
+    {
+        pb_istream_t s = S("\x01\x00");
+        pb_field_t f = {1, PB_LTYPE_VARINT, 0, 0, 4, 0, 0};
+        uint32_t d;
+        COMMENT("Test pb_dec_varint using uint32_t")
+        TEST(pb_dec_varint(&s, &f, &d) && d == 1)
+        
+        /* Verify that no more than data_size is written. */
+        d = 0xFFFFFFFF;
+        f.data_size = 1;
+        TEST(pb_dec_varint(&s, &f, &d) && (d == 0xFFFFFF00 || d == 0x00FFFFFF))
+    }
+    
+    {
+        pb_istream_t s;
+        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 4, 0, 0};
+        int32_t d;
+        
+        COMMENT("Test pb_dec_svarint using int32_t")
+        TEST((s = S("\x01"), pb_dec_svarint(&s, &f, &d) && d == -1))
+        TEST((s = S("\x02"), pb_dec_svarint(&s, &f, &d) && d == 1))
+        TEST((s = S("\xfe\xff\xff\xff\x0f"), pb_dec_svarint(&s, &f, &d) && d == INT32_MAX))
+        TEST((s = S("\xff\xff\xff\xff\x0f"), pb_dec_svarint(&s, &f, &d) && d == INT32_MIN))
+    }
+    
+    {
+        pb_istream_t s;
+        pb_field_t f = {1, PB_LTYPE_SVARINT, 0, 0, 8, 0, 0};
+        uint64_t d;
+        
+        COMMENT("Test pb_dec_svarint using uint64_t")
+        TEST((s = S("\x01"), pb_dec_svarint(&s, &f, &d) && d == -1))
+        TEST((s = S("\x02"), pb_dec_svarint(&s, &f, &d) && d == 1))
+        TEST((s = S("\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"), pb_dec_svarint(&s, &f, &d) && d == INT64_MAX))
+        TEST((s = S("\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"), pb_dec_svarint(&s, &f, &d) && d == INT64_MIN))
+    }
+    
+    {
+        pb_istream_t s;
+        pb_field_t f = {1, PB_LTYPE_FIXED32, 0, 0, 4, 0, 0};
+        float d;
+        
+        COMMENT("Test pb_dec_fixed32 using float (failures here may be caused by imperfect rounding)")
+        TEST((s = S("\x00\x00\x00\x00"), pb_dec_fixed32(&s, &f, &d) && d == 0.0f))
+        TEST((s = S("\x00\x00\xc6\x42"), pb_dec_fixed32(&s, &f, &d) && d == 99.0f))
+        TEST((s = S("\x4e\x61\x3c\xcb"), pb_dec_fixed32(&s, &f, &d) && d == -12345678.0f))
+        TEST((s = S("\x00"), !pb_dec_fixed32(&s, &f, &d) && d == -12345678.0f))
+    }
+    
+    {
+        pb_istream_t s;
+        pb_field_t f = {1, PB_LTYPE_FIXED64, 0, 0, 8, 0, 0};
+        double d;
+        
+        COMMENT("Test pb_dec_fixed64 using double (failures here may be caused by imperfect rounding)")
+        TEST((s = S("\x00\x00\x00\x00\x00\x00\x00\x00"), pb_dec_fixed64(&s, &f, &d) && d == 0.0))
+        TEST((s = S("\x00\x00\x00\x00\x00\xc0\x58\x40"), pb_dec_fixed64(&s, &f, &d) && d == 99.0))
+        TEST((s = S("\x00\x00\x00\xc0\x29\x8c\x67\xc1"), pb_dec_fixed64(&s, &f, &d) && d == -12345678.0f))
+    }
+    
+    {
+        pb_istream_t s;
+        struct { pb_size_t size; uint8_t bytes[5]; } d;
+        pb_field_t f = {1, PB_LTYPE_BYTES, 0, 0, sizeof(d), 0, 0};
+        
+        COMMENT("Test pb_dec_bytes")
+        TEST((s = S("\x00"), pb_dec_bytes(&s, &f, &d) && d.size == 0))
+        TEST((s = S("\x01\xFF"), pb_dec_bytes(&s, &f, &d) && d.size == 1 && d.bytes[0] == 0xFF))
+        TEST((s = S("\x05xxxxx"), pb_dec_bytes(&s, &f, &d) && d.size == 5))
+        TEST((s = S("\x05xxxx"), !pb_dec_bytes(&s, &f, &d)))
+        
+        /* Note: the size limit on bytes-fields is not strictly obeyed, as
+         * the compiler may add some padding to the struct. Using this padding
+         * is not a very good thing to do, but it is difficult to avoid when
+         * we use only a single uint8_t to store the size of the field.
+         * Therefore this tests against a 10-byte string, while otherwise even
+         * 6 bytes should error out.
+         */
+        TEST((s = S("\x10xxxxxxxxxx"), !pb_dec_bytes(&s, &f, &d)))
+    }
+    
+    {
+        pb_istream_t s;
+        pb_field_t f = {1, PB_LTYPE_STRING, 0, 0, 5, 0, 0};
+        char d[5];
+        
+        COMMENT("Test pb_dec_string")
+        TEST((s = S("\x00"), pb_dec_string(&s, &f, &d) && d[0] == '\0'))
+        TEST((s = S("\x04xyzz"), pb_dec_string(&s, &f, &d) && strcmp(d, "xyzz") == 0))
+        TEST((s = S("\x05xyzzy"), !pb_dec_string(&s, &f, &d)))
+    }
+    
+    {
+        pb_istream_t s;
+        IntegerArray dest;
+        
+        COMMENT("Testing pb_decode with repeated int32 field")
+        TEST((s = S(""), pb_decode(&s, IntegerArray_fields, &dest) && dest.data_count == 0))
+        TEST((s = S("\x08\x01\x08\x02"), pb_decode(&s, IntegerArray_fields, &dest)
+             && dest.data_count == 2 && dest.data[0] == 1 && dest.data[1] == 2))
+        s = S("\x08\x01\x08\x02\x08\x03\x08\x04\x08\x05\x08\x06\x08\x07\x08\x08\x08\x09\x08\x0A");
+        TEST(pb_decode(&s, IntegerArray_fields, &dest) && dest.data_count == 10 && dest.data[9] == 10)
+        s = S("\x08\x01\x08\x02\x08\x03\x08\x04\x08\x05\x08\x06\x08\x07\x08\x08\x08\x09\x08\x0A\x08\x0B");
+        TEST(!pb_decode(&s, IntegerArray_fields, &dest))
+    }
+    
+    {
+        pb_istream_t s;
+        IntegerArray dest;
+        
+        COMMENT("Testing pb_decode with packed int32 field")
+        TEST((s = S("\x0A\x00"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 0))
+        TEST((s = S("\x0A\x01\x01"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 1 && dest.data[0] == 1))
+        TEST((s = S("\x0A\x0A\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 10 && dest.data[0] == 1 && dest.data[9] == 10))
+        TEST((s = S("\x0A\x0B\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B"), !pb_decode(&s, IntegerArray_fields, &dest)))
+        
+        /* Test invalid wire data */
+        TEST((s = S("\x0A\xFF"), !pb_decode(&s, IntegerArray_fields, &dest)))
+        TEST((s = S("\x0A\x01"), !pb_decode(&s, IntegerArray_fields, &dest)))
+    }
+    
+    {
+        pb_istream_t s;
+        IntegerArray dest;
+        
+        COMMENT("Testing pb_decode with unknown fields")
+        TEST((s = S("\x18\x0F\x08\x01"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 1 && dest.data[0] == 1))
+        TEST((s = S("\x19\x00\x00\x00\x00\x00\x00\x00\x00\x08\x01"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 1 && dest.data[0] == 1))
+        TEST((s = S("\x1A\x00\x08\x01"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 1 && dest.data[0] == 1))
+        TEST((s = S("\x1B\x08\x01"), !pb_decode(&s, IntegerArray_fields, &dest)))
+        TEST((s = S("\x1D\x00\x00\x00\x00\x08\x01"), pb_decode(&s, IntegerArray_fields, &dest)
+            && dest.data_count == 1 && dest.data[0] == 1))
+    }
+    
+    {
+        pb_istream_t s;
+        CallbackArray dest;
+        struct { pb_size_t size; uint8_t bytes[10]; } ref;
+        dest.data.funcs.decode = &callback_check;
+        dest.data.arg = &ref;
+        
+        COMMENT("Testing pb_decode with callbacks")
+        /* Single varint */
+        ref.size = 1; ref.bytes[0] = 0x55;
+        TEST((s = S("\x08\x55"), pb_decode(&s, CallbackArray_fields, &dest)))
+        /* Packed varint */
+        ref.size = 3; ref.bytes[0] = ref.bytes[1] = ref.bytes[2] = 0x55;
+        TEST((s = S("\x0A\x03\x55\x55\x55"), pb_decode(&s, CallbackArray_fields, &dest)))
+        /* Packed varint with loop */
+        ref.size = 1; ref.bytes[0] = 0x55;
+        TEST((s = S("\x0A\x03\x55\x55\x55"), pb_decode(&s, CallbackArray_fields, &dest)))
+        /* Single fixed32 */
+        ref.size = 4; ref.bytes[0] = ref.bytes[1] = ref.bytes[2] = ref.bytes[3] = 0xAA;
+        TEST((s = S("\x0D\xAA\xAA\xAA\xAA"), pb_decode(&s, CallbackArray_fields, &dest)))
+        /* Single fixed64 */
+        ref.size = 8; memset(ref.bytes, 0xAA, 8);
+        TEST((s = S("\x09\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"), pb_decode(&s, CallbackArray_fields, &dest)))
+        /* Unsupported field type */
+        TEST((s = S("\x0B\x00"), !pb_decode(&s, CallbackArray_fields, &dest)))
+        
+        /* Just make sure that our test function works */
+        ref.size = 1; ref.bytes[0] = 0x56;
+        TEST((s = S("\x08\x55"), !pb_decode(&s, CallbackArray_fields, &dest)))
+    }
+    
+    {
+        pb_istream_t s;
+        IntegerArray dest;
+        
+        COMMENT("Testing pb_decode message termination")
+        TEST((s = S(""), pb_decode(&s, IntegerArray_fields, &dest)))
+        TEST((s = S("\x00"), pb_decode(&s, IntegerArray_fields, &dest)))
+        TEST((s = S("\x08\x01"), pb_decode(&s, IntegerArray_fields, &dest)))
+        TEST((s = S("\x08\x01\x00"), pb_decode(&s, IntegerArray_fields, &dest)))
+        TEST((s = S("\x08"), !pb_decode(&s, IntegerArray_fields, &dest)))
+    }
+    
+    {
+        pb_istream_t s;
+        IntegerContainer dest = {{0}};
+        
+        COMMENT("Testing pb_decode_delimited")
+        TEST((s = S("\x09\x0A\x07\x0A\x05\x01\x02\x03\x04\x05"),
+              pb_decode_delimited(&s, IntegerContainer_fields, &dest)) &&
+              dest.submsg.data_count == 5)
+    }
+    
+    {
+        pb_istream_t s = {0};
+        void *data = NULL;
+        
+        COMMENT("Testing allocate_field")
+        TEST(allocate_field(&s, &data, 10, 10) && data != NULL);
+        TEST(allocate_field(&s, &data, 10, 20) && data != NULL);
+        
+        {
+            void *oldvalue = data;
+            size_t very_big = (size_t)-1;
+            size_t somewhat_big = very_big / 2 + 1;
+            size_t not_so_big = (size_t)1 << (4 * sizeof(size_t));
+        
+            TEST(!allocate_field(&s, &data, very_big, 2) && data == oldvalue);
+            TEST(!allocate_field(&s, &data, somewhat_big, 2) && data == oldvalue);
+            TEST(!allocate_field(&s, &data, not_so_big, not_so_big) && data == oldvalue);
+        }
+        
+        pb_free(data);
+    }
+    
+    if (status != 0)
+        fprintf(stdout, "\n\nSome tests FAILED!\n");
+    
+    return status;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/encode_unittests/SConscript
@@ -0,0 +1,5 @@
+# Build and run the stand-alone unit tests for the nanopb encoder part.
+
+Import('env')
+p = env.Program(["encode_unittests.c", "$COMMON/unittestproto.pb.c"])
+env.RunTest(p)
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/encode_unittests/encode_unittests.c
@@ -0,0 +1,355 @@
+/* This includes the whole .c file to get access to static functions. */
+#include "pb_common.c"
+#include "pb_encode.c"
+
+#include <stdio.h>
+#include <string.h>
+#include "unittests.h"
+#include "unittestproto.pb.h"
+
+bool streamcallback(pb_ostream_t *stream, const uint8_t *buf, size_t count)
+{
+    /* Allow only 'x' to be written */
+    while (count--)
+    {
+        if (*buf++ != 'x')
+            return false;
+    }
+    return true;
+}
+
+bool fieldcallback(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    int value = 0x55;
+    if (!pb_encode_tag_for_field(stream, field))
+        return false;
+    return pb_encode_varint(stream, value);
+}
+
+bool crazyfieldcallback(pb_ostream_t *stream, const pb_field_t *field, void * const *arg)
+{
+    /* This callback writes different amount of data the second time. */
+    uint32_t *state = (uint32_t*)arg;
+    *state <<= 8;
+    if (!pb_encode_tag_for_field(stream, field))
+        return false;
+    return pb_encode_varint(stream, *state);
+}
+
+/* Check that expression x writes data y.
+ * Y is a string, which may contain null bytes. Null terminator is ignored.
+ */
+#define WRITES(x, y) \
+memset(buffer, 0xAA, sizeof(buffer)), \
+s = pb_ostream_from_buffer(buffer, sizeof(buffer)), \
+(x) && \
+memcmp(buffer, y, sizeof(y) - 1) == 0 && \
+buffer[sizeof(y) - 1] == 0xAA
+
+int main()
+{
+    int status = 0;
+    
+    {
+        uint8_t buffer1[] = "foobartest1234";
+        uint8_t buffer2[sizeof(buffer1)];
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer2, sizeof(buffer1));
+        
+        COMMENT("Test pb_write and pb_ostream_t");
+        TEST(pb_write(&stream, buffer1, sizeof(buffer1)));
+        TEST(memcmp(buffer1, buffer2, sizeof(buffer1)) == 0);
+        TEST(!pb_write(&stream, buffer1, 1));
+        TEST(stream.bytes_written == sizeof(buffer1));
+    }
+    
+    {
+        uint8_t buffer1[] = "xxxxxxx";
+        pb_ostream_t stream = {&streamcallback, 0, SIZE_MAX, 0};
+        
+        COMMENT("Test pb_write with custom callback");
+        TEST(pb_write(&stream, buffer1, 5));
+        buffer1[0] = 'a';
+        TEST(!pb_write(&stream, buffer1, 5));
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        
+        COMMENT("Test pb_encode_varint")
+        TEST(WRITES(pb_encode_varint(&s, 0), "\0"));
+        TEST(WRITES(pb_encode_varint(&s, 1), "\1"));
+        TEST(WRITES(pb_encode_varint(&s, 0x7F), "\x7F"));
+        TEST(WRITES(pb_encode_varint(&s, 0x80), "\x80\x01"));
+        TEST(WRITES(pb_encode_varint(&s, UINT32_MAX), "\xFF\xFF\xFF\xFF\x0F"));
+        TEST(WRITES(pb_encode_varint(&s, UINT64_MAX), "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"));
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        
+        COMMENT("Test pb_encode_tag")
+        TEST(WRITES(pb_encode_tag(&s, PB_WT_STRING, 5), "\x2A"));
+        TEST(WRITES(pb_encode_tag(&s, PB_WT_VARINT, 99), "\x98\x06"));
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        pb_field_t field = {10, PB_LTYPE_SVARINT};
+        
+        COMMENT("Test pb_encode_tag_for_field")
+        TEST(WRITES(pb_encode_tag_for_field(&s, &field), "\x50"));
+        
+        field.type = PB_LTYPE_FIXED64;
+        TEST(WRITES(pb_encode_tag_for_field(&s, &field), "\x51"));
+        
+        field.type = PB_LTYPE_STRING;
+        TEST(WRITES(pb_encode_tag_for_field(&s, &field), "\x52"));
+        
+        field.type = PB_LTYPE_FIXED32;
+        TEST(WRITES(pb_encode_tag_for_field(&s, &field), "\x55"));
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        
+        COMMENT("Test pb_encode_string")
+        TEST(WRITES(pb_encode_string(&s, (const uint8_t*)"abcd", 4), "\x04""abcd"));
+        TEST(WRITES(pb_encode_string(&s, (const uint8_t*)"abcd\x00", 5), "\x05""abcd\x00"));
+        TEST(WRITES(pb_encode_string(&s, (const uint8_t*)"", 0), "\x00"));
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        uint8_t value = 1;
+        int32_t max = INT32_MAX;
+        int32_t min = INT32_MIN;
+        int64_t lmax = INT64_MAX;
+        int64_t lmin = INT64_MIN;
+        pb_field_t field = {1, PB_LTYPE_VARINT, 0, 0, sizeof(value)};
+        
+        COMMENT("Test pb_enc_varint and pb_enc_svarint")
+        TEST(WRITES(pb_enc_varint(&s, &field, &value), "\x01"));
+        
+        field.data_size = sizeof(max);
+        TEST(WRITES(pb_enc_svarint(&s, &field, &max), "\xfe\xff\xff\xff\x0f"));
+        TEST(WRITES(pb_enc_svarint(&s, &field, &min), "\xff\xff\xff\xff\x0f"));
+        
+        field.data_size = sizeof(lmax);
+        TEST(WRITES(pb_enc_svarint(&s, &field, &lmax), "\xFE\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"));
+        TEST(WRITES(pb_enc_svarint(&s, &field, &lmin), "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF\x01"));
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        float fvalue;
+        double dvalue;
+        
+        COMMENT("Test pb_enc_fixed32 using float")
+        fvalue = 0.0f;
+        TEST(WRITES(pb_enc_fixed32(&s, NULL, &fvalue), "\x00\x00\x00\x00"))
+        fvalue = 99.0f;
+        TEST(WRITES(pb_enc_fixed32(&s, NULL, &fvalue), "\x00\x00\xc6\x42"))
+        fvalue = -12345678.0f;
+        TEST(WRITES(pb_enc_fixed32(&s, NULL, &fvalue), "\x4e\x61\x3c\xcb"))
+    
+        COMMENT("Test pb_enc_fixed64 using double")
+        dvalue = 0.0;
+        TEST(WRITES(pb_enc_fixed64(&s, NULL, &dvalue), "\x00\x00\x00\x00\x00\x00\x00\x00"))
+        dvalue = 99.0;
+        TEST(WRITES(pb_enc_fixed64(&s, NULL, &dvalue), "\x00\x00\x00\x00\x00\xc0\x58\x40"))
+        dvalue = -12345678.0;
+        TEST(WRITES(pb_enc_fixed64(&s, NULL, &dvalue), "\x00\x00\x00\xc0\x29\x8c\x67\xc1"))
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        struct { pb_size_t size; uint8_t bytes[5]; } value = {5, {'x', 'y', 'z', 'z', 'y'}};
+    
+        COMMENT("Test pb_enc_bytes")
+        TEST(WRITES(pb_enc_bytes(&s, &BytesMessage_fields[0], &value), "\x05xyzzy"))
+        value.size = 0;
+        TEST(WRITES(pb_enc_bytes(&s, &BytesMessage_fields[0], &value), "\x00"))
+    }
+    
+    {
+        uint8_t buffer[30];
+        pb_ostream_t s;
+        char value[30] = "xyzzy";
+        
+        COMMENT("Test pb_enc_string")
+        TEST(WRITES(pb_enc_string(&s, &StringMessage_fields[0], &value), "\x05xyzzy"))
+        value[0] = '\0';
+        TEST(WRITES(pb_enc_string(&s, &StringMessage_fields[0], &value), "\x00"))
+        memset(value, 'x', 30);
+        TEST(WRITES(pb_enc_string(&s, &StringMessage_fields[0], &value), "\x0Axxxxxxxxxx"))
+    }
+    
+    {
+        uint8_t buffer[10];
+        pb_ostream_t s;
+        IntegerArray msg = {5, {1, 2, 3, 4, 5}};
+        
+        COMMENT("Test pb_encode with int32 array")
+        
+        TEST(WRITES(pb_encode(&s, IntegerArray_fields, &msg), "\x0A\x05\x01\x02\x03\x04\x05"))
+        
+        msg.data_count = 0;
+        TEST(WRITES(pb_encode(&s, IntegerArray_fields, &msg), ""))
+        
+        msg.data_count = 10;
+        TEST(!pb_encode(&s, IntegerArray_fields, &msg))
+    }
+    
+    {
+        uint8_t buffer[10];
+        pb_ostream_t s;
+        FloatArray msg = {1, {99.0f}};
+        
+        COMMENT("Test pb_encode with float array")
+        
+        TEST(WRITES(pb_encode(&s, FloatArray_fields, &msg),
+                    "\x0A\x04\x00\x00\xc6\x42"))
+        
+        msg.data_count = 0;
+        TEST(WRITES(pb_encode(&s, FloatArray_fields, &msg), ""))
+        
+        msg.data_count = 3;
+        TEST(!pb_encode(&s, FloatArray_fields, &msg))
+    }
+    
+    {
+        uint8_t buffer[50];
+        pb_ostream_t s;
+        FloatArray msg = {1, {99.0f}};
+        
+        COMMENT("Test array size limit in pb_encode")
+        
+        s = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        TEST((msg.data_count = 10) && pb_encode(&s, FloatArray_fields, &msg))
+        
+        s = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        TEST((msg.data_count = 11) && !pb_encode(&s, FloatArray_fields, &msg))
+    }
+    
+    {
+        uint8_t buffer[10];
+        pb_ostream_t s;
+        CallbackArray msg;
+        
+        msg.data.funcs.encode = &fieldcallback;
+        
+        COMMENT("Test pb_encode with callback field.")
+        TEST(WRITES(pb_encode(&s, CallbackArray_fields, &msg), "\x08\x55"))
+    }
+    
+    {
+        uint8_t buffer[10];
+        pb_ostream_t s;
+        IntegerContainer msg = {{5, {1,2,3,4,5}}};
+        
+        COMMENT("Test pb_encode with packed array in a submessage.")
+        TEST(WRITES(pb_encode(&s, IntegerContainer_fields, &msg),
+                    "\x0A\x07\x0A\x05\x01\x02\x03\x04\x05"))
+    }
+    
+    {
+        uint8_t buffer[32];
+        pb_ostream_t s;
+        BytesMessage msg = {{3, "xyz"}};
+        
+        COMMENT("Test pb_encode with bytes message.")
+        TEST(WRITES(pb_encode(&s, BytesMessage_fields, &msg),
+                    "\x0A\x03xyz"))
+        
+        msg.data.size = 17; /* More than maximum */
+        TEST(!pb_encode(&s, BytesMessage_fields, &msg))
+    }
+        
+    
+    {
+        uint8_t buffer[20];
+        pb_ostream_t s;
+        IntegerContainer msg = {{5, {1,2,3,4,5}}};
+        
+        COMMENT("Test pb_encode_delimited.")
+        TEST(WRITES(pb_encode_delimited(&s, IntegerContainer_fields, &msg),
+                    "\x09\x0A\x07\x0A\x05\x01\x02\x03\x04\x05"))
+    }
+
+    {
+        IntegerContainer msg = {{5, {1,2,3,4,5}}};
+        size_t size;
+        
+        COMMENT("Test pb_get_encoded_size.")
+        TEST(pb_get_encoded_size(&size, IntegerContainer_fields, &msg) &&
+             size == 9);
+    }
+    
+    {
+        uint8_t buffer[10];
+        pb_ostream_t s;
+        CallbackContainer msg;
+        CallbackContainerContainer msg2;
+        uint32_t state = 1;
+        
+        msg.submsg.data.funcs.encode = &fieldcallback;
+        msg2.submsg.submsg.data.funcs.encode = &fieldcallback;
+        
+        COMMENT("Test pb_encode with callback field in a submessage.")
+        TEST(WRITES(pb_encode(&s, CallbackContainer_fields, &msg), "\x0A\x02\x08\x55"))
+        TEST(WRITES(pb_encode(&s, CallbackContainerContainer_fields, &msg2),
+                    "\x0A\x04\x0A\x02\x08\x55"))
+        
+        /* Misbehaving callback: varying output between calls */
+        msg.submsg.data.funcs.encode = &crazyfieldcallback;
+        msg.submsg.data.arg = &state;
+        msg2.submsg.submsg.data.funcs.encode = &crazyfieldcallback;
+        msg2.submsg.submsg.data.arg = &state;
+        
+        TEST(!pb_encode(&s, CallbackContainer_fields, &msg))
+        state = 1;
+        TEST(!pb_encode(&s, CallbackContainerContainer_fields, &msg2))
+    }
+    
+    {
+        uint8_t buffer[StringMessage_size];
+        pb_ostream_t s;
+        StringMessage msg = {"0123456789"};
+        
+        s = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        COMMENT("Test that StringMessage_size is correct")
+
+        TEST(pb_encode(&s, StringMessage_fields, &msg));
+        TEST(s.bytes_written == StringMessage_size);
+    }
+    
+    {
+        uint8_t buffer[128];
+        pb_ostream_t s;
+        StringPointerContainer msg = StringPointerContainer_init_zero;
+        char *strs[1] = {NULL};
+        char zstr[] = "Z";
+        
+        COMMENT("Test string pointer encoding.");
+        
+        msg.rep_str = strs;
+        msg.rep_str_count = 1;
+        TEST(WRITES(pb_encode(&s, StringPointerContainer_fields, &msg), "\x0a\x00"))
+        
+        strs[0] = zstr;
+        TEST(WRITES(pb_encode(&s, StringPointerContainer_fields, &msg), "\x0a\x01Z"))
+    }
+    
+    if (status != 0)
+        fprintf(stdout, "\n\nSome tests FAILED!\n");
+    
+    return status;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/enum_sizes/SConscript
@@ -0,0 +1,12 @@
+# Test that different sizes of enum fields are properly encoded and decoded.
+
+Import('env')
+
+env.NanopbProto('enumsizes')
+
+p = env.Program(["enumsizes_unittests.c",
+                 "enumsizes.pb.c",
+                 "$COMMON/pb_encode.o",
+                 "$COMMON/pb_decode.o",
+                 "$COMMON/pb_common.o"])
+env.RunTest(p)
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/enum_sizes/enumsizes.proto
@@ -0,0 +1,86 @@
+/* Test handling of enums with different value ranges.
+ * Depending on compiler and the packed_enum setting, the datatypes
+ * for enums can be either signed or unsigned. In past this has caused
+ * a bit of a problem for the encoder/decoder (issue #164).
+ */
+
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+option (nanopb_fileopt).long_names = false;
+
+enum UnpackedUint8 {
+    option (nanopb_enumopt).packed_enum = false;
+    UU8_MIN = 0;
+    UU8_MAX = 255;
+}
+
+enum PackedUint8 {
+    option (nanopb_enumopt).packed_enum = true;
+    PU8_MIN = 0;
+    PU8_MAX = 255;
+}
+
+enum UnpackedInt8 {
+    option (nanopb_enumopt).packed_enum = false;
+    UI8_MIN = -128;
+    UI8_MAX = 127;
+}
+
+enum PackedInt8 {
+    option (nanopb_enumopt).packed_enum = true;
+    PI8_MIN = -128;
+    PI8_MAX = 127;
+}
+
+enum UnpackedUint16 {
+    option (nanopb_enumopt).packed_enum = false;
+    UU16_MIN = 0;
+    UU16_MAX = 65535;
+}
+
+enum PackedUint16 {
+    option (nanopb_enumopt).packed_enum = true;
+    PU16_MIN = 0;
+    PU16_MAX = 65535;
+}
+
+enum UnpackedInt16 {
+    option (nanopb_enumopt).packed_enum = false;
+    UI16_MIN = -32768;
+    UI16_MAX = 32767;
+}
+
+enum PackedInt16 {
+    option (nanopb_enumopt).packed_enum = true;
+    PI16_MIN = -32768;
+    PI16_MAX = 32767;
+}
+
+/* Protobuf supports enums up to 32 bits.
+ * The 32 bit case is covered by HugeEnum in the alltypes test.
+ */
+
+message PackedEnums {
+    required PackedUint8  u8_min  = 1;
+    required PackedUint8  u8_max  = 2;
+    required PackedInt8   i8_min  = 3;
+    required PackedInt8   i8_max  = 4;
+    required PackedUint16 u16_min = 5;
+    required PackedUint16 u16_max = 6;
+    required PackedInt16  i16_min = 7;
+    required PackedInt16  i16_max = 8;
+}
+
+message UnpackedEnums {
+    required UnpackedUint8  u8_min  = 1;
+    required UnpackedUint8  u8_max  = 2;
+    required UnpackedInt8   i8_min  = 3;
+    required UnpackedInt8   i8_max  = 4;
+    required UnpackedUint16 u16_min = 5;
+    required UnpackedUint16 u16_max = 6;
+    required UnpackedInt16  i16_min = 7;
+    required UnpackedInt16  i16_max = 8;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/enum_sizes/enumsizes_unittests.c
@@ -0,0 +1,72 @@
+#include <stdio.h>
+#include <string.h>
+#include <pb_decode.h>
+#include <pb_encode.h>
+#include "unittests.h"
+#include "enumsizes.pb.h"
+
+int main()
+{
+    int status = 0;
+
+    UnpackedEnums msg1 = {
+        UU8_MIN,  UU8_MAX,
+        UI8_MIN,  UI8_MAX,
+        UU16_MIN, UU16_MAX,
+        UI16_MIN, UI16_MAX,
+    };
+    
+    PackedEnums msg2;
+    UnpackedEnums msg3;
+    uint8_t buf[256];
+    size_t msgsize;
+    
+    COMMENT("Step 1: unpacked enums -> protobuf");
+    {
+        pb_ostream_t s = pb_ostream_from_buffer(buf, sizeof(buf));
+        TEST(pb_encode(&s, UnpackedEnums_fields, &msg1));
+        msgsize = s.bytes_written;
+    }
+    
+    COMMENT("Step 2: protobuf -> packed enums");
+    {
+        pb_istream_t s = pb_istream_from_buffer(buf, msgsize);
+        TEST(pb_decode(&s, PackedEnums_fields, &msg2));
+        
+        TEST(msg1.u8_min  == (int)msg2.u8_min);
+        TEST(msg1.u8_max  == (int)msg2.u8_max);
+        TEST(msg1.i8_min  == (int)msg2.i8_min);
+        TEST(msg1.i8_max  == (int)msg2.i8_max);
+        TEST(msg1.u16_min == (int)msg2.u16_min);
+        TEST(msg1.u16_max == (int)msg2.u16_max);
+        TEST(msg1.i16_min == (int)msg2.i16_min);
+        TEST(msg1.i16_max == (int)msg2.i16_max);
+    }
+    
+    COMMENT("Step 3: packed enums -> protobuf");
+    {
+        pb_ostream_t s = pb_ostream_from_buffer(buf, sizeof(buf));
+        TEST(pb_encode(&s, PackedEnums_fields, &msg2));
+        msgsize = s.bytes_written;
+    }
+    
+    COMMENT("Step 4: protobuf -> unpacked enums");
+    {
+        pb_istream_t s = pb_istream_from_buffer(buf, msgsize);
+        TEST(pb_decode(&s, UnpackedEnums_fields, &msg3));
+
+        TEST(msg1.u8_min  == (int)msg3.u8_min);
+        TEST(msg1.u8_max  == (int)msg3.u8_max);
+        TEST(msg1.i8_min  == (int)msg3.i8_min);
+        TEST(msg1.i8_max  == (int)msg3.i8_max);
+        TEST(msg1.u16_min == (int)msg2.u16_min);
+        TEST(msg1.u16_max == (int)msg2.u16_max);
+        TEST(msg1.i16_min == (int)msg2.i16_min);
+        TEST(msg1.i16_max == (int)msg2.i16_max);
+    }
+
+    if (status != 0)
+        fprintf(stdout, "\n\nSome tests FAILED!\n");
+
+    return status;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extensions/SConscript
@@ -0,0 +1,16 @@
+# Test the support for extension fields.
+
+Import("env")
+
+# We use the files from the alltypes test case
+incpath = env.Clone()
+incpath.Append(PROTOCPATH = '$BUILD/alltypes')
+incpath.Append(CPPPATH = '$BUILD/alltypes')
+
+incpath.NanopbProto(["extensions", "extensions.options"])
+enc = incpath.Program(["encode_extensions.c", "extensions.pb.c", "$BUILD/alltypes/alltypes.pb$OBJSUFFIX", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+dec = incpath.Program(["decode_extensions.c", "extensions.pb.c", "$BUILD/alltypes/alltypes.pb$OBJSUFFIX", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_extensions.output"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extensions/decode_extensions.c
@@ -0,0 +1,60 @@
+/* Test decoding of extension fields. */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pb_decode.h>
+#include "alltypes.pb.h"
+#include "extensions.pb.h"
+#include "test_helpers.h"
+
+#define TEST(x) if (!(x)) { \
+    printf("Test " #x " failed.\n"); \
+    return 2; \
+    }
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[1024];
+    size_t count;
+    pb_istream_t stream;
+    
+    AllTypes alltypes = {0};
+    int32_t extensionfield1;
+    pb_extension_t ext1;
+    ExtensionMessage extensionfield2;
+    pb_extension_t ext2;
+    
+    /* Read the message data */
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+    stream = pb_istream_from_buffer(buffer, count);
+    
+    /* Add the extensions */
+    alltypes.extensions = &ext1;        
+
+    ext1.type = &AllTypes_extensionfield1;
+    ext1.dest = &extensionfield1;
+    ext1.next = &ext2;
+    
+    ext2.type = &ExtensionMessage_AllTypes_extensionfield2;
+    ext2.dest = &extensionfield2;
+    ext2.next = NULL;
+    
+    /* Decode the message */
+    if (!pb_decode(&stream, AllTypes_fields, &alltypes))
+    {
+        printf("Parsing failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    }
+
+    /* Check that the extensions decoded properly */
+    TEST(ext1.found)
+    TEST(extensionfield1 == 12345)
+    TEST(ext2.found)
+    TEST(strcmp(extensionfield2.test1, "test") == 0)
+    TEST(extensionfield2.test2 == 54321)
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extensions/encode_extensions.c
@@ -0,0 +1,54 @@
+/* Tests extension fields.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "alltypes.pb.h"
+#include "extensions.pb.h"
+#include "test_helpers.h"
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[1024];
+    pb_ostream_t stream;
+
+    AllTypes alltypes = {0};
+    int32_t extensionfield1 = 12345;
+    pb_extension_t ext1;
+    ExtensionMessage extensionfield2 = {"test", 54321};
+    pb_extension_t ext2;
+
+    /* Set up the extensions */
+    alltypes.extensions = &ext1;
+
+    ext1.type = &AllTypes_extensionfield1;
+    ext1.dest = &extensionfield1;
+    ext1.next = &ext2;
+    
+    ext2.type = &ExtensionMessage_AllTypes_extensionfield2;
+    ext2.dest = &extensionfield2;
+    ext2.next = NULL;
+
+    /* Set up the output stream */
+    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+    
+    /* Now encode the message and check if we succeeded. */
+    if (pb_encode(&stream, AllTypes_fields, &alltypes))
+    {
+        SET_BINARY_MODE(stdout);
+        fwrite(buffer, 1, stream.bytes_written, stdout);
+        return 0; /* Success */
+    }
+    else
+    {
+        fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+        return 1; /* Failure */
+    }
+    
+    /* Check that the field tags are properly generated */
+    (void)AllTypes_extensionfield1_tag;
+    (void)ExtensionMessage_AllTypes_extensionfield2_tag;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extensions/extensions.options
@@ -0,0 +1 @@
+* max_size:16
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extensions/extensions.proto
@@ -0,0 +1,19 @@
+syntax = "proto2";
+
+import 'alltypes.proto';
+
+extend AllTypes {
+    optional int32 AllTypes_extensionfield1 = 255 [default = 5];
+}
+
+message ExtensionMessage {
+    extend AllTypes {
+        optional ExtensionMessage AllTypes_extensionfield2 = 254;
+        // required ExtensionMessage AllTypes_extensionfield3 = 253; // No longer allowed by protobuf 3
+        repeated ExtensionMessage AllTypes_extensionfield4 = 252;
+    }
+    
+    required string test1 = 1;
+    required int32 test2 = 2;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extra_fields/SConscript
@@ -0,0 +1,16 @@
+# Test that the decoder properly handles unknown fields in the input.
+
+Import("env")
+
+dec = env.GetBuildPath('$BUILD/basic_buffer/${PROGPREFIX}decode_buffer${PROGSUFFIX}')
+env.RunTest('person_with_extra_field.output', [dec, "person_with_extra_field.pb"])
+env.Compare(["person_with_extra_field.output", "person_with_extra_field.expected"])
+
+dec = env.GetBuildPath('$BUILD/basic_stream/${PROGPREFIX}decode_stream${PROGSUFFIX}')
+env.RunTest('person_with_extra_field_stream.output', [dec, "person_with_extra_field.pb"])
+env.Compare(["person_with_extra_field_stream.output", "person_with_extra_field.expected"])
+
+# This uses the backwards compatibility alltypes test, so that
+# alltypes_with_extra_fields.pb doesn't have to be remade so often.
+dec2 = env.GetBuildPath('$BUILD/backwards_compatibility/${PROGPREFIX}decode_legacy${PROGSUFFIX}')
+env.RunTest('alltypes_with_extra_fields.output', [dec2, 'alltypes_with_extra_fields.pb'])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/extra_fields/person_with_extra_field.expected
@@ -0,0 +1,14 @@
+name: "Test Person 99"
+id: 99
+email: "test@person.com"
+phone {
+  number: "555-12345678"
+  type: MOBILE
+}
+phone {
+  number: "99-2342"
+}
+phone {
+  number: "1234-5678"
+  type: WORK
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/field_size_16/SConscript
@@ -0,0 +1,29 @@
+# Run the alltypes test case, but compile with PB_FIELD_16BIT=1.
+# Also the .proto file has been modified to have high indexes.
+
+Import("env")
+
+# Take copy of the files for custom build.
+c = Copy("$TARGET", "$SOURCE")
+env.Command("encode_alltypes.c", "$BUILD/alltypes/encode_alltypes.c", c)
+env.Command("decode_alltypes.c", "$BUILD/alltypes/decode_alltypes.c", c)
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+
+# Define the compilation options
+opts = env.Clone()
+opts.Append(CPPDEFINES = {'PB_FIELD_16BIT': 1})
+
+# Build new version of core
+strict = opts.Clone()
+strict.Append(CFLAGS = strict['CORECFLAGS'])
+strict.Object("pb_decode_fields16.o", "$NANOPB/pb_decode.c")
+strict.Object("pb_encode_fields16.o", "$NANOPB/pb_encode.c")
+strict.Object("pb_common_fields16.o", "$NANOPB/pb_common.c")
+
+# Now build and run the test normally.
+enc = opts.Program(["encode_alltypes.c", "alltypes.pb.c", "pb_encode_fields16.o", "pb_common_fields16.o"])
+dec = opts.Program(["decode_alltypes.c", "alltypes.pb.c", "pb_decode_fields16.o", "pb_common_fields16.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_alltypes.output"])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/field_size_16/alltypes.options
@@ -0,0 +1,3 @@
+* max_size:16
+* max_count:5
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/field_size_16/alltypes.proto
@@ -0,0 +1,121 @@
+syntax = "proto2";
+
+message SubMessage {
+    required string substuff1 = 1 [default = "1"];
+    required int32 substuff2 = 2 [default = 2];
+    optional fixed32 substuff3 = 65535 [default = 3];
+}
+
+message EmptyMessage {
+
+}
+
+enum HugeEnum {
+    Negative = -2147483647; /* protoc doesn't accept -2147483648 here */
+    Positive =  2147483647;
+}
+
+message Limits {
+    required int32      int32_min  =  1;
+    required int32      int32_max  =  2;
+    required uint32     uint32_min =  3;
+    required uint32     uint32_max =  4;
+    required int64      int64_min  =  5;
+    required int64      int64_max  =  6;
+    required uint64     uint64_min =  7;
+    required uint64     uint64_max =  8;
+    required HugeEnum   enum_min   =  9;
+    required HugeEnum   enum_max   = 10;
+}
+
+enum MyEnum {
+    Zero = 0;
+    First = 1;
+    Second = 2;
+    Truth = 42;
+}
+
+message AllTypes {
+    required int32      req_int32   = 1;
+    required int64      req_int64   = 2;
+    required uint32     req_uint32  = 3;
+    required uint64     req_uint64  = 4;
+    required sint32     req_sint32  = 5;
+    required sint64     req_sint64  = 6;
+    required bool       req_bool    = 7;
+    
+    required fixed32    req_fixed32 = 8;
+    required sfixed32   req_sfixed32= 9;
+    required float      req_float   = 10;
+    
+    required fixed64    req_fixed64 = 11;
+    required sfixed64   req_sfixed64= 12;
+    required double     req_double  = 13;
+    
+    required string     req_string  = 14;
+    required bytes      req_bytes   = 15;
+    required SubMessage req_submsg  = 16;
+    required MyEnum     req_enum    = 17;
+    required EmptyMessage req_emptymsg = 18;
+    
+    
+    repeated int32      rep_int32   = 21;
+    repeated int64      rep_int64   = 22;
+    repeated uint32     rep_uint32  = 23;
+    repeated uint64     rep_uint64  = 24;
+    repeated sint32     rep_sint32  = 25;
+    repeated sint64     rep_sint64  = 26;
+    repeated bool       rep_bool    = 27;
+    
+    repeated fixed32    rep_fixed32 = 28;
+    repeated sfixed32   rep_sfixed32= 29;
+    repeated float      rep_float   = 30;
+    
+    repeated fixed64    rep_fixed64 = 10031;
+    repeated sfixed64   rep_sfixed64= 10032;
+    repeated double     rep_double  = 10033;
+    
+    repeated string     rep_string  = 10034;
+    repeated bytes      rep_bytes   = 10035;
+    repeated SubMessage rep_submsg  = 10036;
+    repeated MyEnum     rep_enum    = 10037;
+    repeated EmptyMessage rep_emptymsg = 10038;
+    
+    optional int32      opt_int32   = 10041 [default = 4041];
+    optional int64      opt_int64   = 10042 [default = 4042];
+    optional uint32     opt_uint32  = 10043 [default = 4043];
+    optional uint64     opt_uint64  = 10044 [default = 4044];
+    optional sint32     opt_sint32  = 10045 [default = 4045];
+    optional sint64     opt_sint64  = 10046 [default = 4046];
+    optional bool       opt_bool    = 10047 [default = false];
+    
+    optional fixed32    opt_fixed32 = 10048 [default = 4048];
+    optional sfixed32   opt_sfixed32= 10049 [default = 4049];
+    optional float      opt_float   = 10050 [default = 4050];
+    
+    optional fixed64    opt_fixed64 = 10051 [default = 4051];
+    optional sfixed64   opt_sfixed64= 10052 [default = 4052];
+    optional double     opt_double  = 10053 [default = 4053];
+    
+    optional string     opt_string  = 10054 [default = "4054"];
+    optional bytes      opt_bytes   = 10055 [default = "4055"];
+    optional SubMessage opt_submsg  = 10056;
+    optional MyEnum     opt_enum    = 10057 [default = Second];
+    optional EmptyMessage opt_emptymsg = 10058;
+
+    oneof oneof
+    {
+        SubMessage oneof_msg1 = 10059;
+        EmptyMessage oneof_msg2 = 10060;
+    }
+
+    // Check that extreme integer values are handled correctly
+    required Limits     req_limits = 98;
+
+    // Just to make sure that the size of the fields has been calculated
+    // properly, i.e. otherwise a bug in last field might not be detected.
+    required int32      end = 10099;
+
+    extensions 200 to 255;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/field_size_32/SConscript
@@ -0,0 +1,29 @@
+# Run the alltypes test case, but compile with PB_FIELD_32BIT=1.
+# Also the .proto file has been modified to have high indexes.
+
+Import("env")
+
+# Take copy of the files for custom build.
+c = Copy("$TARGET", "$SOURCE")
+env.Command("encode_alltypes.c", "$BUILD/alltypes/encode_alltypes.c", c)
+env.Command("decode_alltypes.c", "$BUILD/alltypes/decode_alltypes.c", c)
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+
+# Define the compilation options
+opts = env.Clone()
+opts.Append(CPPDEFINES = {'PB_FIELD_32BIT': 1})
+
+# Build new version of core
+strict = opts.Clone()
+strict.Append(CFLAGS = strict['CORECFLAGS'])
+strict.Object("pb_decode_fields32.o", "$NANOPB/pb_decode.c")
+strict.Object("pb_encode_fields32.o", "$NANOPB/pb_encode.c")
+strict.Object("pb_common_fields32.o", "$NANOPB/pb_common.c")
+
+# Now build and run the test normally.
+enc = opts.Program(["encode_alltypes.c", "alltypes.pb.c", "pb_encode_fields32.o", "pb_common_fields32.o"])
+dec = opts.Program(["decode_alltypes.c", "alltypes.pb.c", "pb_decode_fields32.o", "pb_common_fields32.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_alltypes.output"])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/field_size_32/alltypes.options
@@ -0,0 +1,3 @@
+* max_size:16
+* max_count:5
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/field_size_32/alltypes.proto
@@ -0,0 +1,121 @@
+syntax = "proto2";
+
+message SubMessage {
+    required string substuff1 = 1 [default = "1"];
+    required int32 substuff2 = 2 [default = 2];
+    optional fixed32 substuff3 = 12365535 [default = 3];
+}
+
+message EmptyMessage {
+
+}
+
+enum HugeEnum {
+    Negative = -2147483647; /* protoc doesn't accept -2147483648 here */
+    Positive =  2147483647;
+}
+
+message Limits {
+    required int32      int32_min  =  1;
+    required int32      int32_max  =  2;
+    required uint32     uint32_min =  3;
+    required uint32     uint32_max =  4;
+    required int64      int64_min  =  5;
+    required int64      int64_max  =  6;
+    required uint64     uint64_min =  7;
+    required uint64     uint64_max =  8;
+    required HugeEnum   enum_min   =  9;
+    required HugeEnum   enum_max   = 10;
+}
+
+enum MyEnum {
+    Zero = 0;
+    First = 1;
+    Second = 2;
+    Truth = 42;
+}
+
+message AllTypes {
+    required int32      req_int32   = 1;
+    required int64      req_int64   = 2;
+    required uint32     req_uint32  = 3;
+    required uint64     req_uint64  = 4;
+    required sint32     req_sint32  = 5;
+    required sint64     req_sint64  = 6;
+    required bool       req_bool    = 7;
+    
+    required fixed32    req_fixed32 = 8;
+    required sfixed32   req_sfixed32= 9;
+    required float      req_float   = 10;
+    
+    required fixed64    req_fixed64 = 11;
+    required sfixed64   req_sfixed64= 12;
+    required double     req_double  = 13;
+    
+    required string     req_string  = 14;
+    required bytes      req_bytes   = 15;
+    required SubMessage req_submsg  = 16;
+    required MyEnum     req_enum    = 17;
+    required EmptyMessage req_emptymsg = 18;
+    
+    
+    repeated int32      rep_int32   = 21;
+    repeated int64      rep_int64   = 22;
+    repeated uint32     rep_uint32  = 23;
+    repeated uint64     rep_uint64  = 24;
+    repeated sint32     rep_sint32  = 25;
+    repeated sint64     rep_sint64  = 26;
+    repeated bool       rep_bool    = 27;
+    
+    repeated fixed32    rep_fixed32 = 28;
+    repeated sfixed32   rep_sfixed32= 29;
+    repeated float      rep_float   = 30;
+    
+    repeated fixed64    rep_fixed64 = 10031;
+    repeated sfixed64   rep_sfixed64= 10032;
+    repeated double     rep_double  = 10033;
+    
+    repeated string     rep_string  = 10034;
+    repeated bytes      rep_bytes   = 10035;
+    repeated SubMessage rep_submsg  = 10036;
+    repeated MyEnum     rep_enum    = 10037;
+    repeated EmptyMessage rep_emptymsg = 10038;
+    
+    optional int32      opt_int32   = 10041 [default = 4041];
+    optional int64      opt_int64   = 10042 [default = 4042];
+    optional uint32     opt_uint32  = 10043 [default = 4043];
+    optional uint64     opt_uint64  = 10044 [default = 4044];
+    optional sint32     opt_sint32  = 10045 [default = 4045];
+    optional sint64     opt_sint64  = 10046 [default = 4046];
+    optional bool       opt_bool    = 10047 [default = false];
+    
+    optional fixed32    opt_fixed32 = 10048 [default = 4048];
+    optional sfixed32   opt_sfixed32= 10049 [default = 4049];
+    optional float      opt_float   = 10050 [default = 4050];
+    
+    optional fixed64    opt_fixed64 = 10051 [default = 4051];
+    optional sfixed64   opt_sfixed64= 10052 [default = 4052];
+    optional double     opt_double  = 10053 [default = 4053];
+    
+    optional string     opt_string  = 10054 [default = "4054"];
+    optional bytes      opt_bytes   = 10055 [default = "4055"];
+    optional SubMessage opt_submsg  = 10056;
+    optional MyEnum     opt_enum    = 10057 [default = Second];
+    optional EmptyMessage opt_emptymsg = 10058;
+
+    oneof oneof
+    {
+        SubMessage oneof_msg1 = 10059;
+        EmptyMessage oneof_msg2 = 10060;
+    }
+
+    // Check that extreme integer values are handled correctly
+    required Limits     req_limits = 98;
+
+    // Just to make sure that the size of the fields has been calculated
+    // properly, i.e. otherwise a bug in last field might not be detected.
+    required int32      end = 13432099;
+
+    extensions 200 to 255;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/SConscript
@@ -0,0 +1,43 @@
+# Run a fuzz test to verify robustness against corrupted/malicious data.
+
+Import("env", "malloc_env")
+
+def set_pkgname(src, dst, pkgname):
+    data = open(str(src)).read()
+    placeholder = '// package name placeholder'
+    assert placeholder in data
+    data = data.replace(placeholder, 'package %s;' % pkgname)
+    open(str(dst), 'w').write(data)
+
+# We want both pointer and static versions of the AllTypes message
+# Prefix them with package name.
+env.Command("alltypes_static.proto", "#alltypes/alltypes.proto",
+            lambda target, source, env: set_pkgname(source[0], target[0], 'alltypes_static'))
+env.Command("alltypes_pointer.proto", "#alltypes/alltypes.proto",
+            lambda target, source, env: set_pkgname(source[0], target[0], 'alltypes_pointer'))
+
+p1 = env.NanopbProto(["alltypes_pointer", "alltypes_pointer.options"])
+p2 = env.NanopbProto(["alltypes_static", "alltypes_static.options"])
+fuzz = malloc_env.Program(["fuzztest.c",
+                    "alltypes_pointer.pb.c",
+                    "alltypes_static.pb.c",
+                    "$COMMON/pb_encode_with_malloc.o",
+                    "$COMMON/pb_decode_with_malloc.o",
+                    "$COMMON/pb_common_with_malloc.o",
+                    "$COMMON/malloc_wrappers.o"])
+
+env.RunTest(fuzz)
+
+fuzzstub = malloc_env.Program(["fuzzstub.c",
+                    "alltypes_pointer.pb.c",
+                    "alltypes_static.pb.c",
+                    "$COMMON/pb_encode_with_malloc.o",
+                    "$COMMON/pb_decode_with_malloc.o",
+                    "$COMMON/pb_common_with_malloc.o",
+                    "$COMMON/malloc_wrappers.o"])
+
+generate_message = malloc_env.Program(["generate_message.c",
+                    "alltypes_static.pb.c",
+                    "$COMMON/pb_encode.o",
+                    "$COMMON/pb_common.o"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/alltypes_pointer.options
@@ -0,0 +1,3 @@
+# Generate all fields as pointers.
+* type:FT_POINTER
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/alltypes_static.options
@@ -0,0 +1,3 @@
+* max_size:32
+* max_count:8
+*.extensions type:FT_IGNORE
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/fuzzstub.c
@@ -0,0 +1,189 @@
+/* Fuzz testing for the nanopb core.
+ * This can be used with external fuzzers, e.g. radamsa.
+ * It performs most of the same checks as fuzztest, but does not feature data generation.
+ */
+
+#include <pb_decode.h>
+#include <pb_encode.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <time.h>
+#include <malloc_wrappers.h>
+#include "alltypes_static.pb.h"
+#include "alltypes_pointer.pb.h"
+
+#define BUFSIZE 4096
+
+static bool do_static_decode(uint8_t *buffer, size_t msglen, bool assert_success)
+{
+    pb_istream_t stream;
+    bool status;
+    
+    alltypes_static_AllTypes *msg = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    stream = pb_istream_from_buffer(buffer, msglen);
+    status = pb_decode(&stream, alltypes_static_AllTypes_fields, msg);
+    
+    if (!status && assert_success)
+    {
+        /* Anything that was successfully encoded, should be decodeable.
+         * One exception: strings without null terminator are encoded up
+         * to end of buffer, but refused on decode because the terminator
+         * would not fit. */
+        if (strcmp(stream.errmsg, "string overflow") != 0)
+            assert(status);
+    }
+    
+    free_with_check(msg);
+    return status;
+}
+
+static bool do_pointer_decode(uint8_t *buffer, size_t msglen, bool assert_success)
+{
+    pb_istream_t stream;
+    bool status;
+    alltypes_pointer_AllTypes *msg;
+    
+    msg = malloc_with_check(sizeof(alltypes_pointer_AllTypes));
+    memset(msg, 0, sizeof(alltypes_pointer_AllTypes));
+    stream = pb_istream_from_buffer(buffer, msglen);
+
+    assert(get_alloc_count() == 0);
+    status = pb_decode(&stream, alltypes_pointer_AllTypes_fields, msg);
+    
+    if (assert_success)
+        assert(status);
+    
+    pb_release(alltypes_pointer_AllTypes_fields, msg);    
+    assert(get_alloc_count() == 0);
+    
+    free_with_check(msg);
+
+    return status;
+}
+
+/* Do a decode -> encode -> decode -> encode roundtrip */
+static void do_static_roundtrip(uint8_t *buffer, size_t msglen)
+{
+    bool status;
+    uint8_t *buf2 = malloc_with_check(BUFSIZE);
+    uint8_t *buf3 = malloc_with_check(BUFSIZE);
+    size_t msglen2, msglen3;
+    alltypes_static_AllTypes *msg1 = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    alltypes_static_AllTypes *msg2 = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    memset(msg1, 0, sizeof(alltypes_static_AllTypes));
+    memset(msg2, 0, sizeof(alltypes_static_AllTypes));
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buffer, msglen);
+        status = pb_decode(&stream, alltypes_static_AllTypes_fields, msg1);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf2, BUFSIZE);
+        status = pb_encode(&stream, alltypes_static_AllTypes_fields, msg1);
+        assert(status);
+        msglen2 = stream.bytes_written;
+    }
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buf2, msglen2);
+        status = pb_decode(&stream, alltypes_static_AllTypes_fields, msg2);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf3, BUFSIZE);
+        status = pb_encode(&stream, alltypes_static_AllTypes_fields, msg2);
+        assert(status);
+        msglen3 = stream.bytes_written;
+    }
+    
+    assert(msglen2 == msglen3);
+    assert(memcmp(buf2, buf3, msglen2) == 0);
+    
+    free_with_check(msg1);
+    free_with_check(msg2);
+    free_with_check(buf2);
+    free_with_check(buf3);
+}
+
+/* Do decode -> encode -> decode -> encode roundtrip */
+static void do_pointer_roundtrip(uint8_t *buffer, size_t msglen)
+{
+    bool status;
+    uint8_t *buf2 = malloc_with_check(BUFSIZE);
+    uint8_t *buf3 = malloc_with_check(BUFSIZE);
+    size_t msglen2, msglen3;
+    alltypes_pointer_AllTypes *msg1 = malloc_with_check(sizeof(alltypes_pointer_AllTypes));
+    alltypes_pointer_AllTypes *msg2 = malloc_with_check(sizeof(alltypes_pointer_AllTypes));
+    memset(msg1, 0, sizeof(alltypes_pointer_AllTypes));
+    memset(msg2, 0, sizeof(alltypes_pointer_AllTypes));
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buffer, msglen);
+        status = pb_decode(&stream, alltypes_pointer_AllTypes_fields, msg1);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf2, BUFSIZE);
+        status = pb_encode(&stream, alltypes_pointer_AllTypes_fields, msg1);
+        assert(status);
+        msglen2 = stream.bytes_written;
+    }
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buf2, msglen2);
+        status = pb_decode(&stream, alltypes_pointer_AllTypes_fields, msg2);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf3, BUFSIZE);
+        status = pb_encode(&stream, alltypes_pointer_AllTypes_fields, msg2);
+        assert(status);
+        msglen3 = stream.bytes_written;
+    }
+    
+    assert(msglen2 == msglen3);
+    assert(memcmp(buf2, buf3, msglen2) == 0);
+    
+    pb_release(alltypes_pointer_AllTypes_fields, msg1);
+    pb_release(alltypes_pointer_AllTypes_fields, msg2);
+    free_with_check(msg1);
+    free_with_check(msg2);
+    free_with_check(buf2);
+    free_with_check(buf3);
+}
+
+static void run_iteration()
+{
+    uint8_t *buffer = malloc_with_check(BUFSIZE);
+    size_t msglen;
+    bool status;
+    
+    msglen = fread(buffer, 1, BUFSIZE, stdin);
+
+    status = do_static_decode(buffer, msglen, false);
+    
+    if (status)
+        do_static_roundtrip(buffer, msglen);
+    
+    status = do_pointer_decode(buffer, msglen, false);
+    
+    if (status)
+        do_pointer_roundtrip(buffer, msglen);
+    
+    free_with_check(buffer);
+}
+
+int main(int argc, char **argv)
+{
+    run_iteration();
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/fuzztest.c
@@ -0,0 +1,432 @@
+/* Fuzz testing for the nanopb core.
+ * Attempts to verify all the properties defined in the security model document.
+ */
+
+#include <pb_decode.h>
+#include <pb_encode.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <time.h>
+#include <malloc_wrappers.h>
+#include "alltypes_static.pb.h"
+#include "alltypes_pointer.pb.h"
+
+static uint64_t random_seed;
+
+/* Uses xorshift64 here instead of rand() for both speed and
+ * reproducibility across platforms. */
+static uint32_t rand_word()
+{
+    random_seed ^= random_seed >> 12;
+    random_seed ^= random_seed << 25;
+    random_seed ^= random_seed >> 27;
+    return random_seed * 2685821657736338717ULL;
+}
+
+/* Get a random integer in range, with approximately flat distribution. */
+static int rand_int(int min, int max)
+{
+    return rand_word() % (max + 1 - min) + min;
+}
+
+static bool rand_bool()
+{
+    return rand_word() & 1;
+}
+
+/* Get a random byte, with skewed distribution.
+ * Important corner cases like 0xFF, 0x00 and 0xFE occur more
+ * often than other values. */
+static uint8_t rand_byte()
+{
+    uint32_t w = rand_word();
+    uint8_t b = w & 0xFF;
+    if (w & 0x100000)
+        b >>= (w >> 8) & 7;
+    if (w & 0x200000)
+        b <<= (w >> 12) & 7;
+    if (w & 0x400000)
+        b ^= 0xFF;
+    return b;
+}
+
+/* Get a random length, with skewed distribution.
+ * Favors the shorter lengths, but always atleast 1. */
+static size_t rand_len(size_t max)
+{
+    uint32_t w = rand_word();
+    size_t s;
+    if (w & 0x800000)
+        w &= 3;
+    else if (w & 0x400000)
+        w &= 15;
+    else if (w & 0x200000)
+        w &= 255;
+
+    s = (w % max);
+    if (s == 0)
+        s = 1;
+    
+    return s;
+}
+
+/* Fills a buffer with random data with skewed distribution. */
+static void rand_fill(uint8_t *buf, size_t count)
+{
+    while (count--)
+        *buf++ = rand_byte();
+}
+
+/* Fill with random protobuf-like data */
+static size_t rand_fill_protobuf(uint8_t *buf, size_t min_bytes, size_t max_bytes, int min_tag)
+{
+    pb_ostream_t stream = pb_ostream_from_buffer(buf, max_bytes);
+
+    while(stream.bytes_written < min_bytes)
+    {
+        pb_wire_type_t wt = rand_int(0, 3);
+        if (wt == 3) wt = 5; /* Gap in values */
+        
+        if (!pb_encode_tag(&stream, wt, rand_int(min_tag, min_tag + 512)))
+            break;
+    
+        if (wt == PB_WT_VARINT)
+        {
+            uint64_t value;
+            rand_fill((uint8_t*)&value, sizeof(value));
+            pb_encode_varint(&stream, value);
+        }
+        else if (wt == PB_WT_64BIT)
+        {
+            uint64_t value;
+            rand_fill((uint8_t*)&value, sizeof(value));
+            pb_encode_fixed64(&stream, &value);
+        }
+        else if (wt == PB_WT_32BIT)
+        {
+            uint32_t value;
+            rand_fill((uint8_t*)&value, sizeof(value));
+            pb_encode_fixed32(&stream, &value);
+        }
+        else if (wt == PB_WT_STRING)
+        {
+            size_t len;
+            uint8_t *buf;
+            
+            if (min_bytes > stream.bytes_written)
+                len = rand_len(min_bytes - stream.bytes_written);
+            else
+                len = 0;
+            
+            buf = malloc(len);
+            pb_encode_varint(&stream, len);
+            rand_fill(buf, len);
+            pb_write(&stream, buf, len);
+            free(buf);
+        }
+    }
+    
+    return stream.bytes_written;
+}
+
+/* Given a buffer of data, mess it up a bit */
+static void rand_mess(uint8_t *buf, size_t count)
+{
+    int m = rand_int(0, 3);
+    
+    if (m == 0)
+    {
+        /* Replace random substring */
+        int s = rand_int(0, count - 1);
+        int l = rand_len(count - s);
+        rand_fill(buf + s, l);
+    }
+    else if (m == 1)
+    {
+        /* Swap random bytes */
+        int a = rand_int(0, count - 1);
+        int b = rand_int(0, count - 1);
+        int x = buf[a];
+        buf[a] = buf[b];
+        buf[b] = x;
+    }
+    else if (m == 2)
+    {
+        /* Duplicate substring */
+        int s = rand_int(0, count - 2);
+        int l = rand_len((count - s) / 2);
+        memcpy(buf + s + l, buf + s, l);
+    }
+    else if (m == 3)
+    {
+        /* Add random protobuf noise */
+        int s = rand_int(0, count - 1);
+        int l = rand_len(count - s);
+        rand_fill_protobuf(buf + s, l, count - s, 1);
+    }
+}
+
+/* Some default data to put in the message */
+static const alltypes_static_AllTypes initval = alltypes_static_AllTypes_init_default;
+
+#define BUFSIZE 4096
+
+static bool do_static_encode(uint8_t *buffer, size_t *msglen)
+{
+    pb_ostream_t stream;
+    bool status;
+
+    /* Allocate a message and fill it with defaults */
+    alltypes_static_AllTypes *msg = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    memcpy(msg, &initval, sizeof(initval));
+
+    /* Apply randomness to the data before encoding */
+    while (rand_int(0, 7))
+        rand_mess((uint8_t*)msg, sizeof(alltypes_static_AllTypes));
+
+    stream = pb_ostream_from_buffer(buffer, BUFSIZE);
+    status = pb_encode(&stream, alltypes_static_AllTypes_fields, msg);
+    assert(stream.bytes_written <= BUFSIZE);
+    assert(stream.bytes_written <= alltypes_static_AllTypes_size);
+    
+    *msglen = stream.bytes_written;
+    pb_release(alltypes_static_AllTypes_fields, msg);
+    free_with_check(msg);
+    
+    return status;
+}
+
+/* Append or prepend protobuf noise */
+static void do_protobuf_noise(uint8_t *buffer, size_t *msglen)
+{
+    int m = rand_int(0, 2);
+    size_t max_size = BUFSIZE - 32 - *msglen;
+    if (m == 1)
+    {
+        /* Prepend */
+        uint8_t *tmp = malloc_with_check(BUFSIZE);
+        size_t s = rand_fill_protobuf(tmp, rand_len(max_size), BUFSIZE - *msglen, 512);
+        memmove(buffer + s, buffer, *msglen);
+        memcpy(buffer, tmp, s);
+        free_with_check(tmp);
+        *msglen += s;
+    }
+    else if (m == 2)
+    {
+        /* Append */
+        size_t s = rand_fill_protobuf(buffer + *msglen, rand_len(max_size), BUFSIZE - *msglen, 512);
+        *msglen += s;
+    }
+}
+
+static bool do_static_decode(uint8_t *buffer, size_t msglen, bool assert_success)
+{
+    pb_istream_t stream;
+    bool status;
+    
+    alltypes_static_AllTypes *msg = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    rand_fill((uint8_t*)msg, sizeof(alltypes_static_AllTypes));
+    stream = pb_istream_from_buffer(buffer, msglen);
+    status = pb_decode(&stream, alltypes_static_AllTypes_fields, msg);
+    
+    if (!status && assert_success)
+    {
+        /* Anything that was successfully encoded, should be decodeable.
+         * One exception: strings without null terminator are encoded up
+         * to end of buffer, but refused on decode because the terminator
+         * would not fit. */
+        if (strcmp(stream.errmsg, "string overflow") != 0)
+            assert(status);
+    }
+    
+    free_with_check(msg);
+    return status;
+}
+
+static bool do_pointer_decode(uint8_t *buffer, size_t msglen, bool assert_success)
+{
+    pb_istream_t stream;
+    bool status;
+    alltypes_pointer_AllTypes *msg;
+    
+    msg = malloc_with_check(sizeof(alltypes_pointer_AllTypes));
+    memset(msg, 0, sizeof(alltypes_pointer_AllTypes));
+    stream = pb_istream_from_buffer(buffer, msglen);
+
+    assert(get_alloc_count() == 0);
+    status = pb_decode(&stream, alltypes_pointer_AllTypes_fields, msg);
+    
+    if (assert_success)
+        assert(status);
+    
+    pb_release(alltypes_pointer_AllTypes_fields, msg);    
+    assert(get_alloc_count() == 0);
+    
+    free_with_check(msg);
+
+    return status;
+}
+
+/* Do a decode -> encode -> decode -> encode roundtrip */
+static void do_static_roundtrip(uint8_t *buffer, size_t msglen)
+{
+    bool status;
+    uint8_t *buf2 = malloc_with_check(BUFSIZE);
+    uint8_t *buf3 = malloc_with_check(BUFSIZE);
+    size_t msglen2, msglen3;
+    alltypes_static_AllTypes *msg1 = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    alltypes_static_AllTypes *msg2 = malloc_with_check(sizeof(alltypes_static_AllTypes));
+    memset(msg1, 0, sizeof(alltypes_static_AllTypes));
+    memset(msg2, 0, sizeof(alltypes_static_AllTypes));
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buffer, msglen);
+        status = pb_decode(&stream, alltypes_static_AllTypes_fields, msg1);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf2, BUFSIZE);
+        status = pb_encode(&stream, alltypes_static_AllTypes_fields, msg1);
+        assert(status);
+        msglen2 = stream.bytes_written;
+    }
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buf2, msglen2);
+        status = pb_decode(&stream, alltypes_static_AllTypes_fields, msg2);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf3, BUFSIZE);
+        status = pb_encode(&stream, alltypes_static_AllTypes_fields, msg2);
+        assert(status);
+        msglen3 = stream.bytes_written;
+    }
+    
+    assert(msglen2 == msglen3);
+    assert(memcmp(buf2, buf3, msglen2) == 0);
+    
+    free_with_check(msg1);
+    free_with_check(msg2);
+    free_with_check(buf2);
+    free_with_check(buf3);
+}
+
+/* Do decode -> encode -> decode -> encode roundtrip */
+static void do_pointer_roundtrip(uint8_t *buffer, size_t msglen)
+{
+    bool status;
+    uint8_t *buf2 = malloc_with_check(BUFSIZE);
+    uint8_t *buf3 = malloc_with_check(BUFSIZE);
+    size_t msglen2, msglen3;
+    alltypes_pointer_AllTypes *msg1 = malloc_with_check(sizeof(alltypes_pointer_AllTypes));
+    alltypes_pointer_AllTypes *msg2 = malloc_with_check(sizeof(alltypes_pointer_AllTypes));
+    memset(msg1, 0, sizeof(alltypes_pointer_AllTypes));
+    memset(msg2, 0, sizeof(alltypes_pointer_AllTypes));
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buffer, msglen);
+        status = pb_decode(&stream, alltypes_pointer_AllTypes_fields, msg1);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf2, BUFSIZE);
+        status = pb_encode(&stream, alltypes_pointer_AllTypes_fields, msg1);
+        assert(status);
+        msglen2 = stream.bytes_written;
+    }
+    
+    {
+        pb_istream_t stream = pb_istream_from_buffer(buf2, msglen2);
+        status = pb_decode(&stream, alltypes_pointer_AllTypes_fields, msg2);
+        assert(status);
+    }
+    
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buf3, BUFSIZE);
+        status = pb_encode(&stream, alltypes_pointer_AllTypes_fields, msg2);
+        assert(status);
+        msglen3 = stream.bytes_written;
+    }
+    
+    assert(msglen2 == msglen3);
+    assert(memcmp(buf2, buf3, msglen2) == 0);
+    
+    pb_release(alltypes_pointer_AllTypes_fields, msg1);
+    pb_release(alltypes_pointer_AllTypes_fields, msg2);
+    free_with_check(msg1);
+    free_with_check(msg2);
+    free_with_check(buf2);
+    free_with_check(buf3);
+}
+
+static void run_iteration()
+{
+    uint8_t *buffer = malloc_with_check(BUFSIZE);
+    size_t msglen;
+    bool status;
+    
+    rand_fill(buffer, BUFSIZE);
+
+    if (do_static_encode(buffer, &msglen))
+    {
+        do_protobuf_noise(buffer, &msglen);
+    
+        status = do_static_decode(buffer, msglen, true);
+        
+        if (status)
+            do_static_roundtrip(buffer, msglen);
+        
+        status = do_pointer_decode(buffer, msglen, true);
+        
+        if (status)
+            do_pointer_roundtrip(buffer, msglen);
+        
+        /* Apply randomness to the encoded data */
+        while (rand_bool())
+            rand_mess(buffer, BUFSIZE);
+        
+        /* Apply randomness to encoded data length */
+        if (rand_bool())
+            msglen = rand_int(0, BUFSIZE);
+        
+        status = do_static_decode(buffer, msglen, false);
+        do_pointer_decode(buffer, msglen, status);
+        
+        if (status)
+        {
+            do_static_roundtrip(buffer, msglen);
+            do_pointer_roundtrip(buffer, msglen);
+        }
+    }
+    
+    free_with_check(buffer);
+}
+
+int main(int argc, char **argv)
+{
+    int i;
+    if (argc > 1)
+    {
+        random_seed = atol(argv[1]);
+    }
+    else
+    {
+        random_seed = time(NULL);
+    }
+    
+    fprintf(stderr, "Random seed: %llu\n", (long long unsigned)random_seed);
+    
+    for (i = 0; i < 10000; i++)
+    {
+        run_iteration();
+    }
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/generate_message.c
@@ -0,0 +1,101 @@
+/* Generates a random, valid protobuf message. Useful to seed
+ * external fuzzers such as afl-fuzz.
+ */
+
+#include <pb_encode.h>
+#include <pb_common.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <time.h>
+#include "alltypes_static.pb.h"
+
+static uint64_t random_seed;
+
+/* Uses xorshift64 here instead of rand() for both speed and
+ * reproducibility across platforms. */
+static uint32_t rand_word()
+{
+    random_seed ^= random_seed >> 12;
+    random_seed ^= random_seed << 25;
+    random_seed ^= random_seed >> 27;
+    return random_seed * 2685821657736338717ULL;
+}
+
+/* Fills a buffer with random data. */
+static void rand_fill(uint8_t *buf, size_t count)
+{
+    while (count--)
+    {
+        *buf++ = rand_word() & 0xff;
+    }
+}
+
+/* Check that size/count fields do not exceed their max size.
+ * Otherwise we would have to loop pretty long in generate_message().
+ * Note that there may still be a few encoding errors from submessages.
+ */
+static void limit_sizes(alltypes_static_AllTypes *msg)
+{
+    pb_field_iter_t iter;
+    pb_field_iter_begin(&iter, alltypes_static_AllTypes_fields, msg);
+    while (pb_field_iter_next(&iter))
+    {
+        if (PB_LTYPE(iter.pos->type) == PB_LTYPE_BYTES)
+        {
+            ((pb_bytes_array_t*)iter.pData)->size %= iter.pos->data_size - PB_BYTES_ARRAY_T_ALLOCSIZE(0);
+        }
+        
+        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_REPEATED)
+        {
+            *((pb_size_t*)iter.pSize) %= iter.pos->array_size;
+        }
+        
+        if (PB_HTYPE(iter.pos->type) == PB_HTYPE_ONEOF)
+        {
+            /* Set the oneof to this message type with 50% chance. */
+            if (rand_word() & 1)
+            {
+                *((pb_size_t*)iter.pSize) = iter.pos->tag;
+            }
+        }
+    }
+}
+
+static void generate_message()
+{
+    alltypes_static_AllTypes msg;
+    uint8_t buf[8192];
+    pb_ostream_t stream = {0};
+    
+    do {
+        if (stream.errmsg)
+            fprintf(stderr, "Encoder error: %s\n", stream.errmsg);
+        
+        stream = pb_ostream_from_buffer(buf, sizeof(buf));
+        rand_fill((void*)&msg, sizeof(msg));
+        limit_sizes(&msg);
+    } while (!pb_encode(&stream, alltypes_static_AllTypes_fields, &msg));
+    
+    fwrite(buf, 1, stream.bytes_written, stdout);
+}
+
+int main(int argc, char **argv)
+{
+    if (argc > 1)
+    {
+        random_seed = atol(argv[1]);
+    }
+    else
+    {
+        random_seed = time(NULL);
+    }
+    
+    fprintf(stderr, "Random seed: %llu\n", (long long unsigned)random_seed);
+    
+    generate_message();
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/fuzztest/run_radamsa.sh
@@ -0,0 +1,12 @@
+#!/bin/bash
+
+TMP=`tempfile`
+
+echo $TMP
+while true
+do
+   radamsa sample_data/* > $TMP
+   $1 < $TMP
+   test $? -gt 127 && break
+done
+ 
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/intsizes/SConscript
@@ -0,0 +1,12 @@
+# Test that the int_size option in .proto works.
+
+Import('env')
+
+env.NanopbProto('intsizes')
+
+p = env.Program(["intsizes_unittests.c",
+                 "intsizes.pb.c",
+                 "$COMMON/pb_encode.o",
+                 "$COMMON/pb_decode.o",
+                 "$COMMON/pb_common.o"])
+env.RunTest(p)
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/intsizes/intsizes.proto
@@ -0,0 +1,41 @@
+/* Test the integer size overriding in nanopb options.
+ * This allows to use 8- and 16-bit integer variables, which are not supported
+ * directly by Google Protobuf.
+ *
+ * The int_size setting will override the number of bits, but keep the type
+ * otherwise. E.g. uint32 + IS_8 => uint8_t
+ */
+
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+message IntSizes {
+    required int32  req_int8 =   1  [(nanopb).int_size = IS_8];
+    required uint32 req_uint8 =  2  [(nanopb).int_size = IS_8];
+    required sint32 req_sint8 =  3  [(nanopb).int_size = IS_8];
+    required int32  req_int16 =  4  [(nanopb).int_size = IS_16];
+    required uint32 req_uint16 = 5  [(nanopb).int_size = IS_16];
+    required sint32 req_sint16 = 6  [(nanopb).int_size = IS_16];
+    required int32  req_int32 =  7  [(nanopb).int_size = IS_32];
+    required uint32 req_uint32 = 8  [(nanopb).int_size = IS_32];
+    required sint32 req_sint32 = 9  [(nanopb).int_size = IS_32];
+    required int32  req_int64 =  10 [(nanopb).int_size = IS_64];
+    required uint32 req_uint64 = 11 [(nanopb).int_size = IS_64];
+    required sint32 req_sint64 = 12 [(nanopb).int_size = IS_64];
+}
+
+message DefaultSizes {
+    required int32  req_int8 =   1 ;
+    required uint32 req_uint8 =  2 ;
+    required sint32 req_sint8 =  3 ;
+    required int32  req_int16 =  4 ;
+    required uint32 req_uint16 = 5 ;
+    required sint32 req_sint16 = 6 ;
+    required int32  req_int32 =  7 ;
+    required uint32 req_uint32 = 8 ;
+    required sint32 req_sint32 = 9 ;
+    required int64  req_int64 =  10;
+    required uint64 req_uint64 = 11;
+    required sint64 req_sint64 = 12;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/intsizes/intsizes_unittests.c
@@ -0,0 +1,122 @@
+#include <stdio.h>
+#include <string.h>
+#include <pb_decode.h>
+#include <pb_encode.h>
+#include "unittests.h"
+#include "intsizes.pb.h"
+
+#define S(x) pb_istream_from_buffer((uint8_t*)x, sizeof(x) - 1)
+
+/* This is a macro instead of function in order to get the actual values
+ * into the TEST() lines in output */
+#define TEST_ROUNDTRIP(int8, uint8, sint8, \
+                       int16, uint16, sint16, \
+                       int32, uint32, sint32, \
+                       int64, uint64, sint64, expected_result) \
+{                                                                           \
+    uint8_t buffer1[128], buffer2[128];                                     \
+    size_t msgsize;                                                         \
+    DefaultSizes msg1 = DefaultSizes_init_zero;                             \
+    IntSizes msg2 = IntSizes_init_zero;                                     \
+                                                                            \
+    msg1.req_int8   = int8;                                                 \
+    msg1.req_uint8  = uint8;                                                \
+    msg1.req_sint8  = sint8;                                                \
+    msg1.req_int16  = int16;                                                \
+    msg1.req_uint16 = uint16;                                               \
+    msg1.req_sint16 = sint16;                                               \
+    msg1.req_int32  = int32;                                                \
+    msg1.req_uint32 = uint32;                                               \
+    msg1.req_sint32 = sint32;                                               \
+    msg1.req_int64  = int64;                                                \
+    msg1.req_uint64 = uint64;                                               \
+    msg1.req_sint64 = sint64;                                               \
+                                                                            \
+    {                                                                       \
+        pb_ostream_t s = pb_ostream_from_buffer(buffer1, sizeof(buffer1));  \
+        TEST(pb_encode(&s, DefaultSizes_fields, &msg1));                    \
+        msgsize = s.bytes_written;                                          \
+    }                                                                       \
+                                                                            \
+    {                                                                       \
+        pb_istream_t s = pb_istream_from_buffer(buffer1, msgsize);          \
+        TEST(pb_decode(&s, IntSizes_fields, &msg2) == expected_result);     \
+        if (expected_result)                                                \
+        {                                                                   \
+            TEST( (int64_t)msg2.req_int8   == int8);                        \
+            TEST((uint64_t)msg2.req_uint8  == uint8);                       \
+            TEST( (int64_t)msg2.req_sint8  == sint8);                       \
+            TEST( (int64_t)msg2.req_int16  == int16);                       \
+            TEST((uint64_t)msg2.req_uint16 == uint16);                      \
+            TEST( (int64_t)msg2.req_sint16 == sint16);                      \
+            TEST( (int64_t)msg2.req_int32  == int32);                       \
+            TEST((uint64_t)msg2.req_uint32 == uint32);                      \
+            TEST( (int64_t)msg2.req_sint32 == sint32);                      \
+            TEST( (int64_t)msg2.req_int64  == int64);                       \
+            TEST((uint64_t)msg2.req_uint64 == uint64);                      \
+            TEST( (int64_t)msg2.req_sint64 == sint64);                      \
+        }                                                                   \
+    }                                                                       \
+                                                                            \
+    if (expected_result)                                                    \
+    {                                                                       \
+        pb_ostream_t s = pb_ostream_from_buffer(buffer2, sizeof(buffer2));  \
+        TEST(pb_encode(&s, IntSizes_fields, &msg2));                        \
+        TEST(s.bytes_written == msgsize);                                   \
+        TEST(memcmp(buffer1, buffer2, msgsize) == 0);                       \
+    }                                                                       \
+}
+
+int main()
+{
+    int status = 0;
+
+    {
+        IntSizes msg = IntSizes_init_zero;
+
+        COMMENT("Test field sizes");
+        TEST(sizeof(msg.req_int8) == 1);
+        TEST(sizeof(msg.req_uint8) == 1);
+        TEST(sizeof(msg.req_sint8) == 1);
+        TEST(sizeof(msg.req_int16) == 2);
+        TEST(sizeof(msg.req_uint16) == 2);
+        TEST(sizeof(msg.req_sint16) == 2);
+        TEST(sizeof(msg.req_int32) == 4);
+        TEST(sizeof(msg.req_uint32) == 4);
+        TEST(sizeof(msg.req_sint32) == 4);
+        TEST(sizeof(msg.req_int64) == 8);
+        TEST(sizeof(msg.req_uint64) == 8);
+        TEST(sizeof(msg.req_sint64) == 8);
+    }
+
+    COMMENT("Test roundtrip at maximum value");
+    TEST_ROUNDTRIP(127,     255,    127,
+                   32767, 65535,  32767,
+                   INT32_MAX, UINT32_MAX, INT32_MAX,
+                   INT64_MAX, UINT64_MAX, INT64_MAX, true);
+
+    COMMENT("Test roundtrip at minimum value");
+    TEST_ROUNDTRIP(-128,      0,   -128,
+                   -32768,    0, -32768,
+                   INT32_MIN, 0, INT32_MIN,
+                   INT64_MIN, 0, INT64_MIN, true);
+
+    COMMENT("Test overflow detection");
+    TEST_ROUNDTRIP(-129,      0,   -128,
+                   -32768,    0, -32768,
+                   INT32_MIN, 0, INT32_MIN,
+                   INT64_MIN, 0, INT64_MIN, false);
+    TEST_ROUNDTRIP(127,     256,    127,
+                   32767, 65535,  32767,
+                   INT32_MAX, UINT32_MAX, INT32_MAX,
+                   INT64_MAX, UINT64_MAX, INT64_MAX, false);
+    TEST_ROUNDTRIP(-128,      0,   -128,
+                   -32768,    0, -32769,
+                   INT32_MIN, 0, INT32_MIN,
+                   INT64_MIN, 0, INT64_MIN, false);
+
+    if (status != 0)
+        fprintf(stdout, "\n\nSome tests FAILED!\n");
+
+    return status;
+}
\ No newline at end of file
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/io_errors/SConscript
@@ -0,0 +1,15 @@
+# Simulate io errors when encoding and decoding
+
+Import("env")
+
+c = Copy("$TARGET", "$SOURCE")
+env.Command("alltypes.proto", "#alltypes/alltypes.proto", c)
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+
+ioerr = env.Program(["io_errors.c", "alltypes.pb.c",
+                     "$COMMON/pb_encode.o", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+
+env.RunTest("io_errors.output", [ioerr, "$BUILD/alltypes/encode_alltypes.output"])
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/io_errors/alltypes.options
@@ -0,0 +1,3 @@
+* max_size:16
+* max_count:5
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/io_errors/io_errors.c
@@ -0,0 +1,140 @@
+/* Simulate IO errors after each byte in a stream.
+ * Verifies proper error propagation.
+ */
+
+#include <stdio.h>
+#include <pb_decode.h>
+#include <pb_encode.h>
+#include "alltypes.pb.h"
+#include "test_helpers.h"
+
+typedef struct
+{
+    uint8_t *buffer;
+    size_t fail_after;
+} faulty_stream_t;
+
+bool read_callback(pb_istream_t *stream, uint8_t *buf, size_t count)
+{
+    faulty_stream_t *state = stream->state;
+    
+    while (count--)
+    {
+        if (state->fail_after == 0)
+            PB_RETURN_ERROR(stream, "simulated");
+        state->fail_after--;
+        *buf++ = *state->buffer++;
+    }
+    
+    return true;
+}
+bool write_callback(pb_ostream_t *stream, const uint8_t *buf, size_t count)
+{
+    faulty_stream_t *state = stream->state;
+    
+    while (count--)
+    {
+        if (state->fail_after == 0)
+            PB_RETURN_ERROR(stream, "simulated");
+        state->fail_after--;
+        *state->buffer++ = *buf++;
+    }
+    
+    return true;
+}
+
+int main()
+{
+    uint8_t buffer[2048];
+    size_t msglen;
+    AllTypes msg = AllTypes_init_zero;
+    
+    /* Get some base data to run the tests with */
+    SET_BINARY_MODE(stdin);
+    msglen = fread(buffer, 1, sizeof(buffer), stdin);
+    
+    /* Test IO errors on decoding */
+    {
+        bool status;
+        pb_istream_t stream = {&read_callback, NULL, SIZE_MAX};
+        faulty_stream_t fs;
+        size_t i;
+        
+        for (i = 0; i < msglen; i++)
+        {
+            stream.bytes_left = msglen;
+            stream.state = &fs;
+            fs.buffer = buffer;
+            fs.fail_after = i;
+
+            status = pb_decode(&stream, AllTypes_fields, &msg);
+            if (status != false)
+            {
+                fprintf(stderr, "Unexpected success in decode\n");
+                return 2;
+            }
+            else if (strcmp(stream.errmsg, "simulated") != 0)
+            {
+                fprintf(stderr, "Wrong error in decode: %s\n", stream.errmsg);
+                return 3;
+            }
+        }
+        
+        stream.bytes_left = msglen;
+        stream.state = &fs;
+        fs.buffer = buffer;
+        fs.fail_after = msglen;
+        status = pb_decode(&stream, AllTypes_fields, &msg);
+        
+        if (!status)
+        {
+            fprintf(stderr, "Decoding failed: %s\n", stream.errmsg);
+            return 4;
+        }
+    }
+    
+    /* Test IO errors on encoding */
+    {
+        bool status;
+        pb_ostream_t stream = {&write_callback, NULL, SIZE_MAX, 0};
+        faulty_stream_t fs;
+        size_t i;
+        
+        for (i = 0; i < msglen; i++)
+        {
+            stream.max_size = msglen;
+            stream.bytes_written = 0;
+            stream.state = &fs;
+            fs.buffer = buffer;
+            fs.fail_after = i;
+
+            status = pb_encode(&stream, AllTypes_fields, &msg);
+            if (status != false)
+            {
+                fprintf(stderr, "Unexpected success in encode\n");
+                return 5;
+            }
+            else if (strcmp(stream.errmsg, "simulated") != 0)
+            {
+                fprintf(stderr, "Wrong error in encode: %s\n", stream.errmsg);
+                return 6;
+            }
+        }
+        
+        stream.max_size = msglen;
+        stream.bytes_written = 0;
+        stream.state = &fs;
+        fs.buffer = buffer;
+        fs.fail_after = msglen;
+        status = pb_encode(&stream, AllTypes_fields, &msg);
+        
+        if (!status)
+        {
+            fprintf(stderr, "Encoding failed: %s\n", stream.errmsg);
+            return 7;
+        }
+    }
+
+    return 0;   
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/io_errors_pointers/SConscript
@@ -0,0 +1,26 @@
+# Simulate io errors when encoding and decoding
+
+Import("env", "malloc_env")
+
+c = Copy("$TARGET", "$SOURCE")
+env.Command("alltypes.proto", "#alltypes/alltypes.proto", c)
+env.Command("io_errors.c", "#io_errors/io_errors.c", c)
+
+env.NanopbProto(["alltypes", "alltypes.options"])
+
+ioerr = env.Program(["io_errors.c", "alltypes.pb.c",
+                     "$COMMON/pb_encode_with_malloc.o",
+                     "$COMMON/pb_decode_with_malloc.o",
+                     "$COMMON/pb_common_with_malloc.o",
+                     "$COMMON/malloc_wrappers.o"])
+
+# Run tests under valgrind if available
+valgrind = env.WhereIs('valgrind')
+kwargs = {}
+if valgrind:
+    kwargs['COMMAND'] = valgrind
+    kwargs['ARGS'] = ["-q", "--error-exitcode=99", ioerr[0].abspath]
+
+env.RunTest("io_errors.output", [ioerr, "$BUILD/alltypes/encode_alltypes.output"], **kwargs)
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/io_errors_pointers/alltypes.options
@@ -0,0 +1,3 @@
+# Generate all fields as pointers.
+* type:FT_POINTER
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/mem_release/SConscript
@@ -0,0 +1,13 @@
+Import("env", "malloc_env")
+
+env.NanopbProto("mem_release.proto")
+
+test = malloc_env.Program(["mem_release.c",
+                    "mem_release.pb.c",
+                    "$COMMON/pb_encode_with_malloc.o",
+                    "$COMMON/pb_decode_with_malloc.o",
+                    "$COMMON/pb_common_with_malloc.o",
+                    "$COMMON/malloc_wrappers.o"])
+
+env.RunTest(test)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/mem_release/mem_release.c
@@ -0,0 +1,187 @@
+/* Make sure that all fields are freed in various scenarios. */
+
+#include <pb_decode.h>
+#include <pb_encode.h>
+#include <malloc_wrappers.h>
+#include <stdio.h>
+#include <test_helpers.h>
+#include "mem_release.pb.h"
+
+#define TEST(x) if (!(x)) { \
+    fprintf(stderr, "Test " #x " on line %d failed.\n", __LINE__); \
+    return false; \
+    }
+
+static char *test_str_arr[] = {"1", "2", ""};
+static SubMessage test_msg_arr[] = {SubMessage_init_zero, SubMessage_init_zero};
+static pb_extension_t ext1, ext2;
+
+static void fill_TestMessage(TestMessage *msg)
+{
+    msg->static_req_submsg.dynamic_str = "12345";
+    msg->static_req_submsg.dynamic_str_arr_count = 3;
+    msg->static_req_submsg.dynamic_str_arr = test_str_arr;
+    msg->static_req_submsg.dynamic_submsg_count = 2;
+    msg->static_req_submsg.dynamic_submsg = test_msg_arr;
+    msg->static_req_submsg.dynamic_submsg[1].dynamic_str = "abc";
+    msg->static_opt_submsg.dynamic_str = "abc";
+    msg->static_rep_submsg_count = 2;
+    msg->static_rep_submsg[1].dynamic_str = "abc";
+    msg->has_static_opt_submsg = true;
+    msg->dynamic_submsg = &msg->static_req_submsg;
+
+    msg->extensions = &ext1;
+    ext1.type = &dynamic_ext;
+    ext1.dest = &msg->static_req_submsg;
+    ext1.next = &ext2;
+    ext2.type = &static_ext;
+    ext2.dest = &msg->static_req_submsg;
+    ext2.next = NULL;
+}
+
+/* Basic fields, nested submessages, extensions */
+static bool test_TestMessage()
+{
+    uint8_t buffer[256];
+    size_t msgsize;
+    
+    /* Construct a message with various fields filled in */
+    {
+        TestMessage msg = TestMessage_init_zero;
+        pb_ostream_t stream;
+
+        fill_TestMessage(&msg);
+        
+        stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        if (!pb_encode(&stream, TestMessage_fields, &msg))
+        {
+            fprintf(stderr, "Encode failed: %s\n", PB_GET_ERROR(&stream));
+            return false;
+        }
+        msgsize = stream.bytes_written;
+    }
+    
+    /* Output encoded message for debug */
+    SET_BINARY_MODE(stdout);
+    fwrite(buffer, 1, msgsize, stdout);
+    
+    /* Decode memory using dynamic allocation */
+    {
+        TestMessage msg = TestMessage_init_zero;
+        pb_istream_t stream;
+        SubMessage ext2_dest;
+
+        msg.extensions = &ext1;
+        ext1.type = &dynamic_ext;
+        ext1.dest = NULL;
+        ext1.next = &ext2;
+        ext2.type = &static_ext;
+        ext2.dest = &ext2_dest;
+        ext2.next = NULL;
+        
+        stream = pb_istream_from_buffer(buffer, msgsize);
+        if (!pb_decode(&stream, TestMessage_fields, &msg))
+        {
+            fprintf(stderr, "Decode failed: %s\n", PB_GET_ERROR(&stream));
+            return false;
+        }
+        
+        /* Make sure it encodes back to same data */
+        {
+            uint8_t buffer2[256];
+            pb_ostream_t ostream = pb_ostream_from_buffer(buffer2, sizeof(buffer2));
+            TEST(pb_encode(&ostream, TestMessage_fields, &msg));
+            TEST(ostream.bytes_written == msgsize);
+            TEST(memcmp(buffer, buffer2, msgsize) == 0);
+        }
+        
+        /* Make sure that malloc counters work */
+        TEST(get_alloc_count() > 0);
+        
+        /* Make sure that pb_release releases everything */
+        pb_release(TestMessage_fields, &msg);
+        TEST(get_alloc_count() == 0);
+        
+        /* Check that double-free is a no-op */
+        pb_release(TestMessage_fields, &msg);
+        TEST(get_alloc_count() == 0);
+    }
+    
+    return true;
+}
+
+/* Oneofs */
+static bool test_OneofMessage()
+{
+    uint8_t buffer[256];
+    size_t msgsize;
+
+    {
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+
+        /* Encode first with TestMessage */
+        {
+            OneofMessage msg = OneofMessage_init_zero;
+            msg.which_msgs = OneofMessage_msg1_tag;
+
+            fill_TestMessage(&msg.msgs.msg1);
+
+            if (!pb_encode(&stream, OneofMessage_fields, &msg))
+            {
+                fprintf(stderr, "Encode failed: %s\n", PB_GET_ERROR(&stream));
+                return false;
+            }
+        }
+
+        /* Encode second with SubMessage, invoking 'merge' behaviour */
+        {
+            OneofMessage msg = OneofMessage_init_zero;
+            msg.which_msgs = OneofMessage_msg2_tag;
+
+            msg.first = 999;
+            msg.msgs.msg2.dynamic_str = "ABCD";
+            msg.last = 888;
+
+            if (!pb_encode(&stream, OneofMessage_fields, &msg))
+            {
+                fprintf(stderr, "Encode failed: %s\n", PB_GET_ERROR(&stream));
+                return false;
+            }
+        }
+        msgsize = stream.bytes_written;
+    }
+
+    {
+        OneofMessage msg = OneofMessage_init_zero;
+        pb_istream_t stream = pb_istream_from_buffer(buffer, msgsize);
+        if (!pb_decode(&stream, OneofMessage_fields, &msg))
+        {
+            fprintf(stderr, "Decode failed: %s\n", PB_GET_ERROR(&stream));
+            return false;
+        }
+
+        TEST(msg.first == 999);
+        TEST(msg.which_msgs == OneofMessage_msg2_tag);
+        TEST(msg.msgs.msg2.dynamic_str);
+        TEST(strcmp(msg.msgs.msg2.dynamic_str, "ABCD") == 0);
+        TEST(msg.msgs.msg2.dynamic_str_arr == NULL);
+        TEST(msg.msgs.msg2.dynamic_submsg == NULL);
+        TEST(msg.last == 888);
+
+        pb_release(OneofMessage_fields, &msg);
+        TEST(get_alloc_count() == 0);
+        pb_release(OneofMessage_fields, &msg);
+        TEST(get_alloc_count() == 0);
+    }
+
+    return true;
+}
+
+int main()
+{
+    if (test_TestMessage() && test_OneofMessage())
+        return 0;
+    else
+        return 1;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/mem_release/mem_release.proto
@@ -0,0 +1,35 @@
+syntax = "proto2";
+import "nanopb.proto";
+
+message SubMessage
+{
+    optional string dynamic_str = 1 [(nanopb).type = FT_POINTER];
+    repeated string dynamic_str_arr = 2 [(nanopb).type = FT_POINTER];
+    repeated SubMessage dynamic_submsg = 3 [(nanopb).type = FT_POINTER];
+}
+
+message TestMessage
+{
+    required SubMessage static_req_submsg = 1 [(nanopb).type = FT_STATIC];
+    optional SubMessage dynamic_submsg = 2 [(nanopb).type = FT_POINTER];
+    optional SubMessage static_opt_submsg = 3 [(nanopb).type = FT_STATIC];
+    repeated SubMessage static_rep_submsg = 4 [(nanopb).type = FT_STATIC, (nanopb).max_count=2];
+    extensions 100 to 200;
+}
+
+extend TestMessage
+{
+    optional SubMessage dynamic_ext = 100 [(nanopb).type = FT_POINTER];
+    optional SubMessage static_ext = 101 [(nanopb).type = FT_STATIC];
+}
+
+message OneofMessage
+{
+    required int32 first = 1;
+    oneof msgs
+    {
+        TestMessage msg1 = 2;
+        SubMessage msg2 = 3;
+    }
+    required int32 last = 4;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/message_sizes/SConscript
@@ -0,0 +1,11 @@
+# Test the generation of message size #defines
+
+Import('env')
+
+incpath = env.Clone()
+incpath.Append(PROTOCPATH = '#message_sizes')
+
+incpath.NanopbProto("messages1")
+incpath.NanopbProto("messages2")
+
+incpath.Program(['dummy.c', 'messages1.pb.c', 'messages2.pb.c'])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/message_sizes/dummy.c
@@ -0,0 +1,9 @@
+/* Just test that the file can be compiled successfully. */
+
+#include "messages2.pb.h"
+
+int main()
+{
+    return xmit_size;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/message_sizes/messages1.proto
@@ -0,0 +1,29 @@
+syntax = "proto2";
+
+enum MessageStatus {
+    FAIL = 0;
+    OK = 1;
+};
+
+message MessageInfo {
+   required fixed32 msg_id = 1;
+   optional fixed32 interface_id = 2;
+}
+
+message MessageResponseInfo {
+   required fixed64 interface_id = 1;
+   required fixed32 seq = 2;
+   required fixed32 msg_id = 3;
+}
+
+message MessageHeader {
+   required MessageInfo info = 1;
+   optional MessageResponseInfo response_info = 2;
+   optional MessageResponse response = 3;
+}
+
+message MessageResponse {
+   required MessageStatus status = 1;
+   required fixed32 seq = 2;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/message_sizes/messages2.proto
@@ -0,0 +1,10 @@
+syntax = "proto2";
+
+import 'nanopb.proto';
+import 'messages1.proto';
+
+message xmit {
+   required MessageHeader header = 1;
+   required bytes data = 2 [(nanopb).max_size = 128];
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/missing_fields/SConscript
@@ -0,0 +1,8 @@
+# Check that the decoder properly detects when required fields are missing.
+
+Import("env")
+
+env.NanopbProto("missing_fields")
+test = env.Program(["missing_fields.c", "missing_fields.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_decode.o", "$COMMON/pb_common.o"])
+env.RunTest(test)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/missing_fields/missing_fields.c
@@ -0,0 +1,53 @@
+/* Checks that missing required fields are detected properly */
+
+#include <stdio.h>
+#include <pb_encode.h>
+#include <pb_decode.h>
+#include "missing_fields.pb.h"
+
+int main()
+{
+    uint8_t buffer[512];
+    size_t size;
+    
+    /* Create a message with one missing field */
+    {
+        MissingField msg = {0};
+        pb_ostream_t stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+        
+        if (!pb_encode(&stream, MissingField_fields, &msg))
+        {
+            printf("Encode failed.\n");
+            return 1;
+        }
+
+        size = stream.bytes_written;
+    }
+
+    /* Test that it decodes properly if we don't require that field */
+    {
+        MissingField msg = {0};
+        pb_istream_t stream = pb_istream_from_buffer(buffer, size);
+        
+        if (!pb_decode(&stream, MissingField_fields, &msg))
+        {
+            printf("Decode failed: %s\n", PB_GET_ERROR(&stream));
+            return 2;
+        }
+    }
+    
+    /* Test that it does *not* decode properly if we require the field */
+    {
+        AllFields msg = {0};
+        pb_istream_t stream = pb_istream_from_buffer(buffer, size);
+        
+        if (pb_decode(&stream, AllFields_fields, &msg))
+        {
+            printf("Decode didn't detect missing field.\n");
+            return 3;
+        }
+    }
+    
+    return 0; /* All ok */
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/missing_fields/missing_fields.proto
@@ -0,0 +1,140 @@
+/* Test for one missing field among many */
+
+syntax = "proto2";
+
+message AllFields
+{
+    required int32 field1 = 1;
+    required int32 field2 = 2;
+    required int32 field3 = 3;
+    required int32 field4 = 4;
+    required int32 field5 = 5;
+    required int32 field6 = 6;
+    required int32 field7 = 7;
+    required int32 field8 = 8;
+    required int32 field9 = 9;
+    required int32 field10 = 10;
+    required int32 field11 = 11;
+    required int32 field12 = 12;
+    required int32 field13 = 13;
+    required int32 field14 = 14;
+    required int32 field15 = 15;
+    required int32 field16 = 16;
+    required int32 field17 = 17;
+    required int32 field18 = 18;
+    required int32 field19 = 19;
+    required int32 field20 = 20;
+    required int32 field21 = 21;
+    required int32 field22 = 22;
+    required int32 field23 = 23;
+    required int32 field24 = 24;
+    required int32 field25 = 25;
+    required int32 field26 = 26;
+    required int32 field27 = 27;
+    required int32 field28 = 28;
+    required int32 field29 = 29;
+    required int32 field30 = 30;
+    required int32 field31 = 31;
+    required int32 field32 = 32;
+    required int32 field33 = 33;
+    required int32 field34 = 34;
+    required int32 field35 = 35;
+    required int32 field36 = 36;
+    required int32 field37 = 37;
+    required int32 field38 = 38;
+    required int32 field39 = 39;
+    required int32 field40 = 40;
+    required int32 field41 = 41;
+    required int32 field42 = 42;
+    required int32 field43 = 43;
+    required int32 field44 = 44;
+    required int32 field45 = 45;
+    required int32 field46 = 46;
+    required int32 field47 = 47;
+    required int32 field48 = 48;
+    required int32 field49 = 49;
+    required int32 field50 = 50;
+    required int32 field51 = 51;
+    required int32 field52 = 52;
+    required int32 field53 = 53;
+    required int32 field54 = 54;
+    required int32 field55 = 55;
+    required int32 field56 = 56;
+    required int32 field57 = 57;
+    required int32 field58 = 58;
+    required int32 field59 = 59;
+    required int32 field60 = 60;
+    required int32 field61 = 61;
+    required int32 field62 = 62;
+    required int32 field63 = 63;
+    required int32 field64 = 64;
+}
+
+message MissingField
+{
+    required int32 field1 = 1;
+    required int32 field2 = 2;
+    required int32 field3 = 3;
+    required int32 field4 = 4;
+    required int32 field5 = 5;
+    required int32 field6 = 6;
+    required int32 field7 = 7;
+    required int32 field8 = 8;
+    required int32 field9 = 9;
+    required int32 field10 = 10;
+    required int32 field11 = 11;
+    required int32 field12 = 12;
+    required int32 field13 = 13;
+    required int32 field14 = 14;
+    required int32 field15 = 15;
+    required int32 field16 = 16;
+    required int32 field17 = 17;
+    required int32 field18 = 18;
+    required int32 field19 = 19;
+    required int32 field20 = 20;
+    required int32 field21 = 21;
+    required int32 field22 = 22;
+    required int32 field23 = 23;
+    required int32 field24 = 24;
+    required int32 field25 = 25;
+    required int32 field26 = 26;
+    required int32 field27 = 27;
+    required int32 field28 = 28;
+    required int32 field29 = 29;
+    required int32 field30 = 30;
+    required int32 field31 = 31;
+    required int32 field32 = 32;
+    required int32 field33 = 33;
+    required int32 field34 = 34;
+    required int32 field35 = 35;
+    required int32 field36 = 36;
+    required int32 field37 = 37;
+    required int32 field38 = 38;
+    required int32 field39 = 39;
+    required int32 field40 = 40;
+    required int32 field41 = 41;
+    required int32 field42 = 42;
+    required int32 field43 = 43;
+    required int32 field44 = 44;
+    required int32 field45 = 45;
+    required int32 field46 = 46;
+    required int32 field47 = 47;
+    required int32 field48 = 48;
+    required int32 field49 = 49;
+    required int32 field50 = 50;
+    required int32 field51 = 51;
+    required int32 field52 = 52;
+    required int32 field53 = 53;
+    required int32 field54 = 54;
+    required int32 field55 = 55;
+    required int32 field56 = 56;
+    required int32 field57 = 57;
+    required int32 field58 = 58;
+    required int32 field59 = 59;
+    required int32 field60 = 60;
+    required int32 field61 = 61;
+    required int32 field62 = 62;
+/*    required int32 field63 = 63; */
+    required int32 field64 = 64;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/multiple_files/SConscript
@@ -0,0 +1,13 @@
+# Test that multiple .proto files don't cause name collisions.
+
+Import("env")
+
+incpath = env.Clone()
+incpath.Append(PROTOCPATH = '#multiple_files')
+
+incpath.NanopbProto(["multifile1", "multifile1.options"])
+incpath.NanopbProto("multifile2")
+test = incpath.Program(["test_multiple_files.c", "multifile1.pb.c", "multifile2.pb.c"])
+
+env.RunTest(test)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/multiple_files/multifile1.options
@@ -0,0 +1 @@
+StaticMessage.repint32 max_count:5
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/multiple_files/multifile1.proto
@@ -0,0 +1,34 @@
+syntax = "proto2";
+
+message SubMessage {
+    optional string stringvalue = 1;
+    repeated int32 int32value = 2;
+    repeated fixed32 fixed32value = 3;
+    repeated fixed64 fixed64value = 4;
+}
+
+message TestMessage {
+    optional string stringvalue = 1;
+    repeated int32 int32value = 2;
+    repeated fixed32 fixed32value = 3;
+    repeated fixed64 fixed64value = 4;
+    optional SubMessage submsg = 5;
+    repeated string repeatedstring = 6;
+}
+
+message StaticMessage {
+    repeated fixed32 repint32 = 1;
+}
+
+enum SignedEnum {
+    SE_MIN = -128;
+    SE_MAX = 127;
+}
+
+enum UnsignedEnum {
+    UE_MIN = 0;
+    UE_MAX = 255;
+}
+
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/multiple_files/multifile2.proto
@@ -0,0 +1,22 @@
+// Test if including generated header file for this file + implicit include of
+// multifile2.pb.h still compiles. Used with test_compiles.c.
+syntax = "proto2";
+
+import "multifile1.proto";
+
+message Callback2Message {
+    required TestMessage tstmsg = 1;
+    required SubMessage submsg = 2;
+}
+
+message OneofMessage {
+    oneof msgs {
+        StaticMessage tstmsg = 1;
+    }
+}
+
+message Enums {
+    required SignedEnum senum = 1;
+    required UnsignedEnum uenum = 2;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/multiple_files/test_multiple_files.c
@@ -0,0 +1,22 @@
+/*
+ * Tests if this still compiles when multiple .proto files are involved.
+ */
+
+#include <stdio.h>
+#include <pb_encode.h>
+#include "unittests.h"
+#include "multifile2.pb.h"
+
+int main()
+{
+    int status = 0;
+    
+    /* Test that included file options are properly loaded */
+    TEST(OneofMessage_size == 27);
+    
+    /* Check that enum signedness is detected properly */
+    TEST(PB_LTYPE(Enums_fields[0].type) == PB_LTYPE_VARINT);
+    TEST(PB_LTYPE(Enums_fields[1].type) == PB_LTYPE_UVARINT);
+    
+    return status;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/no_errmsg/SConscript
@@ -0,0 +1,28 @@
+# Run the alltypes test case, but compile with PB_NO_ERRMSG=1
+
+Import("env")
+
+# Take copy of the files for custom build.
+c = Copy("$TARGET", "$SOURCE")
+env.Command("alltypes.pb.h", "$BUILD/alltypes/alltypes.pb.h", c)
+env.Command("alltypes.pb.c", "$BUILD/alltypes/alltypes.pb.c", c)
+env.Command("encode_alltypes.c", "$BUILD/alltypes/encode_alltypes.c", c)
+env.Command("decode_alltypes.c", "$BUILD/alltypes/decode_alltypes.c", c)
+
+# Define the compilation options
+opts = env.Clone()
+opts.Append(CPPDEFINES = {'PB_NO_ERRMSG': 1})
+
+# Build new version of core
+strict = opts.Clone()
+strict.Append(CFLAGS = strict['CORECFLAGS'])
+strict.Object("pb_decode_noerr.o", "$NANOPB/pb_decode.c")
+strict.Object("pb_encode_noerr.o", "$NANOPB/pb_encode.c")
+strict.Object("pb_common_noerr.o", "$NANOPB/pb_common.c")
+
+# Now build and run the test normally.
+enc = opts.Program(["encode_alltypes.c", "alltypes.pb.c", "pb_encode_noerr.o", "pb_common_noerr.o"])
+dec = opts.Program(["decode_alltypes.c", "alltypes.pb.c", "pb_decode_noerr.o", "pb_common_noerr.o"])
+
+env.RunTest(enc)
+env.RunTest([dec, "encode_alltypes.output"])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/no_messages/SConscript
@@ -0,0 +1,7 @@
+# Test that a .proto file without any messages compiles fine.
+
+Import("env")
+
+env.NanopbProto("no_messages")
+env.Object('no_messages.pb.c')
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/no_messages/no_messages.proto
@@ -0,0 +1,9 @@
+/* Test that a file without any messages works. */
+
+syntax = "proto2";
+
+enum Test {
+    First = 1;
+}
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/oneof/SConscript
@@ -0,0 +1,33 @@
+# Test the 'oneof' feature for generating C unions.
+
+Import('env')
+
+import re
+
+match = None
+if 'PROTOC_VERSION' in env:
+    match = re.search('([0-9]+).([0-9]+).([0-9]+)', env['PROTOC_VERSION'])
+
+if match:
+    version = map(int, match.groups())
+
+# Oneof is supported by protoc >= 2.6.0
+if env.GetOption('clean') or (match and (version[0] > 2 or (version[0] == 2 and version[1] >= 6))):
+    env.NanopbProto('oneof')
+
+    enc = env.Program(['encode_oneof.c',
+                    'oneof.pb.c',
+                    '$COMMON/pb_encode.o',
+                    '$COMMON/pb_common.o'])
+
+    dec = env.Program(['decode_oneof.c',
+                    'oneof.pb.c',
+                    '$COMMON/pb_decode.o',
+                    '$COMMON/pb_common.o'])
+
+    env.RunTest("message1.pb", enc, ARGS = ['1'])
+    env.RunTest("message1.txt", [dec, 'message1.pb'], ARGS = ['1'])
+    env.RunTest("message2.pb", enc, ARGS = ['2'])
+    env.RunTest("message2.txt", [dec, 'message2.pb'], ARGS = ['2'])
+    env.RunTest("message3.pb", enc, ARGS = ['3'])
+    env.RunTest("message3.txt", [dec, 'message3.pb'], ARGS = ['3'])
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/oneof/decode_oneof.c
@@ -0,0 +1,131 @@
+/* Decode a message using oneof fields */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pb_decode.h>
+#include "oneof.pb.h"
+#include "test_helpers.h"
+#include "unittests.h"
+
+/* Test the 'OneOfMessage' */
+int test_oneof_1(pb_istream_t *stream, int option)
+{
+    OneOfMessage msg;
+    int status = 0;
+
+    /* To better catch initialization errors */
+    memset(&msg, 0xAA, sizeof(msg));
+
+    if (!pb_decode(stream, OneOfMessage_fields, &msg))
+    {
+        printf("Decoding failed: %s\n", PB_GET_ERROR(stream));
+        return 1;
+    }
+
+    /* Check that the basic fields work normally */
+    TEST(msg.prefix == 123);
+    TEST(msg.suffix == 321);
+
+    /* Check that we got the right oneof according to command line */
+    if (option == 1)
+    {
+        TEST(msg.which_values == OneOfMessage_first_tag);
+        TEST(msg.values.first == 999);
+    }
+    else if (option == 2)
+    {
+        TEST(msg.which_values == OneOfMessage_second_tag);
+        TEST(strcmp(msg.values.second, "abcd") == 0);
+    }
+    else if (option == 3)
+    {
+        TEST(msg.which_values == OneOfMessage_third_tag);
+        TEST(msg.values.third.array[0] == 1);
+        TEST(msg.values.third.array[1] == 2);
+        TEST(msg.values.third.array[2] == 3);
+        TEST(msg.values.third.array[3] == 4);
+        TEST(msg.values.third.array[4] == 5);
+    }
+
+    return status;
+}
+
+
+/* Test the 'PlainOneOfMessage' */
+int test_oneof_2(pb_istream_t *stream, int option)
+{
+    PlainOneOfMessage msg = PlainOneOfMessage_init_zero;
+    int status = 0;
+
+    if (!pb_decode(stream, PlainOneOfMessage_fields, &msg))
+    {
+        printf("Decoding failed: %s\n", PB_GET_ERROR(stream));
+        return 1;
+    }
+
+    /* Check that we got the right oneof according to command line */
+    if (option == 1)
+    {
+        TEST(msg.which_values == OneOfMessage_first_tag);
+        TEST(msg.values.first == 999);
+    }
+    else if (option == 2)
+    {
+        TEST(msg.which_values == OneOfMessage_second_tag);
+        TEST(strcmp(msg.values.second, "abcd") == 0);
+    }
+    else if (option == 3)
+    {
+        TEST(msg.which_values == OneOfMessage_third_tag);
+        TEST(msg.values.third.array[0] == 1);
+        TEST(msg.values.third.array[1] == 2);
+        TEST(msg.values.third.array[2] == 3);
+        TEST(msg.values.third.array[3] == 4);
+        TEST(msg.values.third.array[4] == 5);
+    }
+
+    return status;
+}
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[OneOfMessage_size];
+    size_t count;
+    int option;
+
+    if (argc != 2)
+    {
+        fprintf(stderr, "Usage: decode_oneof [number]\n");
+        return 1;
+    }
+    option = atoi(argv[1]);
+
+    SET_BINARY_MODE(stdin);
+    count = fread(buffer, 1, sizeof(buffer), stdin);
+
+    if (!feof(stdin))
+    {
+        printf("Message does not fit in buffer\n");
+        return 1;
+    }
+
+    {
+        int status = 0;
+        pb_istream_t stream;
+
+        stream = pb_istream_from_buffer(buffer, count);
+        status = test_oneof_1(&stream, option);
+
+        if (status != 0)
+            return status;
+
+        stream = pb_istream_from_buffer(buffer, count);
+        status = test_oneof_2(&stream, option);
+
+        if (status != 0)
+            return status;
+    }
+
+    return 0;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/oneof/encode_oneof.c
@@ -0,0 +1,64 @@
+/* Encode a message using oneof fields */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <pb_encode.h>
+#include "oneof.pb.h"
+#include "test_helpers.h"
+
+int main(int argc, char **argv)
+{
+    uint8_t buffer[OneOfMessage_size];
+    OneOfMessage msg = OneOfMessage_init_zero;
+    pb_ostream_t stream;
+    int option;
+
+    if (argc != 2)
+    {
+        fprintf(stderr, "Usage: encode_oneof [number]\n");
+        return 1;
+    }
+    option = atoi(argv[1]);
+
+    /* Prefix and suffix are used to test that the union does not disturb
+     * other fields in the same message. */
+    msg.prefix = 123;
+
+    /* We encode one of the 'values' fields based on command line argument */
+    if (option == 1)
+    {
+        msg.which_values = OneOfMessage_first_tag;
+        msg.values.first = 999;
+    }
+    else if (option == 2)
+    {
+        msg.which_values = OneOfMessage_second_tag;
+        strcpy(msg.values.second, "abcd");
+    }
+    else if (option == 3)
+    {
+        msg.which_values = OneOfMessage_third_tag;
+        msg.values.third.array_count = 5;
+        msg.values.third.array[0] = 1;
+        msg.values.third.array[1] = 2;
+        msg.values.third.array[2] = 3;
+        msg.values.third.array[3] = 4;
+        msg.values.third.array[4] = 5;
+    }
+
+    msg.suffix = 321;
+
+    stream = pb_ostream_from_buffer(buffer, sizeof(buffer));
+
+    if (pb_encode(&stream, OneOfMessage_fields, &msg))
+    {
+        SET_BINARY_MODE(stdout);
+        fwrite(buffer, 1, stream.bytes_written, stdout);
+        return 0;
+    }
+    else
+    {
+        fprintf(stderr, "Encoding failed: %s\n", PB_GET_ERROR(&stream));
+        return 1;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/oneof/oneof.proto
@@ -0,0 +1,32 @@
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+message SubMessage
+{
+    repeated int32 array = 1 [(nanopb).max_count = 8];
+}
+
+/* Oneof in a message with other fields */
+message OneOfMessage
+{
+    required int32 prefix = 1;
+    oneof values
+    {
+        int32 first = 5;
+        string second = 6 [(nanopb).max_size = 8];
+        SubMessage third = 7;
+    }
+    required int32 suffix = 99;
+}
+
+/* Oneof in a message by itself */
+message PlainOneOfMessage
+{
+    oneof values
+    {
+        int32 first = 5;
+        string second = 6 [(nanopb).max_size = 8];
+        SubMessage third = 7;
+    }
+}
\ No newline at end of file
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/options/SConscript
@@ -0,0 +1,9 @@
+# Test that the generator options work as expected.
+
+Import("env")
+
+env.NanopbProto("options")
+env.Object('options.pb.c')
+
+env.Match(['options.pb.h', 'options.expected'])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/options/options.expected
@@ -0,0 +1,18 @@
+char filesize\[20\];
+char msgsize\[30\];
+char fieldsize\[40\];
+pb_callback_t int32_callback;
+\sEnumValue1 = 1
+Message5_EnumValue1
+} pb_packed my_packed_struct;
+! skipped_field
+! SkippedMessage
+#define PB_MSG_103 Message3
+#define PB_MSG_104 Message4
+#define PB_MSG_105 Message5
+#define OPTIONS_MESSAGES \\
+\s+PB_MSG\(103,[0-9]*,Message3\) \\
+\s+PB_MSG\(104,-1,Message4\) \\
+\s+PB_MSG\(105,[0-9]*,Message5\) \\
+#define Message5_msgid 105
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/options/options.proto
@@ -0,0 +1,91 @@
+/* Test nanopb option parsing.
+ * options.expected lists the patterns that are searched for in the output.
+ */
+
+syntax = "proto2";
+
+import "nanopb.proto";
+
+// File level options
+option (nanopb_fileopt).max_size = 20;
+
+message Message1
+{
+    required string filesize = 1;
+}
+
+// Message level options
+message Message2
+{
+    option (nanopb_msgopt).max_size = 30;
+    required string msgsize = 1;
+}
+
+// Field level options
+message Message3
+{
+    option (nanopb_msgopt).msgid = 103;
+    required string fieldsize = 1 [(nanopb).max_size = 40];
+}
+
+// Forced callback field
+message Message4
+{
+    option (nanopb_msgopt).msgid = 104;
+    required int32 int32_callback = 1 [(nanopb).type = FT_CALLBACK];
+}
+
+// Short enum names
+enum Enum1
+{
+    option (nanopb_enumopt).long_names = false;
+    EnumValue1 = 1;
+    EnumValue2 = 2;
+}
+
+message EnumTest
+{
+    required Enum1 field = 1 [default = EnumValue2];
+}
+
+// Short enum names inside message
+message Message5
+{
+    option (nanopb_msgopt).msgid = 105;
+    enum Enum2
+    {
+       option (nanopb_enumopt).long_names = false;
+       EnumValue1 = 1;
+    }
+    required Enum2 field = 1 [default = EnumValue1];
+}
+
+// Packed structure
+message my_packed_struct
+{
+    option (nanopb_msgopt).packed_struct = true;
+    optional int32 myfield = 1;
+}
+
+// Message with ignored field
+message Message6
+{
+    required int32 field1 = 1;
+    optional int32 skipped_field = 2 [(nanopb).type = FT_IGNORE];
+}
+
+// Message that is skipped
+message SkippedMessage
+{
+    option (nanopb_msgopt).skip_message = true;
+    required int32 foo = 1;
+}
+
+// Message with oneof field
+message OneofMessage
+{
+    oneof foo {
+        int32 bar = 1;
+    }
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/package_name/SConscript
@@ -0,0 +1,38 @@
+# Check that alltypes test case works also when the .proto file defines
+# a package name.
+
+Import("env")
+
+def set_pkgname(src, dst, pkgname):
+    data = open(str(src)).read()
+    placeholder = '// package name placeholder'
+    assert placeholder in data
+    data = data.replace(placeholder, 'package %s;' % pkgname)
+    open(str(dst), 'w').write(data)
+
+# Build a modified alltypes.proto
+env.Command("alltypes.proto", "#alltypes/alltypes.proto",
+            lambda target, source, env: set_pkgname(source[0], target[0], 'test.package'))
+env.Command("alltypes.options", "#alltypes/alltypes.options", Copy("$TARGET", "$SOURCE"))
+env.NanopbProto(["alltypes", "alltypes.options"])
+
+# Build a modified encode_alltypes.c
+def modify_c(target, source, env):
+    '''Add package name to type names in .c file.'''
+
+    data = open(str(source[0]), 'r').read()
+    
+    type_names = ['AllTypes', 'MyEnum', 'HugeEnum']
+    for name in type_names:
+        data = data.replace(name, 'test_package_' + name)
+    
+    open(str(target[0]), 'w').write(data)
+    return 0
+env.Command("encode_alltypes.c", "#alltypes/encode_alltypes.c", modify_c)
+
+# Encode and compare results to original alltypes testcase
+enc = env.Program(["encode_alltypes.c", "alltypes.pb.c", "$COMMON/pb_encode.o", "$COMMON/pb_common.o"])
+refdec = "$BUILD/alltypes/decode_alltypes$PROGSUFFIX"
+env.RunTest(enc)
+env.Compare(["encode_alltypes.output", "$BUILD/alltypes/encode_alltypes.output"])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_118/SConscript
@@ -0,0 +1,12 @@
+# Regression test for Issue 118: Short enum names in imported proto files are not honoured
+
+Import("env")
+env = env.Clone()
+env.Append(PROTOCPATH = "#regression/issue_118")
+
+env.NanopbProto("enumdef")
+env.Object('enumdef.pb.c')
+
+env.NanopbProto(["enumuse", "enumdef.proto"])
+env.Object('enumuse.pb.c')
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_118/enumdef.proto
@@ -0,0 +1,8 @@
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+enum MyEnum {
+	option (nanopb_enumopt).long_names = false;
+	FOOBAR = 1;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_118/enumuse.proto
@@ -0,0 +1,7 @@
+syntax = "proto2";
+
+import 'enumdef.proto';
+
+message MyMessage {
+	required MyEnum myenum = 1 [default = FOOBAR];
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_125/SConscript
@@ -0,0 +1,9 @@
+# Regression test for Issue 125: Wrong identifier name for extension fields
+
+Import("env")
+
+env.NanopbProto(["extensionbug", "extensionbug.options"])
+env.Object('extensionbug.pb.c')
+
+env.Match(['extensionbug.pb.h', 'extensionbug.expected'])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_125/extensionbug.expected
@@ -0,0 +1,3 @@
+pb_extension_type_t Message2_extras
+uint32_t field2
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_125/extensionbug.options
@@ -0,0 +1,4 @@
+* type:FT_IGNORE
+
+Message2.extras type:FT_STATIC
+Message2.field2 type:FT_STATIC
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_125/extensionbug.proto
@@ -0,0 +1,18 @@
+syntax = "proto2";
+
+message Message1
+{
+	optional uint32	fieldA = 1;
+	extensions 30 to max;
+}
+
+message Message2
+{
+	extend Message1
+	{
+		optional Message2 extras = 30;
+	}
+	
+	optional uint32	field1 = 1;
+	optional uint32 field2 = 2;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_141/SConscript
@@ -0,0 +1,8 @@
+# Regression test for issue 141: wrong encoded size #define for oneof messages
+
+Import("env")
+
+env.NanopbProto("testproto")
+env.Object('testproto.pb.c')
+env.Match(['testproto.pb.h', 'testproto.expected'])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_141/testproto.expected
@@ -0,0 +1,7 @@
+define SubMessage_size \s* 88
+define OneOfMessage_size \s* 113
+define topMessage_size \s* 70
+define MyMessage1_size \s* 46
+define MyMessage2_size \s* 8
+define MyMessage3_size \s* 5
+define MyMessage4_size \s* 18
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_141/testproto.proto
@@ -0,0 +1,52 @@
+syntax = "proto2";
+
+import 'nanopb.proto';
+
+message SubMessage
+{
+    repeated int32 array = 1 [(nanopb).max_count = 8];
+}
+
+message OneOfMessage
+{
+    required int32 prefix = 1;
+    oneof values
+    {
+        int32 first = 5;
+        string second = 6 [(nanopb).max_size = 8];
+        SubMessage third = 7;
+    }
+    required int32 suffix = 99;
+}
+
+message topMessage {
+	required int32 start = 1;
+	oneof msg {
+		MyMessage1 msg1 = 2;
+		MyMessage2 msg2 = 3;
+	}
+	required int32 end = 4;
+}
+
+message MyMessage1 {
+	required uint32 n1 = 1;
+	required uint32 n2 = 2;
+	required string s = 3 [(nanopb).max_size = 32];
+}
+
+message MyMessage2 {
+	required uint32 num = 1;
+	required bool b = 2;
+}
+
+message MyMessage3 {
+	required bool bbb = 1;
+	required string ss = 2 [(nanopb).max_size = 1];
+}
+
+message MyMessage4 {
+	required bool bbbb = 1;
+	required string sss = 2 [(nanopb).max_size = 2];
+	required uint32 num = 3;
+	required uint32 num2 = 4;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_145/SConscript
@@ -0,0 +1,9 @@
+# Regression test for Issue 145: Allow /* */ and // comments in .options files
+
+Import("env")
+
+env.NanopbProto(["comments", "comments.options"])
+env.Object('comments.pb.c')
+
+env.Match(['comments.pb.h', 'comments.expected'])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_145/comments.expected
@@ -0,0 +1,3 @@
+char foo\[5\];
+char bar\[16\];
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_145/comments.options
@@ -0,0 +1,6 @@
+/* Block comment */
+# Line comment
+// Line comment
+DummyMessage.foo /* Block comment */ max_size:5
+DummyMessage.bar max_size:16 # Line comment ###
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_145/comments.proto
@@ -0,0 +1,7 @@
+syntax = "proto2";
+
+message DummyMessage {
+    required string foo = 1;
+    required string bar = 2;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_166/SConscript
@@ -0,0 +1,13 @@
+# Verify that the maximum encoded size is calculated properly
+# for enums.
+
+Import('env')
+
+env.NanopbProto('enums')
+
+p = env.Program(["enum_encoded_size.c",
+                 "enums.pb.c",
+                 "$COMMON/pb_encode.o",
+                 "$COMMON/pb_common.o"])
+env.RunTest(p)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_166/enum_encoded_size.c
@@ -0,0 +1,43 @@
+#include <stdio.h>
+#include <string.h>
+#include <pb_encode.h>
+#include "unittests.h"
+#include "enums.pb.h"
+
+int main()
+{
+    int status = 0;
+    
+    uint8_t buf[256];
+    SignedMsg msg1;
+    UnsignedMsg msg2;
+    pb_ostream_t s;
+    
+    {
+        COMMENT("Test negative value of signed enum");
+        /* Negative value should take up the maximum size */
+        msg1.value = SignedEnum_SE_MIN;
+        s = pb_ostream_from_buffer(buf, sizeof(buf));
+        TEST(pb_encode(&s, SignedMsg_fields, &msg1));
+        TEST(s.bytes_written == SignedMsg_size);
+        
+        COMMENT("Test positive value of signed enum");
+        /* Positive value should be smaller */
+        msg1.value = SignedEnum_SE_MAX;
+        s = pb_ostream_from_buffer(buf, sizeof(buf));
+        TEST(pb_encode(&s, SignedMsg_fields, &msg1));
+        TEST(s.bytes_written < SignedMsg_size);
+    }
+    
+    {
+        COMMENT("Test positive value of unsigned enum");
+        /* This should take up the maximum size */
+        msg2.value = UnsignedEnum_UE_MAX;
+        s = pb_ostream_from_buffer(buf, sizeof(buf));
+        TEST(pb_encode(&s, UnsignedMsg_fields, &msg2));
+        TEST(s.bytes_written == UnsignedMsg_size);
+    }
+    
+    return status;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_166/enums.proto
@@ -0,0 +1,18 @@
+syntax = "proto2";
+
+enum SignedEnum {
+    SE_MIN = -1;
+    SE_MAX = 255;
+}
+
+enum UnsignedEnum {
+    UE_MAX = 65536;
+}
+
+message SignedMsg {
+    required SignedEnum value = 1;
+}
+
+message UnsignedMsg {
+    required UnsignedEnum value = 1;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_172/SConscript
@@ -0,0 +1,16 @@
+# Verify that _size define is generated for messages that have
+# includes from another directory.
+
+Import('env')
+
+incpath = env.Clone()
+incpath.Append(PROTOCPATH="#regression/issue_172/submessage")
+incpath.Append(CPPPATH="$BUILD/regression/issue_172/submessage")
+incpath.NanopbProto('test')
+incpath.NanopbProto(['submessage/submessage', 'submessage/submessage.options'])
+
+p = incpath.Program(["msg_size.c",
+                     "test.pb.c",
+                     "submessage/submessage.pb.c"])
+
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_172/msg_size.c
@@ -0,0 +1,9 @@
+#include "test.pb.h"
+
+PB_STATIC_ASSERT(testmessage_size >= 1+1+1+1+16, TESTMESSAGE_SIZE_IS_WRONG)
+
+int main()
+{
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_172/submessage/submessage.options
@@ -0,0 +1 @@
+submessage.data max_size: 16
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_172/submessage/submessage.proto
@@ -0,0 +1,4 @@
+syntax = "proto2";
+message submessage {
+    required bytes data = 1;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_172/test.proto
@@ -0,0 +1,6 @@
+syntax = "proto2";
+import "submessage.proto";
+
+message testmessage {
+ optional submessage sub = 1;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_188/SConscript
@@ -0,0 +1,6 @@
+# Regression test for issue with Enums inside OneOf.
+
+Import('env')
+
+env.NanopbProto('oneof')
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_188/oneof.proto
@@ -0,0 +1,29 @@
+syntax = "proto2";
+
+message MessageOne
+{
+    required uint32 one = 1;
+    required uint32 two = 2;
+    required uint32 three = 3;
+    required int32 four = 4;
+}
+
+enum EnumTwo
+{
+    SOME_ENUM_1 = 1;
+    SOME_ENUM_2 = 5;
+    SOME_ENUM_3 = 6;
+    SOME_ENUM_4 = 9;
+    SOME_ENUM_5 = 10;
+    SOME_ENUM_6 = 12;
+    SOME_ENUM_7 = 39;  
+    SOME_ENUM_8 = 401;
+}
+
+message OneofMessage
+{
+    oneof payload {
+        MessageOne message = 1;
+        EnumTwo enum = 2;
+    }
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_195/SConscript
@@ -0,0 +1,10 @@
+# Regression test for Issue 195: Message size not calculated if a submessage includes 
+# bytes. Basically a non-working #define being generated.
+
+Import("env")
+
+env.NanopbProto(["test"])
+env.Object('test.pb.c')
+
+env.Match(['test.pb.h', 'test.expected'])
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_195/test.expected
@@ -0,0 +1 @@
+/\* TestMessage_size depends
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_195/test.proto
@@ -0,0 +1,8 @@
+message TestMessage {
+    required uint32 id = 1;
+    required bytes payload = 2;
+}
+message EncapsulatedMessage {
+    required uint32 id = 1;
+    required TestMessage test = 2;
+}
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_203/SConscript
@@ -0,0 +1,9 @@
+# Regression test for issue with multiple files generated at once
+
+Import('env')
+
+env.Command(['file1.pb.c', 'file1.pb.h', 'file2.pb.c', 'file2.pb.h'], ['file1.proto', 'file2.proto'],
+            env['NANOPB_PROTO_CMD'])
+
+env.Object('file1.pb.c')
+env.Object('file2.pb.c')
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_203/file1.proto
@@ -0,0 +1,10 @@
+syntax = "proto2";
+
+message SubMessage1 {
+	required int32 foo = 1;
+}
+
+message Message1 {
+	required SubMessage1 bar = 1;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_203/file2.proto
@@ -0,0 +1,10 @@
+syntax = "proto2";
+
+message SubMessage2 {
+	required int32 foo = 1;
+}
+
+message Message2 {
+	required SubMessage2 bar = 1;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_205/SConscript
@@ -0,0 +1,14 @@
+# Check that pb_release() correctly handles corrupted size fields of
+# static arrays.
+
+Import('env', 'malloc_env')
+
+env.NanopbProto('size_corruption')
+
+p = malloc_env.Program(["size_corruption.c",
+                         "size_corruption.pb.c",
+                         "$COMMON/pb_decode_with_malloc.o",
+                         "$COMMON/pb_common_with_malloc.o",
+                         "$COMMON/malloc_wrappers.o"])
+env.RunTest(p)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_205/size_corruption.c
@@ -0,0 +1,12 @@
+#include "size_corruption.pb.h"
+#include <pb_decode.h>
+
+int main()
+{
+    MainMessage msg = MainMessage_init_zero;
+    msg.bar_count = (pb_size_t)-1;
+    pb_release(MainMessage_fields, &msg);
+    
+    return 0;
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/regression/issue_205/size_corruption.proto
@@ -0,0 +1,11 @@
+syntax = "proto2";
+import 'nanopb.proto';
+
+message SubMessage {
+    repeated int32 foo = 1 [(nanopb).type = FT_POINTER];
+}
+
+message MainMessage {
+    repeated SubMessage bar = 1 [(nanopb).max_count = 5];
+}
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/site_scons/site_init.py
@@ -0,0 +1,109 @@
+import subprocess
+import sys
+import re
+
+try:
+    # Make terminal colors work on windows
+    import colorama
+    colorama.init()
+except ImportError:
+    pass
+
+def add_nanopb_builders(env):
+    '''Add the necessary builder commands for nanopb tests.'''
+
+    # Build command that runs a test program and saves the output
+    def run_test(target, source, env):
+        if len(source) > 1:
+            infile = open(str(source[1]))
+        else:
+            infile = None
+        
+        if env.has_key("COMMAND"):
+            args = [env["COMMAND"]]
+        else:
+            args = [str(source[0])]
+        
+        if env.has_key('ARGS'):
+            args.extend(env['ARGS'])
+        
+        print 'Command line: ' + str(args)
+        pipe = subprocess.Popen(args,
+                                stdin = infile,
+                                stdout = open(str(target[0]), 'w'),
+                                stderr = sys.stderr)
+        result = pipe.wait()
+        if result == 0:
+            print '\033[32m[ OK ]\033[0m   Ran ' + args[0]
+        else:
+            print '\033[31m[FAIL]\033[0m   Program ' + args[0] + ' returned ' + str(result)
+        return result
+        
+    run_test_builder = Builder(action = run_test,
+                               suffix = '.output')
+    env.Append(BUILDERS = {'RunTest': run_test_builder})
+
+    # Build command that decodes a message using protoc
+    def decode_actions(source, target, env, for_signature):
+        esc = env['ESCAPE']
+        dirs = ' '.join(['-I' + esc(env.GetBuildPath(d)) for d in env['PROTOCPATH']])
+        return '$PROTOC $PROTOCFLAGS %s --decode=%s %s <%s >%s' % (
+            dirs, env['MESSAGE'], esc(str(source[1])), esc(str(source[0])), esc(str(target[0])))
+
+    decode_builder = Builder(generator = decode_actions,
+                             suffix = '.decoded')
+    env.Append(BUILDERS = {'Decode': decode_builder})    
+
+    # Build command that encodes a message using protoc
+    def encode_actions(source, target, env, for_signature):
+        esc = env['ESCAPE']
+        dirs = ' '.join(['-I' + esc(env.GetBuildPath(d)) for d in env['PROTOCPATH']])
+        return '$PROTOC $PROTOCFLAGS %s --encode=%s %s <%s >%s' % (
+            dirs, env['MESSAGE'], esc(str(source[1])), esc(str(source[0])), esc(str(target[0])))
+
+    encode_builder = Builder(generator = encode_actions,
+                             suffix = '.encoded')
+    env.Append(BUILDERS = {'Encode': encode_builder})    
+
+    # Build command that asserts that two files be equal
+    def compare_files(target, source, env):
+        data1 = open(str(source[0]), 'rb').read()
+        data2 = open(str(source[1]), 'rb').read()
+        if data1 == data2:
+            print '\033[32m[ OK ]\033[0m   Files equal: ' + str(source[0]) + ' and ' + str(source[1])
+            return 0
+        else:
+            print '\033[31m[FAIL]\033[0m   Files differ: ' + str(source[0]) + ' and ' + str(source[1])
+            return 1
+
+    compare_builder = Builder(action = compare_files,
+                              suffix = '.equal')
+    env.Append(BUILDERS = {'Compare': compare_builder})
+
+    # Build command that checks that each pattern in source2 is found in source1.
+    def match_files(target, source, env):
+        data = open(str(source[0]), 'rU').read()
+        patterns = open(str(source[1]))
+        for pattern in patterns:
+            if pattern.strip():
+                invert = False
+                if pattern.startswith('! '):
+                    invert = True
+                    pattern = pattern[2:]
+                
+                status = re.search(pattern.strip(), data, re.MULTILINE)
+                
+                if not status and not invert:
+                    print '\033[31m[FAIL]\033[0m   Pattern not found in ' + str(source[0]) + ': ' + pattern
+                    return 1
+                elif status and invert:
+                    print '\033[31m[FAIL]\033[0m   Pattern should not exist, but does in ' + str(source[0]) + ': ' + pattern
+                    return 1
+        else:
+            print '\033[32m[ OK ]\033[0m   All patterns found in ' + str(source[0])
+            return 0
+
+    match_builder = Builder(action = match_files, suffix = '.matched')
+    env.Append(BUILDERS = {'Match': match_builder})
+    
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/site_scons/site_tools/nanopb.py
@@ -0,0 +1,126 @@
+'''
+Scons Builder for nanopb .proto definitions.
+
+This tool will locate the nanopb generator and use it to generate .pb.c and
+.pb.h files from the .proto files.
+
+Basic example
+-------------
+# Build myproto.pb.c and myproto.pb.h from myproto.proto
+myproto = env.NanopbProto("myproto")
+
+# Link nanopb core to the program
+env.Append(CPPPATH = "$NANOB")
+myprog = env.Program(["myprog.c", myproto, "$NANOPB/pb_encode.c", "$NANOPB/pb_decode.c"])
+
+Configuration options
+---------------------
+Normally, this script is used in the test environment of nanopb and it locates
+the nanopb generator by a relative path. If this script is used in another
+application, the path to nanopb root directory has to be defined:
+
+env.SetDefault(NANOPB = "path/to/nanopb")
+
+Additionally, the path to protoc and the options to give to protoc can be
+defined manually:
+
+env.SetDefault(PROTOC = "path/to/protoc")
+env.SetDefault(PROTOCFLAGS = "--plugin=protoc-gen-nanopb=path/to/protoc-gen-nanopb")
+'''
+
+import SCons.Action
+import SCons.Builder
+import SCons.Util
+import os.path
+
+class NanopbWarning(SCons.Warnings.Warning):
+    pass
+SCons.Warnings.enableWarningClass(NanopbWarning)
+
+def _detect_nanopb(env):
+    '''Find the path to nanopb root directory.'''
+    if env.has_key('NANOPB'):
+        # Use nanopb dir given by user
+        return env['NANOPB']
+    
+    p = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..', '..'))
+    if os.path.isdir(p) and os.path.isfile(os.path.join(p, 'pb.h')):
+        # Assume we are running under tests/site_scons/site_tools
+        return p
+    
+    raise SCons.Errors.StopError(NanopbWarning,
+        "Could not find the nanopb root directory")
+
+def _detect_protoc(env):
+    '''Find the path to the protoc compiler.'''
+    if env.has_key('PROTOC'):
+        # Use protoc defined by user
+        return env['PROTOC']
+    
+    n = _detect_nanopb(env)
+    p1 = os.path.join(n, 'generator-bin', 'protoc' + env['PROGSUFFIX'])
+    if os.path.exists(p1):
+        # Use protoc bundled with binary package
+        return env['ESCAPE'](p1)
+    
+    p = env.WhereIs('protoc')
+    if p:
+        # Use protoc from path
+        return env['ESCAPE'](p)
+    
+    raise SCons.Errors.StopError(NanopbWarning,
+        "Could not find the protoc compiler")
+
+def _detect_protocflags(env):
+    '''Find the options to use for protoc.'''
+    if env.has_key('PROTOCFLAGS'):
+        return env['PROTOCFLAGS']
+    
+    p = _detect_protoc(env)
+    n = _detect_nanopb(env)
+    p1 = os.path.join(n, 'generator-bin', 'protoc' + env['PROGSUFFIX'])
+    if p == env['ESCAPE'](p1):
+        # Using the bundled protoc, no options needed
+        return ''
+    
+    e = env['ESCAPE']
+    if env['PLATFORM'] == 'win32':
+        return e('--plugin=protoc-gen-nanopb=' + os.path.join(n, 'generator', 'protoc-gen-nanopb.bat'))
+    else:
+        return e('--plugin=protoc-gen-nanopb=' + os.path.join(n, 'generator', 'protoc-gen-nanopb'))
+
+def _nanopb_proto_actions(source, target, env, for_signature):
+    esc = env['ESCAPE']
+    dirs = ' '.join(['-I' + esc(env.GetBuildPath(d)) for d in env['PROTOCPATH']])
+    return '$PROTOC $PROTOCFLAGS %s --nanopb_out=. %s' % (dirs, esc(str(source[0])))
+
+def _nanopb_proto_emitter(target, source, env):
+    basename = os.path.splitext(str(source[0]))[0]
+    target.append(basename + '.pb.h')
+    
+    if os.path.exists(basename + '.options'):
+        source.append(basename + '.options')
+    
+    return target, source
+
+_nanopb_proto_builder = SCons.Builder.Builder(
+    generator = _nanopb_proto_actions,
+    suffix = '.pb.c',
+    src_suffix = '.proto',
+    emitter = _nanopb_proto_emitter)
+       
+def generate(env):
+    '''Add Builder for nanopb protos.'''
+    
+    env['NANOPB'] = _detect_nanopb(env)
+    env['PROTOC'] = _detect_protoc(env)
+    env['PROTOCFLAGS'] = _detect_protocflags(env)
+    
+    env.SetDefault(PROTOCPATH = ['.', os.path.join(env['NANOPB'], 'generator', 'proto')])
+    
+    env.SetDefault(NANOPB_PROTO_CMD = '$PROTOC $PROTOCFLAGS --nanopb_out=. $SOURCES')
+    env['BUILDERS']['NanopbProto'] = _nanopb_proto_builder
+    
+def exists(env):
+    return _detect_protoc(env) and _detect_protoc_opts(env)
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/special_characters/SConscript
@@ -0,0 +1,6 @@
+# Test that special characters in .proto filenames work.
+
+Import('env')
+
+env.NanopbProto("funny-proto+name has.characters.proto")
+env.Object("funny-proto+name has.characters.pb.c")
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/special_characters/funny-proto+name has.characters.proto	
@@ -0,0 +1 @@
+syntax="proto2";
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/splint/SConscript
@@ -0,0 +1,16 @@
+# Check the nanopb core using splint
+
+Import('env')
+
+p = env.WhereIs('splint')
+
+if p:
+    env.Command('pb_decode.splint', '$NANOPB/pb_decode.c',
+        'splint -f splint/splint.rc $SOURCE 2> $TARGET')
+
+    env.Command('pb_encode.splint', '$NANOPB/pb_encode.c',
+        'splint -f splint/splint.rc $SOURCE 2> $TARGET')
+
+    env.Command('pb_common.splint', '$NANOPB/pb_common.c',
+        'splint -f splint/splint.rc $SOURCE 2> $TARGET')
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tests/splint/splint.rc
@@ -0,0 +1,37 @@
++checks
++partial
++matchanyintegral
++strictlib
+-nullassign
+-predboolint
+-predboolptr
++ptrnegate
+-switchloopbreak
++ignoresigns
+-infloopsuncon
+-type
+
+# splint's memory checks don't quite work without annotations
+-mustfreeonly
+-compmempass
+-nullret
+-observertrans
+-statictrans
+-compdestroy
+-nullpass
+-nullstate
+-compdef
+-usereleased
+-temptrans
+-dependenttrans
+-kepttrans
+-branchstate
+-immediatetrans
+-mustfreefresh
+
+# These tests give false positives, compiler typically has
+# better warnings for these.
+-noret
+-noeffect
+-usedef
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tools/make_linux_package.sh
@@ -0,0 +1,47 @@
+#!/bin/bash
+
+# Run this script in the top nanopb directory to create a binary package
+# for Linux users.
+
+set -e
+set -x
+
+VERSION=`git describe --always`-linux-x86
+DEST=dist/$VERSION
+
+rm -rf $DEST
+mkdir -p $DEST
+
+# Export the files from newest commit
+git archive HEAD | tar x -C $DEST
+
+# Rebuild the Python .proto files
+make -BC $DEST/generator/proto
+
+# Make the nanopb generator available as a protoc plugin
+cp $DEST/generator/nanopb_generator.py $DEST/generator/protoc-gen-nanopb.py
+
+# Package the Python libraries
+( cd $DEST/generator; bbfreeze nanopb_generator.py protoc-gen-nanopb.py )
+mv $DEST/generator/dist $DEST/generator-bin
+
+# Remove temp file
+rm $DEST/generator/protoc-gen-nanopb.py
+
+# Package the protoc compiler
+cp `which protoc` $DEST/generator-bin/protoc.bin
+LIBPROTOC=$(ldd `which protoc` | grep -o '/.*libprotoc[^ ]*')
+LIBPROTOBUF=$(ldd `which protoc` | grep -o '/.*libprotobuf[^ ]*')
+cp $LIBPROTOC $LIBPROTOBUF $DEST/generator-bin/
+cat > $DEST/generator-bin/protoc << EOF
+#!/bin/bash
+SCRIPTDIR=\$(dirname "\$0")
+export LD_LIBRARY_PATH=\$SCRIPTDIR
+export PATH=\$SCRIPTDIR:\$PATH
+exec "\$SCRIPTDIR/protoc.bin" "\$@"
+EOF
+chmod +x $DEST/generator-bin/protoc
+
+# Tar it all up
+( cd dist; tar -czf $VERSION.tar.gz $VERSION )
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tools/make_mac_package.sh
@@ -0,0 +1,49 @@
+#!/bin/bash
+
+# Run this script in the top nanopb directory to create a binary package
+# for Mac OS X users.
+
+# Requires: protobuf, python-protobuf, pyinstaller
+
+set -e
+set -x
+
+VERSION=`git describe --always`-macosx-x86
+DEST=dist/$VERSION
+
+rm -rf $DEST
+mkdir -p $DEST
+
+# Export the files from newest commit
+git archive HEAD | tar x -C $DEST
+
+# Rebuild the Python .proto files
+make -BC $DEST/generator/proto
+
+# Package the Python libraries
+( cd $DEST/generator; pyinstaller nanopb_generator.py )
+mv $DEST/generator/dist/nanopb_generator $DEST/generator-bin
+
+# Remove temp files
+rm -rf $DEST/generator/dist $DEST/generator/build $DEST/generator/nanopb_generator.spec
+
+# Make the nanopb generator available as a protoc plugin
+cp $DEST/generator-bin/nanopb_generator $DEST/generator-bin/protoc-gen-nanopb
+
+# Package the protoc compiler
+cp `which protoc` $DEST/generator-bin/protoc.bin
+LIBPROTOC=$(otool -L `which protoc` | grep -o '/.*libprotoc[^ ]*')
+LIBPROTOBUF=$(otool -L `which protoc` | grep -o '/.*libprotobuf[^ ]*')
+cp $LIBPROTOC $LIBPROTOBUF $DEST/generator-bin/
+cat > $DEST/generator-bin/protoc << EOF
+#!/bin/bash
+SCRIPTDIR=\$(dirname "\$0")
+export DYLD_LIBRARY_PATH=\$SCRIPTDIR
+export PATH=\$SCRIPTDIR:\$PATH
+exec "\$SCRIPTDIR/protoc.bin" "\$@"
+EOF
+chmod +x $DEST/generator-bin/protoc
+
+# Tar it all up
+( cd dist; tar -czf $VERSION.tar.gz $VERSION )
+
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tools/make_windows_package.sh
@@ -0,0 +1,55 @@
+#!/bin/bash
+
+# Run this script in the top nanopb directory to create a binary package
+# for Windows users. This script is designed to run under MingW/MSYS bash
+# and requires the following tools: git, make, zip, unix2dos
+
+set -e
+set -x
+
+VERSION=`git describe --always`-windows-x86
+DEST=dist/$VERSION
+
+rm -rf $DEST
+mkdir -p $DEST
+
+# Export the files from newest commit
+git archive HEAD | tar x -C $DEST
+
+# Rebuild the Python .proto files
+make -BC $DEST/generator/proto
+
+# Make the nanopb generator available as a protoc plugin
+cp $DEST/generator/nanopb_generator.py $DEST/generator/protoc-gen-nanopb.py
+
+# Package the Python libraries
+( cd $DEST/generator; bbfreeze nanopb_generator.py protoc-gen-nanopb.py )
+mv $DEST/generator/dist $DEST/generator-bin
+
+# Remove temp file
+rm $DEST/generator/protoc-gen-nanopb.py
+
+# The python interpreter requires MSVCR90.dll.
+# FIXME: Find a way around hardcoding this path
+cp /c/windows/winsxs/x86_microsoft.vc90.crt_1fc8b3b9a1e18e3b_9.0.30729.4974_none_50940634bcb759cb/MSVCR90.DLL $DEST/generator-bin/
+cat > $DEST/generator-bin/Microsoft.VC90.CRT.manifest <<EOF
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+    <noInheritable></noInheritable>
+    <assemblyIdentity type="win32" name="Microsoft.VC90.CRT" version="9.0.21022.8" processorArchitecture="x86" publicKeyToken="1fc8b3b9a1e18e3b"></assemblyIdentity>
+    <file name="msvcr90.dll" hashalg="SHA1" hash="e0dcdcbfcb452747da530fae6b000d47c8674671"><asmv2:hash xmlns:asmv2="urn:schemas-microsoft-com:asm.v2" xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"><dsig:Transforms><dsig:Transform Algorithm="urn:schemas-microsoft-com:HashTransforms.Identity"></dsig:Transform></dsig:Transforms><dsig:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"></dsig:DigestMethod><dsig:DigestValue>KSaO8M0iCtPF6YEr79P1dZsnomY=</dsig:DigestValue></asmv2:hash></file> <file name="msvcp90.dll" hashalg="SHA1" hash="81efe890e4ef2615c0bb4dda7b94bea177c86ebd"><asmv2:hash xmlns:asmv2="urn:schemas-microsoft-com:asm.v2" xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"><dsig:Transforms><dsig:Transform Algorithm="urn:schemas-microsoft-com:HashTransforms.Identity"></dsig:Transform></dsig:Transforms><dsig:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"></dsig:DigestMethod><dsig:DigestValue>ojDmTgpYMFRKJYkPcM6ckpYkWUU=</dsig:DigestValue></asmv2:hash></file> <file name="msvcm90.dll" hashalg="SHA1" hash="5470081b336abd7b82c6387567a661a729483b04"><asmv2:hash xmlns:asmv2="urn:schemas-microsoft-com:asm.v2" xmlns:dsig="http://www.w3.org/2000/09/xmldsig#"><dsig:Transforms><dsig:Transform Algorithm="urn:schemas-microsoft-com:HashTransforms.Identity"></dsig:Transform></dsig:Transforms><dsig:DigestMethod Algorithm="http://www.w3.org/2000/09/xmldsig#sha1"></dsig:DigestMethod><dsig:DigestValue>tVogb8kezDre2mXShlIqpp8ErIg=</dsig:DigestValue></asmv2:hash></file>
+</assembly>
+EOF
+
+# Package the protoc compiler
+cp `which protoc.exe` $DEST/generator-bin/
+cp `which MSVCR100.DLL` $DEST/generator-bin/
+cp `which MSVCP100.DLL` $DEST/generator-bin/
+
+# Convert line breaks for convenience
+find $DEST -name '*.c' -o -name '*.h' -o -name '*.txt' \
+    -o -name '*.proto' -o -name '*.py' -o -name '*.options' \
+    -exec unix2dos '{}' \;
+
+# Zip it all up
+( cd dist; zip -r $VERSION.zip $VERSION )
--- /dev/null
+++ grpc-1.0.0/third_party/nanopb/tools/set_version.sh
@@ -0,0 +1,10 @@
+#!/bin/bash
+
+# Run this from the top directory of nanopb tree.
+# e.g. user@localhost:~/nanopb$ tools/set_version.sh nanopb-0.1.9-dev
+# It sets the version number in pb.h and generator/nanopb_generator.py.
+
+sed -i -e 's/nanopb_version\s*=\s*"[^"]*"/nanopb_version = "'$1'"/' generator/nanopb_generator.py
+sed -i -e 's/#define\s*NANOPB_VERSION\s*.*/#define NANOPB_VERSION '$1'/' pb.h
+
+
